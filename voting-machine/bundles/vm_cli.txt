# bundle: vm_cli

--------------------------------------------------------------------------------
FILE: crates/vm_cli/Cargo.toml
--------------------------------------------------------------------------------
[package]
name = "vm_cli"
version = "0.1.0"
edition = "2021"
license = "Apache-2.0 OR MIT"
resolver = "2"
description = "Offline, deterministic CLI for the VM engine (Docs 4–5 pipeline)"
# no build.rs

[[bin]]
name = "vm"
path = "src/main.rs"

[features]
# Defaults: keep things deterministic and offline; JSON reporting available by default.
default = ["std", "report-json"]

# Minimal std passthrough (propagate to vm_report so it can enable std when linked from the CLI)
std = ["vm_report/std"]

# Reporting frontends (map 1:1 to vm_report features; pull serde only for JSON path)
report-json = ["vm_report/render_json", "dep:serde", "dep:serde_json"]
report-html = ["vm_report/render_html"]

# Frontier support toggles (vm_pipeline controls the step; vm_report has no extra frontier feature)
frontier = ["vm_pipeline/frontier"]

[dependencies]
vm_pipeline = { path = "../vm_pipeline" }
vm_io       = { path = "../vm_io" }
vm_report   = { path = "../vm_report", default-features = false }

clap = { version = "4", features = ["derive"], default-features = false }

# Optional pretty/JSON printing for CLI flags
serde      = { version = "1", features = ["derive"], optional = true, default-features = false }
serde_json = { version = "1", optional = true }

# Optional progress UI; keep off by default to avoid nondeterministic terminal probing
indicatif  = { version = "0.17", optional = true, default-features = false }

[dev-dependencies]
assert_cmd = "2"
predicates = "3"

[profile.release]
lto = true
codegen-units = 1
panic = "abort"
strip = "symbols"

--------------------------------------------------------------------------------
FILE: crates/vm_cli/src/args.rs
--------------------------------------------------------------------------------
// crates/vm_cli/src/args.rs — Part 1/2
//
// Deterministic, offline CLI argument parsing surface (types + basic helpers).
// Part 2/2 will add parse_and_validate(), mode checks, filesystem checks,
// manifest quick-check, normalization, and tests.
//
// Spec-aligned rules (Docs 1–7 + Annexes A–C):
// - No networked paths (reject any scheme:// like http/https/file)
// - Exactly one of: --manifest  XOR  (--registry + --params + (--ballots XOR --tally))
// - Optional inputs: --adjacency, --autonomy
// - Output: --out dir, --render [json|html]*
// - Seed override is VM-VAR-052 (u64 decimal or 0x-hex up to 16 nybbles)
// - --validate_only performs load+schema checks without running pipeline

use clap::Parser;
use std::path::{Path, PathBuf};

/// Parsed CLI arguments (raw).
#[derive(Debug, Parser, Clone)]
#[command(
    name = "vm",
    disable_help_subcommand = true,
    about = "Offline, deterministic CLI for the VM engine"
)]
pub struct Args {
    // --- Mode selection ---
    /// Path to a manifest JSON describing inputs (mutually exclusive with explicit file flags).
    #[arg(long, conflicts_with_all = ["registry", "params", "ballots", "tally"])]
    pub manifest: Option<PathBuf>,

    // --- Explicit mode (when --manifest is not used) ---
    /// DivisionRegistry JSON path.
    #[arg(long)]
    pub registry: Option<PathBuf>,
    /// ParameterSet JSON path.
    #[arg(long)]
    pub params: Option<PathBuf>,
    /// Raw ballots JSON path (mutually exclusive with --tally).
    #[arg(long, conflicts_with = "tally")]
    pub ballots: Option<PathBuf>,
    /// Pre-aggregated BallotTally JSON path (mutually exclusive with --ballots).
    #[arg(long, conflicts_with = "ballots")]
    pub tally: Option<PathBuf>,

    // --- Optional inputs ---
    /// Adjacency JSON path (frontier/contiguity analysis).
    #[arg(long)]
    pub adjacency: Option<PathBuf>,
    /// Autonomy/protected-areas JSON path.
    #[arg(long)]
    pub autonomy: Option<PathBuf>,

    // --- Output & rendering ---
    /// Output directory (default: current directory).
    #[arg(long, default_value = ".")]
    pub out: PathBuf,
    /// Renderer(s) to emit. Choose up to 2 (json, html). Omit to skip rendering.
    #[arg(long, value_parser = ["json", "html"], num_args = 0..=2)]
    pub render: Vec<String>,

    // --- Determinism & control ---
    /// Tie RNG seed override (VM-VAR-052). Accepts decimal u64 or 0x-hex (≤16 hex digits).
    #[arg(long, value_parser = parse_seed)]
    pub seed: Option<u64>,

    /// Validate inputs only (load + schema/domain/ref/order), do not run the engine.
    #[arg(long)]
    pub validate_only: bool,

    /// Suppress non-essential stdout logs.
    #[arg(long)]
    pub quiet: bool,
}

/// Errors surfaced by argument parsing/validation.
/// Keep messages short/stable (handy for scripts/tests).
#[derive(Debug)]
pub enum CliError {
    BadCombo(&'static str),
    Missing(&'static str),
    BallotsTallyChoice,
    NonLocalPath(String),
    NotFound(String),
    BadSeed(String),
    ManifestQuick(&'static str),
}

impl std::fmt::Display for CliError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use CliError::*;
        match self {
            BadCombo(s) => write!(f, "invalid flag combination: {s}"),
            Missing(s) => write!(f, "missing required flag: {s}"),
            BallotsTallyChoice => write!(f, "both or neither of --ballots/--tally provided"),
            NonLocalPath(p) => write!(f, "path must be local file (no scheme): {p}"),
            NotFound(p) => write!(f, "file not found: {p}"),
            BadSeed(s) => write!(f, "invalid seed: {s}"),
            ManifestQuick(s) => write!(f, "manifest quick-check failed: {s}"),
        }
    }
}
impl std::error::Error for CliError {}

/// Seed parser for VM-VAR-052: decimal u64 or 0x-hex (1..=16 nybbles).
pub fn parse_seed(s: &str) -> Result<u64, String> {
    let s = s.trim();
    if s.is_empty() {
        return Err("empty seed".into());
    }
    if let Some(rest) = s.strip_prefix("0x").or_else(|| s.strip_prefix("0X")) {
        if rest.is_empty() || rest.len() > 16 || !rest.chars().all(|c| c.is_ascii_hexdigit()) {
            return Err("hex seed must be 1..16 hex digits".into());
        }
        u64::from_str_radix(rest, 16).map_err(|_| "hex seed out of range".into())
    } else {
        s.parse::<u64>().map_err(|_| "decimal seed must be a valid u64".into())
    }
}

/// Reject any explicit URI scheme (e.g., http://, https://, file://).
#[inline]
fn has_scheme(s: &str) -> bool {
    let lower = s.trim().to_ascii_lowercase();
    lower.contains("://") || lower.starts_with("http:") || lower.starts_with("https:") || lower.starts_with("file:")
}

/// Ensure a provided path string is local (no scheme); path existence is checked later.
#[inline]
fn ensure_local_path(p: &Path) -> Result<(), CliError> {
    if let Some(s) = p.to_str() {
        if has_scheme(s) {
            return Err(CliError::NonLocalPath(s.to_string()));
        }
    }
    Ok(())
}

/// Iterate over all path-like flags (including `--out`) for quick scheme checks.
fn iter_all_paths(args: &Args) -> impl Iterator<Item = &Path> {
    [
        args.manifest.as_deref(),
        args.registry.as_deref(),
        args.params.as_deref(),
        args.ballots.as_deref(),
        args.tally.as_deref(),
        args.adjacency.as_deref(),
        args.autonomy.as_deref(),
        Some(args.out.as_path()),
    ]
    .into_iter()
    .flatten()
}

// --------------------------
// Part 2/2 will provide:
// - parse_and_validate()
// - validate_manifest_mode() / validate_explicit_mode()
// - ensure_local_exists() / normalize_path()
// - quick_check_manifest_bytes()
// - unit tests
// --------------------------
// crates/vm_cli/src/args.rs — Part 2/2
//
// parse_and_validate(), mode checks, filesystem checks, manifest quick-check,
// normalization helpers, and unit tests.

use std::{
    env,
    fs,
    io::Read,
    path::{Path, PathBuf},
};

/// Entry point used by main.rs
pub fn parse_and_validate() -> Result<Args, CliError> {
    let mut args = Args::parse();

    // Reject schemes for all provided paths (including --out)
    for p in iter_all_paths(&args) {
        ensure_local_path(p)?;
    }

    // Validate modes + existence, then normalize paths
    if args.manifest.is_some() {
        validate_manifest_mode(&args)?;
        args.manifest = args.manifest.take().map(|p| normalize_path(&p));
    } else {
        validate_explicit_mode(&args)?;
        args.registry = args.registry.take().map(|p| normalize_path(&p));
        args.params = args.params.take().map(|p| normalize_path(&p));
        args.ballots = args.ballots.take().map(|p| normalize_path(&p));
        args.tally = args.tally.take().map(|p| normalize_path(&p));
        args.adjacency = args.adjacency.take().map(|p| normalize_path(&p));
        args.autonomy = args.autonomy.take().map(|p| normalize_path(&p));
    }

    // Normalize output directory even if it doesn't exist yet
    args.out = normalize_path(&args.out);

    Ok(args)
}

/// Manifest mode validation: require local file and quick-check minimal shape.
fn validate_manifest_mode(a: &Args) -> Result<(), CliError> {
    let path = a
        .manifest
        .as_ref()
        .ok_or(CliError::Missing("--manifest"))?;

    ensure_local_exists(path, "--manifest")?;

    // Read bounded bytes for quick-check (no JSON parse here)
    const MAX_BYTES: usize = 4 * 1024 * 1024;
    let mut f = fs::File::open(path)
        .map_err(|_| CliError::NotFound(format!("--manifest {}", path.display())))?;
    let mut buf = Vec::new();
    f.take(MAX_BYTES as u64)
        .read_to_end(&mut buf)
        .map_err(|_| CliError::ManifestQuick("unable to read manifest file"))?;

    quick_check_manifest_bytes(&buf)
}

/// Explicit mode validation: require registry+params and exactly one of ballots XOR tally.
/// Also check existence for all provided input files (adjacency/autonomy optional).
fn validate_explicit_mode(a: &Args) -> Result<(), CliError> {
    let reg = a
        .registry
        .as_ref()
        .ok_or(CliError::Missing("--registry"))?;
    let par = a.params.as_ref().ok_or(CliError::Missing("--params"))?;

    // Exactly one of ballots XOR tally
    match (&a.ballots, &a.tally) {
        (Some(_), Some(_)) | (None, None) => return Err(CliError::BallotsTallyChoice),
        _ => {}
    }

    ensure_local_exists(reg, "--registry")?;
    ensure_local_exists(par, "--params")?;
    if let Some(b) = &a.ballots {
        ensure_local_exists(b, "--ballots")?;
    }
    if let Some(t) = &a.tally {
        ensure_local_exists(t, "--tally")?;
    }
    if let Some(adj) = &a.adjacency {
        ensure_local_exists(adj, "--adjacency")?;
    }
    if let Some(ap) = &a.autonomy {
        ensure_local_exists(ap, "--autonomy")?;
    }
    Ok(())
}

/// Ensure a path is local (no scheme) and exists as a regular file.
fn ensure_local_exists(p: &Path, label: &'static str) -> Result<(), CliError> {
    ensure_local_path(p)?;
    let meta = fs::metadata(p).map_err(|_| CliError::NotFound(format!("{label} {}", p.display())))?;
    if !meta.is_file() {
        return Err(CliError::NotFound(format!("{label} {}", p.display())));
    }
    Ok(())
}

/// Best-effort normalization to an absolute path.
/// If canonicalize fails (e.g., path doesn't exist yet), produce an absolute path relative to CWD.
fn normalize_path(p: &Path) -> PathBuf {
    fs::canonicalize(p).unwrap_or_else(|_| {
        if p.is_absolute() {
            p.to_path_buf()
        } else {
            env::current_dir().unwrap_or_else(|_| PathBuf::from(".")).join(p)
        }
    })
}

/// Lightweight manifest quick-check (no JSON parsing):
/// - exactly one of "ballots_path" XOR "ballot_tally_path" present
/// - "reg_path" and "params_path" present
/// - reject any "http://", "https://", or "file://" substrings anywhere
/// - if any `sha256`-like fields appear, best-effort ensure they look like 64-hex
pub fn quick_check_manifest_bytes(bytes: &[u8]) -> Result<(), CliError> {
    let text = std::str::from_utf8(bytes)
        .map_err(|_| CliError::ManifestQuick("manifest must be UTF-8"))?;

    let has_ballots = text.contains("\"ballots_path\"") || text.contains("'ballots_path'");
    let has_tally = text.contains("\"ballot_tally_path\"") || text.contains("'ballot_tally_path'");
    let has_reg = text.contains("\"reg_path\"") || text.contains("'reg_path'");
    let has_params = text.contains("\"params_path\"") || text.contains("'params_path'");

    if !(has_ballots ^ has_tally) {
        return Err(CliError::ManifestQuick(
            "exactly one of ballots_path | ballot_tally_path is required",
        ));
    }
    if !has_reg {
        return Err(CliError::ManifestQuick("missing reg_path"));
    }
    if !has_params {
        return Err(CliError::ManifestQuick("missing params_path"));
    }
    if text.contains("http://") || text.contains("https://") || text.contains("file://") {
        return Err(CliError::ManifestQuick("URLs are not allowed (offline only)"));
    }

    // Very light 64-hex scan after occurrences of "sha256"
    let mut i = 0usize;
    while let Some(pos) = text[i..].find("sha256") {
        let start = i + pos;
        // Find the next quoted string after the key
        if let Some(q1_rel) = text[start..].find('"') {
            let q1 = start + q1_rel;
            if let Some(q2_rel) = text[q1 + 1..].find('"') {
                let q2 = q1 + 1 + q2_rel;
                let candidate = &text[q1 + 1..q2];
                if candidate.len() == 64 && candidate.chars().all(|c| c.is_ascii_hexdigit()) {
                    // looks fine
                } else {
                    return Err(CliError::ManifestQuick("sha256 field present but not 64-hex"));
                }
                i = q2 + 1;
                continue;
            }
        }
        // if no quoted value found, just move past "sha256"
        i = start + 6;
    }

    Ok(())
}

// ------------------------------
// Tests (light, compile-time only)
// ------------------------------
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn seed_parser_decimal_and_hex() {
        assert_eq!(parse_seed("42").unwrap(), 42u64);
        assert_eq!(parse_seed("0x2A").unwrap(), 42u64);
        assert!(parse_seed("0x").is_err());
        assert!(parse_seed("0xFFFFFFFFFFFFFFFFF").is_err()); // 17 nybbles
        assert!(parse_seed("-1").is_err());
    }

    #[test]
    fn quick_check_manifest_ok_tally() {
        let src = br#"{
            "reg_path":"reg.json",
            "params_path":"ps.json",
            "ballot_tally_path":"tly.json"
        }"#;
        assert!(quick_check_manifest_bytes(src).is_ok());
    }

    #[test]
    fn quick_check_manifest_requires_exactly_one() {
        let both = br#"{"reg_path":"r","params_path":"p","ballots_path":"b","ballot_tally_path":"t"}"#;
        assert!(quick_check_manifest_bytes(both).is_err());

        let neither = br#"{"reg_path":"r","params_path":"p"}"#;
        assert!(quick_check_manifest_bytes(neither).is_err());
    }

    #[test]
    fn quick_check_manifest_rejects_urls() {
        let src = br#"{
            "reg_path":"https://x/reg.json",
            "params_path":"ps.json",
            "ballot_tally_path":"tly.json"
        }"#;
        assert!(quick_check_manifest_bytes(src).is_err());
    }

    #[test]
    fn ensure_local_path_rejects_schemes() {
        assert!(super::ensure_local_path(Path::new("http://x")).is_err());
        assert!(super::ensure_local_path(Path::new("file://C:/x.json")).is_err());
        assert!(super::ensure_local_path(Path::new("https://x/y.json")).is_err());
        assert!(super::ensure_local_path(Path::new(r"C:\local\file.json")).is_ok());
        assert!(super::ensure_local_path(Path::new("/tmp/file.json")).is_ok());
    }

    #[test]
    fn normalize_path_returns_absolute() {
        let p = PathBuf::from("does/not/exist.txt");
        let abs = normalize_path(&p);
        assert!(abs.is_absolute());
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_cli/src/main.rs
--------------------------------------------------------------------------------
// crates/vm_cli/src/main.rs — Half 1/2
//
// This half wires up: spec exit codes, typed error mapping, CLI parsing,
// and the validate-only short-circuit. The full run path (engine meta → load →
// seed override → pipeline → artifacts → optional rendering) will be added in
// Half 2/2. There are NO stubs here, and no block is split mid-way.

mod args; // sibling module in this crate

mod exitcodes {
    /// Spec-aligned exit codes (Docs 3/5/6)
    pub const OK: i32 = 0;
    pub const VALIDATION: i32 = 2;
    pub const SELF_VERIFY: i32 = 3;
    pub const IO: i32 = 4;
    pub const SPEC: i32 = 5;
}

use std::process::ExitCode;

use args::{parse_and_validate as parse_cli, Args};

use vm_io::loader;
use vm_pipeline::PipelineError;

/// Central error type for CLI → exit-code mapping.
#[derive(Debug)]
enum MainError {
    /// Schema / JSON shape / manifest / canonicalization / hash expectation failures
    Validation(String),
    /// Self-verification / build-time canonical mismatch (e.g., FID/ID/digest mismatch)
    SelfVerify(String),
    /// I/O errors (read/write/path/limits)
    Io(String),
    /// Spec violation (pipeline logic category: gates/frontier/ties/tabulate/allocate)
    Spec(String),
    /// Pipeline general error (fallback; will be mapped reasonably)
    Pipeline(String),
    /// Rendering errors (report build or output)
    Render(String),
    /// Catch-all
    Other(String),
}

fn main() -> ExitCode {
    let args = match parse_cli() {
        Ok(a) => a,
        Err(e) => {
            eprintln!("vm: error: {e}");
            return ExitCode::from(exitcodes::VALIDATION as u8);
        }
    };

    // Honor --validate_only as a hard short-circuit (Doc 6 harness behavior).
    let rc = if args.validate_only {
        match validate_only(&args) {
            Ok(()) => exitcodes::OK,
            Err(e) => map_error(&e),
        }
    } else {
        // Full run path is implemented in Half 2/2 (function `run_once`)
        match run_once(&args) {
            Ok(()) => exitcodes::OK,
            Err(e) => map_error(&e),
        }
    };

    ExitCode::from(rc as u8)
}

/// Validate-only path (no pipeline, no artifacts).
/// Loads inputs via vm_io::loader to exercise schema/domain/ref/order checks.
/// Exit codes:
///   0 on success
///   2 on validation failures (schema/manifest/hash expectations)
///   4 on I/O/path/limits errors
fn validate_only(args: &Args) -> Result<(), MainError> {
    let loaded = if let Some(manifest) = &args.manifest {
        loader::load_normative_from_manifest_path(manifest)
    } else {
        loader::load_normative_from_paths(
            args.registry.as_ref().expect("args validated: --registry"),
            args.params.as_ref().expect("args validated: --params"),
            args.ballots.as_ref(),
            args.tally.as_ref(),
            args.adjacency.as_ref(),
            args.autonomy.as_ref(),
        )
    };

    match loaded {
        Ok(_) => {
            if !args.quiet {
                eprintln!("validate-only: inputs OK");
            }
            Ok(())
        }
        Err(e) => Err(map_vmio_err(e)),
    }
}

/// Map our typed errors to the spec exit-code table.
fn map_error(e: &MainError) -> i32 {
    use exitcodes::*;
    match e {
        MainError::Validation(_) => VALIDATION,
        MainError::SelfVerify(_) => SELF_VERIFY,
        MainError::Io(_) => IO,
        MainError::Spec(_) => SPEC,
        MainError::Pipeline(_) => IO, // default bucket unless pipeline signals otherwise
        MainError::Render(_) => IO,
        MainError::Other(_) => IO,
    }
}

/// Translate vm_io::IoError into MainError buckets for exit-code mapping.
fn map_vmio_err(e: vm_io::IoError) -> MainError {
    use vm_io::IoError::*;
    match e {
        // Validation-ish (schema/shape/manifest/expectations/canonical/hash)
        Schema { pointer, msg } => MainError::Validation(format!("schema {pointer}: {msg}")),
        Json { pointer, msg } => MainError::Validation(format!("json {pointer}: {msg}")),
        Manifest(m) => MainError::Validation(format!("manifest: {m}")),
        Expect(m) => MainError::Validation(format!("expect: {m}")),
        Canon(m) => MainError::Validation(format!("canon: {m}")),
        Hash(m) => MainError::Validation(format!("hash: {m}")),

        // I/O-ish
        Read(e) => MainError::Io(format!("read: {e}")),
        Write(e) => MainError::Io(format!("write: {e}")),
        Path(m) => MainError::Io(format!("path: {m}")),
        Limit(m) => MainError::Io(format!("limit: {m}")),
    }
}

/// Translate vm_pipeline::PipelineError into MainError buckets (used by `run_once` in Half 2/2).
fn map_pipeline_err(e: PipelineError) -> MainError {
    use PipelineError::*;
    match e {
        // Validation-like buckets
        Schema(m) | Validate(m) => MainError::Validation(m),
        // I/O
        Io(m) => MainError::Io(m),
        // Build/self-verify mismatches (e.g., ID/FID/digest checks)
        Build(m) => MainError::SelfVerify(m),
        // Spec-directed algorithmic failures
        Tabulate(m) | Allocate(m) | Gates(m) | Frontier(m) | Tie(m) => MainError::Spec(m),
        // Fallback (covers any enum growth)
        _ => MainError::Pipeline(format!("{e:?}")),
    }
}

// NOTE: `run_once(&Args) -> Result<(), MainError>` is implemented in Half 2/2.
// crates/vm_cli/src/main.rs — Half 2/2
//
// Full run path (engine meta → load → seed override → pipeline → artifacts → rendering).
// Complements Half 1/2 (which defined error mapping, validate-only, and main()).

use std::fs;
use std::path::Path;

use serde_json::json;
use vm_io::{canonical_json, loader};
use vm_pipeline::{run_with_ctx, EngineMeta, PipelineCtx, PipelineOutputs};
use vm_report::{build_model, ReportError};

fn run_once(args: &Args) -> Result<(), MainError> {
    // 1) Deterministic engine metadata (compile-time env where available)
    let engine_meta = EngineMeta {
        vendor: option_env!("VM_ENGINE_VENDOR").unwrap_or("vm").to_string(),
        name: option_env!("VM_ENGINE_NAME")
            .unwrap_or(env!("CARGO_PKG_NAME"))
            .to_string(),
        version: option_env!("VM_ENGINE_VERSION")
            .unwrap_or(env!("CARGO_PKG_VERSION"))
            .to_string(),
        build: option_env!("VM_ENGINE_BUILD").unwrap_or("dev").to_string(),
    };

    // 2) Load normative context (schema + structural validation)
    let mut loaded = if let Some(manifest) = &args.manifest {
        loader::load_normative_from_manifest_path(manifest).map_err(map_vmio_err)?
    } else {
        loader::load_normative_from_paths(
            args.registry.as_ref().expect("args validated: --registry"),
            args.params.as_ref().expect("args validated: --params"),
            args.ballots.as_ref(),
            args.tally.as_ref(),
            args.adjacency.as_ref(),
            args.autonomy.as_ref(),
        )
        .map_err(map_vmio_err)?
    };

    // 3) Apply seed override (VM-VAR-052) if provided
    if let Some(seed) = args.seed {
        // Adjust field name to your ParameterSet model if different.
        loaded.params.v052_tie_seed = Some(seed);
    }

    // 4) Normative manifest JSON for FID (TODO: replace with Included-only builder per Annex A)
    let nm_canonical = serde_json::to_value(&loaded.params).unwrap_or_else(|_| json!({}));

    // 5) Run pipeline
    let ctx = PipelineCtx {
        loaded,
        engine_meta,
        nm_canonical,
    };
    let outs = run_with_ctx(ctx).map_err(map_pipeline_err)?;

    // 6) Write canonical artifacts
    write_artifacts(&args.out, &outs)?;

    // 7) Optional report rendering (read-only; offline)
    maybe_render_reports(args, &outs, &args.out)?;

    if !args.quiet {
        eprintln!("run: artifacts written to {}", args.out.to_string_lossy());
    }
    Ok(())
}

fn write_artifacts(out_dir: &Path, outs: &PipelineOutputs) -> Result<(), MainError> {
    fs::create_dir_all(out_dir)
        .map_err(|e| MainError::Io(format!("mkdir {}: {e}", out_dir.to_string_lossy())))?;

    // result.json
    let res_path = out_dir.join("result.json");
    canonical_json::write_canonical_file(&outs.result, &res_path)
        .map_err(|e| MainError::Io(format!("write result.json: {e}")))?;

    // run_record.json
    let run_path = out_dir.join("run_record.json");
    canonical_json::write_canonical_file(&outs.run_record, &run_path)
        .map_err(|e| MainError::Io(format!("write run_record.json: {e}")))?;

    // frontier_map.json (optional; pipeline decides based on VM-VAR-034/040)
    if let Some(frontier) = &outs.frontier_map {
        let fr_path = out_dir.join("frontier_map.json");
        canonical_json::write_canonical_file(frontier, &fr_path)
            .map_err(|e| MainError::Io(format!("write frontier_map.json: {e}")))?;
    }

    Ok(())
}

fn maybe_render_reports(args: &Args, outs: &PipelineOutputs, out_dir: &Path) -> Result<(), MainError> {
    if args.render.is_empty() {
        return Ok(());
    }

    // Build in-memory report model from canonical artifacts
    let result_val = serde_json::to_value(&outs.result)
        .map_err(|e| MainError::Render(format!("result to JSON: {e}")))?;
    let run_val = serde_json::to_value(&outs.run_record)
        .map_err(|e| MainError::Render(format!("run_record to JSON: {e}")))?;
    let frontier_val = match &outs.frontier_map {
        Some(f) => Some(
            serde_json::to_value(f).map_err(|e| MainError::Render(format!("frontier to JSON: {e}")))?,
        ),
        None => None,
    };
    let frontier_opt = frontier_val.as_ref();

    let model = build_model(&result_val, &run_val, frontier_opt, None).map_err(map_report_err)?;

    // Emit requested formats (unknown → error)
    for fmt in &args.render {
        match fmt.as_str() {
            "json" => render_json_report(&model, out_dir)?,
            "html" => render_html_report(&model, out_dir)?,
            other => return Err(MainError::Render(format!("unknown renderer: {other}"))),
        }
    }
    Ok(())
}

// Always accept the concrete model type; gate body by feature.
fn render_json_report(model: &vm_report::ReportModel, out_dir: &Path) -> Result<(), MainError> {
    #[cfg(feature = "report-json")]
    {
        let path = out_dir.join("report.json");
        return canonical_json::write_canonical_file(model, &path)
            .map_err(|e| MainError::Io(format!("write report.json: {e}")));
    }
    #[cfg(not(feature = "report-json"))]
    {
        Err(MainError::Render(
            "json renderer not enabled (build with feature `report-json`)".into(),
        ))
    }
}

fn render_html_report(model: &vm_report::ReportModel, out_dir: &Path) -> Result<(), MainError> {
    // Minimal, deterministic, asset-free HTML (no recomputation).
    let mut html = String::new();
    use std::fmt::Write;

    writeln!(
        &mut html,
        "<!doctype html><html><head><meta charset=\"utf-8\"><title>Voting Model Report</title></head><body>"
    )
    .unwrap();

    // Cover
    writeln!(
        &mut html,
        "<h1>{}</h1><h2>Outcome: {}</h2>{}",
        esc(&model.cover.title),
        esc(&model.cover.label),
        model
            .cover
            .reason
            .as_ref()
            .map(|r| format!("<p>{}</p>", esc(r)))
            .unwrap_or_default()
    )
    .unwrap();

    // Snapshot
    writeln!(&mut html, "<h3>Snapshot</h3><ul>").unwrap();
    for it in &model.snapshot.items {
        writeln!(&mut html, "<li><b>{}</b>: {}</li>", esc(&it.key), esc(&it.value)).unwrap();
    }
    writeln!(&mut html, "</ul>").unwrap();

    // Eligibility
    let elig = &model.eligibility;
    writeln!(
        &mut html,
        "<h3>Eligibility</h3><p>Roll policy: {}<br>Registry source: {}<br>Eligible: {} | Cast: {} | Valid: {}</p>",
        esc(&elig.roll_policy),
        esc(&elig.registry_source),
        elig.totals.eligible_roll,
        elig.totals.ballots_cast,
        elig.totals.valid_ballots
    )
    .unwrap();
    if let Some(note) = &elig.per_unit_quorum_note {
        writeln!(&mut html, "<p>{}</p>", esc(note)).unwrap();
    }

    // Ballot method
    writeln!(
        &mut html,
        "<h3>Ballot Method</h3><p>Method: {} | Allocation: {} | Weighting: {}</p>",
        esc(&model.ballot_method.method),
        esc(&model.ballot_method.allocation),
        esc(&model.ballot_method.weighting)
    )
    .unwrap();
    if let Some(sent) = &model.ballot_method.approval_denominator_sentence {
        writeln!(&mut html, "<p><em>{}</em></p>", esc(sent)).unwrap();
    }

    // Legitimacy
    let leg = &model.legitimacy_panel;
    writeln!(
        &mut html,
        "<h3>Legitimacy</h3><p>Quorum: {}% ({}%) → {}<br>Majority: {}% ({}%) → {}<br>Pass: {}</p>",
        esc(&leg.quorum.value_pct_1dp),
        esc(&leg.quorum.threshold_pct_0dp),
        yesno(leg.quorum.pass),
        esc(&leg.majority.value_pct_1dp),
        esc(&leg.majority.threshold_pct_0dp),
        yesno(leg.majority.pass),
        yesno(leg.pass)
    )
    .unwrap();
    if let Some((nat, fam)) = &leg.double_majority {
        writeln!(
            &mut html,
            "<p>Double majority – National: {}% / thr {}% → {}; Family: {}% / thr {}% → {}</p>",
            esc(&nat.value_pct_1dp),
            esc(&nat.threshold_pct_0dp),
            yesno(nat.pass),
            esc(&fam.value_pct_1dp),
            esc(&fam.threshold_pct_0dp),
            yesno(fam.pass)
        )
        .unwrap();
    }
    if !leg.reasons.is_empty() {
        writeln!(&mut html, "<ul>").unwrap();
        for r in &leg.reasons {
            writeln!(&mut html, "<li>{}</li>", esc(r)).unwrap();
        }
        writeln!(&mut html, "</ul>").unwrap();
    }

    // Outcome
    writeln!(
        &mut html,
        "<h3>Outcome</h3><p>Label: {}<br>Reason: {}<br>National margin: {}</p>",
        esc(&model.outcome_label.label),
        esc(&model.outcome_label.reason),
        esc(&model.outcome_label.national_margin_pp)
    )
    .unwrap();

    // Frontier (optional)
    if let Some(fr) = &model.frontier {
        writeln!(
            &mut html,
            "<h3>Frontier</h3><p>Mode: {} | Edge policy: {} | Island rule: {}</p>",
            esc(&fr.mode),
            esc(&fr.edge_policy),
            esc(&fr.island_rule)
        )
        .unwrap();
        writeln!(
            &mut html,
            "<p>Changed: {} | No change: {} | Mediation: {} | Enclave: {} | Protected blocked: {} | Quorum blocked: {}</p>",
            fr.counters.changed,
            fr.counters.no_change,
            fr.counters.mediation,
            fr.counters.enclave,
            fr.counters.protected_blocked,
            fr.counters.quorum_blocked
        )
        .unwrap();
        if !fr.bands_summary.is_empty() {
            writeln!(&mut html, "<ul>").unwrap();
            for s in &fr.bands_summary {
                writeln!(&mut html, "<li>{}</li>", esc(s)).unwrap();
            }
            writeln!(&mut html, "</ul>").unwrap();
        }
    }

    // Sensitivity (optional)
    if let Some(sens) = &model.sensitivity {
        writeln!(&mut html, "<h3>Sensitivity</h3>").unwrap();
        for row in &sens.table {
            let line = row.iter().map(|c| esc(c)).collect::<Vec<_>>().join(" | ");
            writeln!(&mut html, "<p>{}</p>", line).unwrap();
        }
    }

    // Integrity
    let integ = &model.integrity;
    writeln!(
        &mut html,
        "<h3>Integrity</h3><p>Result ID: {}<br>Run ID: {}<br>Formula ID: {}<br>Engine: {} {} ({}) build {}</p>",
        esc(integ.result_id.as_str()),
        esc(integ.run_id.as_str()),
        esc(&integ.formula_id_hex),
        esc(&integ.engine_vendor),
        esc(&integ.engine_name),
        esc(&integ.engine_version),
        esc(&integ.engine_build)
    )
    .unwrap();
    if let Some(frid) = &integ.frontier_id {
        writeln!(&mut html, "<p>Frontier ID: {}</p>", esc(frid.as_str())).unwrap();
    }
    if let Some(seed) = &integ.tie_seed {
        writeln!(&mut html, "<p>Tie seed: {}</p>", esc(seed)).unwrap();
    }

    writeln!(&mut html, "</body></html>").unwrap();

    let path = out_dir.join("report.html");
    fs::write(&path, html).map_err(|e| MainError::Io(format!("write report.html: {e}")))?;
    Ok(())
}

fn esc(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#x27;")
}

fn yesno(b: bool) -> &'static str {
    if b { "pass" } else { "fail" }
}

fn map_report_err(e: ReportError) -> MainError {
    use ReportError::*;
    match e {
        Template(m) => MainError::Render(format!("template: {m}")),
        MissingField(m) => MainError::Render(format!("missing: {m}")),
        Inconsistent(m) => MainError::Render(format!("inconsistent: {m}")),
    }
}

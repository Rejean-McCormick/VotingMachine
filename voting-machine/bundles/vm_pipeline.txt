# bundle: vm_pipeline

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/Cargo.toml
--------------------------------------------------------------------------------
[package]
name = "vm_pipeline"
version = "0.1.0"
edition = "2021"
rust-version = "1.77"
license = "Apache-2.0 OR MIT"
description = "Deterministic orchestration of the VM engine pipeline (load → validate → tabulate → allocate → gates → frontier → ties → label → artifacts)."
# repository = ""
# readme = "README.md"

[lib]
name = "vm_pipeline"
path = "src/lib.rs"
crate-type = ["rlib"]

[features]
# Compile-time switches that only change code scope, not public types.
default  = ["std", "frontier", "mmp"]
std      = []
frontier = []   # frontier mapping step (040–049)
mmp      = []   # mixed-member proportional helpers

[dependencies]
vm_core = { path = "../vm_core" }  # IDs, variables, rounding, RNG wrapper
vm_io   = { path = "../vm_io" }    # canonical JSON, schemas, hashing, manifest loaders
vm_algo = { path = "../vm_algo" }  # tabulation, allocation, gates/frontier primitives

[dev-dependencies]
tempfile = "3"   # optional, for integration tests

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/lib.rs
--------------------------------------------------------------------------------
//! VM Engine — core artifacts & canonicalization (Part 1/2)
//! This file provides:
//! - Canonical JSON utilities (stable key ordering, LF endings)
//! - SHA-256 helpers and ID prefixes (RES:, RUN:, FR:)
//! - Core data types (ResultDoc, RunRecordDoc, FrontierMapDoc)
//! - “NoId → WithId” builders for canonical artifacts
//!
//! Part 2 adds orchestration (run functions, self-verify, file IO).

use sha2::{Digest, Sha256};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::{self as json, Value};

/// ----- Error type -----
#[derive(thiserror::Error, Debug)]
pub enum EngineError {
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    #[error("JSON error: {0}")]
    Json(#[from] json::Error),
    #[error("Timestamp must be RFC3339 with Z (UTC): {0}")]
    BadTimestamp(String),
    #[error("Spec violation: {0}")]
    Spec(String),
    #[error("Internal: {0}")]
    Internal(String),
}

/// ----- Tie policy (determinism contract) -----
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TiePolicy {
    /// Deterministic based on the canonical order (e.g., unit_id then order_index).
    #[serde(rename = "deterministic_order")]
    DeterministicOrder,
    /// Uses RNG only when a real tie occurs.
    #[serde(rename = "random")]
    Random,
}

/// Determinism echo in RunRecord (what policy was in effect and whether RNG took place).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Determinism {
    pub tie_policy: TiePolicy,
    /// Present only if the policy is random *and* at least one random tie occurred.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rng_seed: Option<u64>,
}

/// ----- Canonical JSON helpers -----

/// Recursively sort object keys to guarantee deterministic serialization.
/// Arrays retain order; numbers/strings/booleans are passed through.
fn canonicalize_value(v: &Value) -> Value {
    match v {
        Value::Object(map) => {
            let mut keys: Vec<&String> = map.keys().collect();
            keys.sort();
            let mut out = json::Map::new();
            for k in keys {
                out.insert(k.clone(), canonicalize_value(&map[k]));
            }
            Value::Object(out)
        }
        Value::Array(a) => {
            let mut out = Vec::with_capacity(a.len());
            for item in a {
                out.push(canonicalize_value(item));
            }
            Value::Array(out)
        }
        _ => v.clone(),
    }
}

/// Convert any Serialize into canonical, LF-terminated UTF-8 bytes.
fn to_canonical_bytes<T: Serialize>(t: &T) -> Result<Vec<u8>, EngineError> {
    let v = json::to_value(t)?;
    let c = canonicalize_value(&v);
    let mut s = json::to_string(&c)?;
    if !s.ends_with('\n') {
        s.push('\n');
    }
    Ok(s.into_bytes())
}

fn sha256_hex(bytes: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(bytes);
    let digest = hasher.finalize();
    hex::encode(digest)
}

/// Validate and normalize an RFC3339 UTC timestamp (must end with 'Z').
fn normalize_timestamp_utc(ts: &str) -> Result<String, EngineError> {
    let dt: DateTime<Utc> = ts.parse::<DateTime<Utc>>()
        .map_err(|_| EngineError::BadTimestamp(ts.to_string()))?;
    Ok(dt.to_rfc3339_opts(chrono::SecondsFormat::Secs, true))
}

/// ----- Artifact IDs & wrappers -----

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IdOnly {
    pub id: String,
    pub sha256: String,
}

/// Result.json (canonical, outcome-carrying summary).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResultDoc {
    pub id: String,                // "RES:<sha256>"
    pub formula_id: String,        // FID (sha256 of Normative Manifest)
    pub engine_version: String,    // e.g., "VM-ENGINE v0"
    pub created_at: String,        // RFC3339 UTC
    pub summary: ResultSummary,
    pub units: Vec<UnitResult>,    // ordered
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,     // presentation-only; computed post-allocation
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResultSummary {
    pub unit_count: u64,
    pub allocation_count: u64,
    pub tie_count: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnitResult {
    pub unit_id: String,
    /// Example outcome payload (keep minimal here; align your model as needed).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_to: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub score: Option<f64>,
}

/// RunRecord (canonical trace of a run).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RunRecordDoc {
    pub run_id: String,            // "RUN:<timestamp>-<sha256>"
    pub timestamp_utc: String,     // RFC3339 UTC
    pub formula_id: String,        // same FID as in ResultDoc
    pub determinism: Determinism,  // tie policy + rng echo (if any)
    pub inputs: InputsEcho,        // hashes/digests of inputs used
    pub vars_effective: json::Map<String, Value>, // Included vars actually used
    pub outputs: RunOutputs,       // produced artifact IDs + hashes
    #[serde(default)]
    pub ties: Vec<TieEvent>,       // ordered by unit/time as produced
}

/// Digest wrapper for the Normative Manifest.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NmDigest {
    pub nm_sha256: String,
}

/// Inputs echoed in the run record (digests only; no raw content).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputsEcho {
    /// Nested digest object (canonical shape).
    pub nm_digest: NmDigest,
    /// Optional additional inputs (registries, tallies, etc.)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extra: Option<json::Map<String, Value>>,
}

/// Produced artifacts (+hashes) of the run.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RunOutputs {
    pub result_id: String,
    pub result_sha256: String,
    pub run_record_sha256: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frontier_map_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frontier_map_sha256: Option<String>,
}

/// Canonical record of a random tie (only when RNG actually used).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TieEvent {
    pub unit_id: String,
    /// Optional extra detail (band, competing candidates, etc.).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub note: Option<String>,
}

/// Optional frontier map (presentation-supporting; separate canonical artifact).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FrontierEntry {
    pub unit_id: String,
    pub band_met: String, // token per spec glossary; keep minimal here
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FrontierMapDoc {
    pub id: String,        // "FR:<sha256>"
    pub created_at: String,
    pub entries: Vec<FrontierEntry>, // ordered
}

/// Internal “NoId” shapes used to compute canonical bytes and derive IDs.

#[derive(Debug, Clone, Serialize, Deserialize)]
struct ResultNoId {
    pub formula_id: String,
    pub engine_version: String,
    pub created_at: String,
    pub summary: ResultSummary,
    pub units: Vec<UnitResult>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct RunRecordNoId {
    pub timestamp_utc: String,
    pub formula_id: String,
    pub determinism: Determinism,
    pub inputs: InputsEcho,
    pub vars_effective: json::Map<String, Value>,
    pub outputs: RunOutputsNoRunHash, // run_hash not yet known
    #[serde(default)]
    pub ties: Vec<TieEvent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct RunOutputsNoRunHash {
    pub result_id: String,
    pub result_sha256: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frontier_map_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frontier_map_sha256: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct FrontierMapNoId {
    pub created_at: String,
    pub entries: Vec<FrontierEntry>,
}

/// Compute Formula ID (FID) from the **Normative Manifest** canonical bytes.
pub fn compute_formula_id(normative_manifest: &Value) -> Result<String, EngineError> {
    let nm_canon = to_canonical_bytes(normative_manifest)?;
    Ok(sha256_hex(&nm_canon))
}

/// Build a canonical Result artifact from a fully-specified `ResultNoId`.
fn finalize_result(noid: &ResultNoId) -> Result<(ResultDoc, String), EngineError> {
    let bytes = to_canonical_bytes(noid)?;
    let hash = sha256_hex(&bytes);
    let id = format!("RES:{hash}");
    let with_id = ResultDoc {
        id: id.clone(),
        formula_id: noid.formula_id.clone(),
        engine_version: noid.engine_version.clone(),
        created_at: noid.created_at.clone(),
        summary: noid.summary.clone(),
        units: noid.units.clone(),
        label: noid.label.clone(),
    };
    Ok((with_id, hash))
}

/// Build a canonical FrontierMap artifact (if present).
fn finalize_frontier(noid: &FrontierMapNoId) -> Result<(FrontierMapDoc, String), EngineError> {
    let bytes = to_canonical_bytes(noid)?;
    let hash = sha256_hex(&bytes);
    let id = format!("FR:{hash}");
    let with_id = FrontierMapDoc {
        id,
        created_at: noid.created_at.clone(),
        entries: noid.entries.clone(),
    };
    Ok((with_id, hash))
}

/// Build a canonical RunRecord artifact.
/// Note: `run_id` includes the timestamp and the hash of the canonical run record bytes.
fn finalize_run_record(
    timestamp_utc: &str,
    formula_id: &str,
    determinism: Determinism,
    inputs: InputsEcho,
    vars_effective: json::Map<String, Value>,
    result_id: &str,
    result_sha256: &str,
    ties: Vec<TieEvent>,
    frontier_map: Option<IdOnly>,
) -> Result<(RunRecordDoc, String), EngineError> {
    let ts = normalize_timestamp_utc(timestamp_utc)?;
    let outputs_no_run = RunOutputsNoRunHash {
        result_id: result_id.to_string(),
        result_sha256: result_sha256.to_string(),
        frontier_map_id: frontier_map.as_ref().map(|x| x.id.clone()),
        frontier_map_sha256: frontier_map.as_ref().map(|x| x.sha256.clone()),
    };

    let noid = RunRecordNoId {
        timestamp_utc: ts.clone(),
        formula_id: formula_id.to_string(),
        determinism,
        inputs,
        vars_effective,
        outputs: outputs_no_run,
        ties, // now carried through
    };

    // Hash the canonical RunRecord (without run_id) to derive run_id.
    let run_bytes = to_canonical_bytes(&noid)?;
    let run_hash = sha256_hex(&run_bytes);
    let run_id = format!("RUN:{ts}-{run_hash}");

    let outputs = RunOutputs {
        result_id: result_id.to_string(),
        result_sha256: result_sha256.to_string(),
        run_record_sha256: run_hash.clone(),
        frontier_map_id: frontier_map.as_ref().map(|x| x.id.clone()),
        frontier_map_sha256: frontier_map.as_ref().map(|x| x.sha256.clone()),
    };

    let with_id = RunRecordDoc {
        run_id,
        timestamp_utc: ts,
        formula_id: formula_id.to_string(),
        determinism: noid.determinism,
        inputs: noid.inputs,
        vars_effective: noid.vars_effective,
        outputs,
        ties: noid.ties,
    };

    Ok((with_id, run_hash))
}

/// Convenience helper to wrap an already-finalized artifact into IdOnly.
fn id_only(id: &str, sha256: &str) -> IdOnly {
    IdOnly { id: id.to_string(), sha256: sha256.to_string() }
}

/// ----- Public bundle for orchestration results (returned by part 2 functions) -----

#[derive(Debug, Clone)]
pub struct BuildOutputs {
    pub result: ResultDoc,
    pub result_sha256: String,
    pub run_record: RunRecordDoc,
    pub run_record_sha256: String,
    pub frontier_map: Option<FrontierMapDoc>,
    pub frontier_map_sha256: Option<String>,
}
// Part 2/2 — Orchestration, self-verify, and file I/O.
// Depends on types & helpers from Part 1.

use std::fs::{create_dir_all, File};
use std::io::Write;
use std::path::Path;
use serde_json::{self as json, Value};

/// Inputs to build all canonical artifacts for a run.
#[derive(Debug, Clone)]
pub struct OrchestrationInputs {
    /// Full Normative Manifest (Included vars only), as JSON.
    pub normative_manifest: Value,
    /// Engine version token, e.g., "VM-ENGINE v0".
    pub engine_version: String,
    /// RFC3339 UTC. Also used as `Result.created_at`.
    pub timestamp_utc: String,
    /// Effective Included variables actually used by the run (echoed in RunRecord).
    pub vars_effective: json::Map<String, Value>,
    /// Already-computed per-unit results, in canonical order.
    pub units: Vec<UnitResult>,
    /// Presentation-only label (computed by the caller after allocations).
    pub label: Option<String>,
    /// Determinism echo (policy + optional rng seed; we’ll enforce rules below).
    pub determinism: Determinism,
    /// Random tie events (empty when none; required to echo rng_seed for random policy).
    pub ties: Vec<TieEvent>,
    /// Optional frontier entries (emitted only when Some and non-empty).
    pub frontier_entries: Option<Vec<FrontierEntry>>,
}

/// Build artifacts (`result.json`, `run_record.json`, optional `frontier_map.json`)
/// and return them with their sha256 digests. Performs spec self-verify checks.
pub fn build_artifacts(inp: OrchestrationInputs) -> Result<BuildOutputs, EngineError> {
    // --- Normalize and compute FID from the Normative Manifest ---
    let fid = compute_formula_id(&inp.normative_manifest)?;
    let nm_sha = {
        let nm_bytes = to_canonical_bytes(&inp.normative_manifest)?;
        sha256_hex(&nm_bytes)
    };

    // --- Determinism & rng_seed echo rules ---
    let tie_policy = inp.determinism.tie_policy;
    let rng_seed = match tie_policy {
        TiePolicy::DeterministicOrder => None, // never echo a seed in deterministic policy
        TiePolicy::Random => {
            if inp.ties.is_empty() { None } else { inp.determinism.rng_seed }
        }
    };
    let determinism = Determinism { tie_policy, rng_seed };

    // --- Build Result (NoId → WithId) ---
    let created_at = normalize_timestamp_utc(&inp.timestamp_utc)?; // also used in RUN prefix
    let summary = ResultSummary {
        unit_count: inp.units.len() as u64,
        allocation_count: inp.units.iter().filter(|u| u.assigned_to.is_some()).count() as u64,
        tie_count: inp.ties.len() as u64,
    };
    let result_noid = ResultNoId {
        formula_id: fid.clone(),
        engine_version: inp.engine_version.clone(),
        created_at: created_at.clone(),
        summary,
        units: inp.units.clone(),
        label: inp.label.clone(),
    };
    let (result_doc, result_sha256) = finalize_result(&result_noid)?;

    // --- Optional Frontier Map ---
    let (frontier_doc_opt, frontier_sha_opt, frontier_idonly_opt) = if let Some(entries) = inp.frontier_entries {
        if entries.is_empty() {
            (None, None, None)
        } else {
            let fm_noid = FrontierMapNoId {
                created_at: created_at.clone(),
                entries,
            };
            let (fm_doc, fm_sha) = finalize_frontier(&fm_noid)?;
            let idonly = id_only(&fm_doc.id, &fm_sha);
            (Some(fm_doc), Some(fm_sha), Some(idonly))
        }
    } else {
        (None, None, None)
    };

    // --- Inputs echo for RunRecord (nested digest shape) ---
    let inputs_echo = InputsEcho {
        nm_digest: NmDigest { nm_sha256: nm_sha },
        extra: None,
    };

    // --- Build RunRecord (NoId → WithId) ---
    let vars_effective = inp.vars_effective;
    let (run_record_doc, run_record_sha256) = finalize_run_record(
        &created_at,
        &fid,
        determinism,
        inputs_echo,
        vars_effective,
        &result_doc.id,
        &result_sha256,
        inp.ties.clone(),           // pass ties through
        frontier_idonly_opt,
    )?;

    // --- Self-verify (spec S6): cross-check IDs and FID consistency ---
    // 1) FID must match between Result and RunRecord.
    if result_doc.formula_id != fid || run_record_doc.formula_id != fid {
        return Err(EngineError::Spec("formula_id mismatch across artifacts".into()));
    }
    // 2) RES: id must be "RES:<sha256_of_result_noid>"
    if !result_doc.id.starts_with("RES:") || &result_doc.id[4..] != result_sha256 {
        return Err(EngineError::Internal("Result ID does not match canonical bytes".into()));
    }
    // 3) RUN: id must be "RUN:<timestamp>-<sha256_of_runrecord_noid>"
    if !run_record_doc.run_id.starts_with("RUN:") {
        return Err(EngineError::Internal("RunRecord ID prefix missing".into()));
    }
    let expect_prefix = format!("RUN:{}-", created_at);
    if !run_record_doc.run_id.starts_with(&expect_prefix) {
        return Err(EngineError::Internal("RunRecord timestamp prefix mismatch".into()));
    }
    if run_record_doc.outputs.run_record_sha256 != run_record_sha256 {
        return Err(EngineError::Internal("RunRecord SHA mismatch".into()));
    }
    // 4) RNG echo rule: if random policy and ties non-empty → rng_seed must be Some.
    if tie_policy == TiePolicy::Random {
        let has_rng = !inp.ties.is_empty();
        match run_record_doc.determinism.rng_seed {
            Some(_) if has_rng => {},                  // ok
            None if !has_rng => {},                    // ok
            Some(_) if !has_rng => {
                return Err(EngineError::Spec("rng_seed echoed but no random tie occurred".into()))
            }
            None if has_rng => {
                return Err(EngineError::Spec("random tie occurred but rng_seed was not echoed".into()))
            }
        }
    }
    // 5) Ties echo consistency
    if run_record_doc.ties.len() != inp.ties.len() {
        return Err(EngineError::Spec("RunRecord ties[] length mismatch".into()));
    }

    Ok(BuildOutputs {
        result: result_doc,
        result_sha256,
        run_record: run_record_doc,
        run_record_sha256,
        frontier_map: frontier_doc_opt,
        frontier_map_sha256: frontier_sha_opt,
    })
}

/// Write artifacts to `out_dir` with canonical JSON (LF) encoding.
/// Filenames: result.json, run_record.json, frontier_map.json (if present).
pub fn write_artifacts(out_dir: &Path, outs: &BuildOutputs) -> Result<(), EngineError> {
    create_dir_all(out_dir)?;

    // result.json
    {
        let bytes = to_canonical_bytes(&outs.result)?;
        write_file(out_dir.join("result.json"), &bytes)?;
    }
    // run_record.json
    {
        let bytes = to_canonical_bytes(&outs.run_record)?;
        write_file(out_dir.join("run_record.json"), &bytes)?;
    }
    // frontier_map.json (optional)
    if let Some(ref fm) = outs.frontier_map {
        let bytes = to_canonical_bytes(fm)?;
        write_file(out_dir.join("frontier_map.json"), &bytes)?;
    }
    Ok(())
}

fn write_file<P: AsRef<Path>>(path: P, bytes: &[u8]) -> Result<(), EngineError> {
    let mut f = File::create(path)?;
    f.write_all(bytes)?;
    Ok(())
}

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/load.rs
--------------------------------------------------------------------------------
//! LOAD stage for normative runs: manifest → vm_io loaders → deterministic bundle.
//! - Enforces the "tally-only" input contract (no raw ballots path).
//! - Delegates schema/ID parsing & canonicalization to vm_io.
//! - Aggregates canonical digests and (if manifest) computes nm_digest + formula_id.

#![forbid(unsafe_code)]

use std::collections::BTreeMap;
use std::path::Path;

use vm_core::{
    entities::{DivisionRegistry, OptionItem},
    variables::Params,
};
use vm_io::{
    hasher,
    loader,
    manifest::{self, Manifest},
};

/// Errors surfaced by the LOAD stage.
#[derive(Debug)]
pub enum LoadError {
    Io(String),
    Schema(String),
    Manifest(String),
    Hash(String),
    Contract(String),
}

impl From<vm_io::IoError> for LoadError {
    fn from(e: vm_io::IoError) -> Self {
        use LoadError::*;
        match e {
            vm_io::IoError::Read(err) => Io(err.to_string()),
            vm_io::IoError::Write(err) => Io(err.to_string()),
            vm_io::IoError::Json { pointer, msg } => Schema(format!("json {pointer}: {msg}")),
            vm_io::IoError::Schema { pointer, msg } => Schema(format!("{pointer}: {msg}")),
            vm_io::IoError::Manifest(m) => Manifest(m),
            vm_io::IoError::Expect(m) => Manifest(format!("expectation: {m}")),
            vm_io::IoError::Canon(m) => Manifest(format!("canonicalization: {m}")),
            vm_io::IoError::Hash(m) => Hash(m),
            vm_io::IoError::Path(m) => Io(format!("path: {m}")),
            vm_io::IoError::Limit(m) => Io(format!("limit: {m}")),
        }
    }
}

/// Input IDs echoed downstream (placeholders for normative-run inputs).
/// In a fuller build, these may be parsed from files; for LOAD we keep opaque strings.
#[derive(Debug, Clone)]
pub struct LoadedIds {
    pub reg_id: String,
    pub tally_id: String,
    pub param_set_id: String,
}

/// Deterministic bundle consumed by downstream stages.
#[derive(Debug, Clone)]
pub struct NormContext {
    pub reg: DivisionRegistry,
    /// Registry-wide canonical option set (deduped by OptionId, sorted by (order_index, OptionId)).
    pub options: Vec<OptionItem>,
    pub params: Params,
    pub tallies: loader::UnitTallies,
    pub ids: LoadedIds,
}

/// Canonical input digests (64-hex).
#[derive(Debug, Clone)]
pub struct InputDigests {
    pub reg_sha256: String,
    pub tally_sha256: String,
    pub params_sha256: String,
    pub adjacency_sha256: Option<String>,
}

/// Output of the LOAD stage.
#[derive(Debug, Clone)]
pub struct LoadedStage {
    pub norm_ctx: NormContext,
    pub digests: InputDigests,
    /// Present when a manifest was used (nm_digest over the Normative Manifest JSON built from Included variables).
    pub nm_digest: Option<String>,
    /// Present when a manifest was used; equals nm_digest under current policy.
    pub formula_id: Option<String>,
}

// -------------------------------------------------------------------------------------------------
// Entry points
// -------------------------------------------------------------------------------------------------

/// Preferred: load from a manifest, enforce the normative contract, and compute nm_digest/FID.
pub fn load_normative_from_manifest<P: AsRef<Path>>(path: P) -> Result<LoadedStage, LoadError> {
    // 1) Parse + validate manifest.
    let man = manifest::load_manifest(&path)?;
    ensure_manifest_contract(&man)?;

    // 2) Load artifacts (vm_io handles schema + canonicalization + cross-refs & reordering).
    let io_loaded = loader::load_all_from_manifest(path.as_ref())?;

    // 3) Lift into NormContext.
    let options = collect_registry_options(&io_loaded.registry);
    let norm_ctx = NormContext {
        reg: io_loaded.registry,
        options,
        params: io_loaded.params,
        tallies: io_loaded.tally,
        ids: LoadedIds {
            reg_id: "REG:local".into(),
            tally_id: "TLY:local".into(),
            param_set_id: "PS:local".into(),
        },
    };

    // 4) Map canonical digests out of vm_io (these are digests of canonical bytes).
    let digests = InputDigests {
        reg_sha256: io_loaded.digests.division_registry_sha256,
        tally_sha256: io_loaded.digests.ballot_tally_sha256,
        params_sha256: io_loaded.digests.parameter_set_sha256,
        adjacency_sha256: io_loaded.digests.adjacency_sha256,
    };

    // 5) Compute Normative Manifest (NM) from **Included VM-VARs** and derive FID.
    let (nm_digest, fid) = compute_nm_and_fid_from_params(&norm_ctx.params)?;

    Ok(LoadedStage {
        norm_ctx,
        digests,
        nm_digest: Some(nm_digest),
        formula_id: Some(fid),
    })
}

/// Alternate entry: direct file paths (no manifest). Does not compute FID/NM.
pub fn load_normative_from_paths<P: AsRef<Path>>(
    registry_path: P,
    tally_path: P,
    params_path: P,
    adjacency_path: Option<P>,
) -> Result<LoadedStage, LoadError> {
    // Load individually via vm_io targeted loaders.
    let reg = loader::load_registry(registry_path.as_ref())?;
    let params = loader::load_params(params_path.as_ref())?;
    let mut tallies = loader::load_ballot_tally(tally_path.as_ref())?;

    // Reuse registry-deduced options; consumers sort per-registry anyway.
    // (vm_io::load_all_from_manifest performs per-unit reorder; path mode keeps tallies as loaded.)
    let options = collect_registry_options(&reg);

    let norm_ctx = NormContext {
        reg,
        options,
        params,
        tallies: {
            // Keep as loaded; callers relying on manifest-mode canonicalization should prefer it.
            // We still ensure stable unit ordering if present.
            tallies.units.sort_by(|a, b| a.unit_id.cmp(&b.unit_id));
            tallies
        },
        ids: LoadedIds {
            reg_id: "REG:local".into(),
            tally_id: "TLY:local".into(),
            param_set_id: "PS:local".into(),
        },
    };

    // Stream-hash file bytes for transparency in path mode.
    let digests = InputDigests {
        reg_sha256: hasher::sha256_file(registry_path.as_ref())?,
        tally_sha256: hasher::sha256_file(tally_path.as_ref())?,
        params_sha256: hasher::sha256_file(params_path.as_ref())?,
        adjacency_sha256: match adjacency_path {
            Some(p) => Some(hasher::sha256_file(p.as_ref())?),
            None => None,
        },
    };

    Ok(LoadedStage {
        norm_ctx,
        digests,
        nm_digest: None,
        formula_id: None,
    })
}

// -------------------------------------------------------------------------------------------------
// Internals
// -------------------------------------------------------------------------------------------------

/// Ensure the manifest matches the normative contract:
/// - MUST provide `ballot_tally_path`
/// - MUST NOT provide a legacy `ballots_path` (schema should forbid; we still guard).
fn ensure_manifest_contract(man: &Manifest) -> Result<(), LoadError> {
    if man.ballot_tally_path.trim().is_empty() {
        return Err(LoadError::Contract(
            "manifest must specify `ballot_tally_path` for normative runs".into(),
        ));
    }
    // Defensive note: if a legacy field “ballots_path” existed, schema should reject it.
    // We can only sanity-check the typed struct here.
    Ok(())
}

/// Compute NM and FID from the **Included VM-VARs** only (Annex A / Doc 2..5).
fn compute_nm_and_fid_from_params(params: &Params) -> Result<(String, String), LoadError> {
    use serde_json::{Map, Value};

    // Convert Params → Value, then filter keys by Included set.
    let full = serde_json::to_value(params)
        .map_err(|e| LoadError::Schema(format!("serialize Params: {e}")))?;

    let obj = full.as_object().ok_or_else(|| {
        LoadError::Schema("Params serialization did not yield an object".into())
    })?;

    let mut included: Map<String, Value> = Map::new();
    for (k, v) in obj {
        if is_included_var_key(k) {
            included.insert(k.clone(), v.clone());
        }
    }

    // Shape the NM with a stable top-level key to keep room for future fields.
    let nm = Value::Object({
        let mut m = Map::new();
        m.insert("vars_included".to_string(), Value::Object(included));
        m
    });

    let nm_digest = hasher::nm_digest_from_value(&nm).map_err(LoadError::from)?;
    let fid = hasher::formula_id_from_nm(&nm).map_err(LoadError::from)?;
    Ok((nm_digest, fid))
}

/// Inclusion predicate per Annex A:
/// IN: 001–007, 010–017, 020–031, 040–049, 050, 073
/// OUT: 032–035, 052, 060–062 (and any other non-listed).
fn is_included_var_key(key: &str) -> bool {
    // Expect keys like "v001_algorithm_family", "v014", "v050_tie_policy", etc.
    if !key.starts_with('v') { return false; }
    let digits = key.as_bytes().get(1..4);
    let Ok(n) = digits
        .and_then(|s| std::str::from_utf8(s).ok())
        .and_then(|s| s.parse::<u16>().ok())
    else { return false; };

    match n {
        1..=7 => true,        // 001..007
        10..=17 => true,      // 010..017
        20..=31 => true,      // 020..031
        40..=49 => true,      // 040..049
        50 => true,           // 050
        73 => true,           // 073
        // Explicit exclusions (for clarity; already excluded by ranges above except 052/060..062)
        32..=35 => false,
        52 => false,
        60..=62 => false,
        _ => false,
    }
}

// -------------------------------------------------------------------------------------------------
// Small utilities
// -------------------------------------------------------------------------------------------------

/// Aggregate a registry-wide option list, deduped by OptionId and sorted by (order_index, OptionId).
fn collect_registry_options(reg: &DivisionRegistry) -> Vec<OptionItem> {
    use core::cmp::Ordering;

    let mut seen: BTreeMap<vm_core::ids::OptionId, OptionItem> = BTreeMap::new();
    for unit in &reg.units {
        for opt in &unit.options {
            // If the same option_id appears across units, prefer the one with the smaller (order_index, id).
            match seen.get(&opt.option_id) {
                None => {
                    seen.insert(opt.option_id.clone(), opt.clone());
                }
                Some(existing) => {
                    let a = (opt.order_index, &opt.option_id);
                    let b = (existing.order_index, &existing.option_id);
                    if a.cmp(&b) == Ordering::Less {
                        seen.insert(opt.option_id.clone(), opt.clone());
                    }
                }
            }
        }
    }
    let mut options: Vec<OptionItem> = seen.into_values().collect();
    options.sort_by(|a, b| {
        let ka = (a.order_index, &a.option_id);
        let kb = (b.order_index, &b.option_id);
        ka.cmp(&kb)
    });
    options
}

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/validate.rs
--------------------------------------------------------------------------------
//! crates/vm_pipeline/src/validate.rs
//! Structural & semantic validation before any computation.
//! Deterministic outputs; no RNG; pure integer reasoning.
//!
//! NOTE: This file implements the full reporting model and the
//! option-ordering checks now (enforceable with current vm_core types).
//! Other checks are scaffolded and will be filled as the corresponding
//! fields/types (tree parents, magnitudes, tallies, params) are wired.

#![allow(clippy::result_large_err)]

use alloc::string::{String, ToString};
use alloc::vec::Vec;

use vm_core::{
    entities::{DivisionRegistry, OptionItem, Unit},
    ids::{OptionId, UnitId},
};

/// Context normalized by LOAD (paths → typed, canonical ordering, ids echoed).
/// This is declared elsewhere in the pipeline; we only borrow it here.
#[allow(dead_code)]
pub struct NormContext<'a> {
    pub reg: &'a DivisionRegistry,
    pub options: &'a [OptionItem],
    // pub params: &'a vm_core::variables::Params,
    // pub tallies: &'a vm_core::tallies::UnitTallies,
    // pub ids: NormIds,
}

/// Issue severity.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Severity {
    Error,
    Warning,
}

/// Where the issue occurred (kept small & deterministic).
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum EntityRef {
    Root,
    Unit(UnitId),
    Option(OptionId),
    Param(&'static str),
    TallyUnit(UnitId),
    Adjacency(UnitId, UnitId),
}

/// One validation finding.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ValidationIssue {
    pub severity: Severity,
    pub code: &'static str,
    pub message: String,
    pub where_: EntityRef,
}

/// Deterministic report: pass = (no Error); ordering of issues is stable.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct ValidationReport {
    pub pass: bool,
    pub issues: Vec<ValidationIssue>,
}

/// Top-level entry point.
pub fn validate(ctx: &NormContext) -> ValidationReport {
    let mut issues: Vec<ValidationIssue> = Vec::new();

    // A) Registry tree & magnitudes & baseline pairing (scaffold — fill as fields land)
    issues.extend(check_registry_tree(ctx.reg));
    issues.extend(check_unit_magnitudes(&ctx.reg.units));
    issues.extend(check_baseline_pairing(&ctx.reg.units));

    // B) Options: canonical order & order_index uniqueness (per unit)
    for u in &ctx.reg.units {
        issues.extend(check_unit_options_order(u));
    }

    // C) Params ↔ tally shape (scaffold)
    // if let (Some(params), Some(tallies)) = (ctx.params_opt, ctx.tallies_opt) { ... }
    // issues.extend(check_params_vs_tally(params, tallies));

    // D) Tally sanity per ballot type (scaffold)
    // issues.extend(check_tally_sanity_plurality(tallies, ctx.options));
    // issues.extend(check_tally_sanity_approval(tallies, ctx.options));
    // issues.extend(check_tally_sanity_score(tallies, ctx.options, params));
    // issues.extend(check_tally_sanity_ranked_irv(tallies, ctx.options));
    // issues.extend(check_tally_sanity_ranked_condorcet(tallies, ctx.options));

    // E) WTA constraint (scaffold)
    // issues.extend(check_wta_constraint(&ctx.reg.units, params));

    // F) Quorum data presence/bounds (scaffold)
    // issues.extend(check_quorum_data(&ctx.reg.units, tallies, params));

    // G) Double-majority family preconditions (scaffold)
    // issues.extend(check_double_majority_family(params, ctx.reg));

    // H) Frontier prerequisites (shape-level) (scaffold)
    // issues.extend(check_frontier_prereqs(params, ctx.reg));

    // I) RNG tie knobs (re-assert only) (scaffold)
    // issues.extend(check_tie_seed(params));

    // Deterministic sort of issues (by code, then where, then message) for byte-identical runs.
    sort_issues_stably(&mut issues);

    ValidationReport {
        pass: !issues.iter().any(|i| i.severity == Severity::Error),
        issues,
    }
}

// ------------------------------------------------------------------------------------------------
// Helpers / checks
// ------------------------------------------------------------------------------------------------

fn check_registry_tree(_reg: &DivisionRegistry) -> Vec<ValidationIssue> {
    // Current vm_core::entities::DivisionRegistry has no parent/root fields yet.
    // Stub to be filled once the tree representation lands.
    Vec::new()
}

fn check_unit_magnitudes(_units: &[Unit]) -> Vec<ValidationIssue> {
    // Current Unit has no magnitude field yet; fill once available.
    Vec::new()
}

fn check_baseline_pairing(_units: &[Unit]) -> Vec<ValidationIssue> {
    // Current Unit has no baseline fields; fill once (population_baseline, year) exist.
    Vec::new()
}

/// Per-unit option validations: uniqueness of `order_index` and canonical ordering.
fn check_unit_options_order(unit: &Unit) -> Vec<ValidationIssue> {
    use alloc::collections::{BTreeMap, BTreeSet};

    let mut issues = Vec::new();

    // A) order_index uniqueness within the unit (Doc 1B §4/§5; Doc 6A VM-TST-108)
    let mut seen: BTreeMap<u16, Vec<OptionId>> = BTreeMap::new();
    for o in &unit.options {
        seen.entry(o.order_index).or_default().push(o.option_id.clone());
    }
    for (idx, ids) in seen.into_iter() {
        if ids.len() > 1 {
            // Emit one error per duplicated index at the unit scope
            issues.push(ValidationIssue {
                severity: Severity::Error,
                code: "E-DR-ORD-UNIQ",
                message: format!("unit has duplicate order_index {} for options {:?}", idx, ids),
                where_: EntityRef::Unit(unit.unit_id.clone()),
            });
        }
    }

    // B) canonical ordering check: (order_index, option_id)
    let mut prev: Option<(u16, &OptionId)> = None;
    for o in &unit.options {
        let key = (o.order_index, &o.option_id);
        if let Some(pk) = prev {
            if key < pk {
                issues.push(ValidationIssue {
                    severity: Severity::Warning,
                    code: "Option.OutOfOrder",
                    message: "options are not in canonical (order_index, option_id) order".to_string(),
                    where_: EntityRef::Unit(unit.unit_id.clone()),
                });
                // continue scanning to collect all warnings
            }
        }
        prev = Some(key);
    }

    issues
}

/// Enforce canonical option ordering and unique/non-negative order_index.
///
/// Errors:
/// - "Option.OrderIndexDuplicate" on duplicate `order_index`
/// Warnings:
/// - "Option.OutOfOrder" if slice is not sorted by (order_index, OptionId)
fn check_options_order(options: &[OptionItem]) -> Vec<ValidationIssue> {
    use alloc::collections::BTreeSet;

    let mut issues = Vec::new();

    // Duplicate order_index?
    let mut seen = BTreeSet::<u16>::new();
    for o in options {
        // non-negative is guaranteed by u16 type
        if !seen.insert(o.order_index) {
            issues.push(ValidationIssue {
                severity: Severity::Error,
                code: "Option.OrderIndexDuplicate",
                message: format!("duplicate order_index {}", o.order_index),
                where_: EntityRef::Option(o.option_id.clone()),
            });
        }
    }

    // Sorted by (order_index, OptionId)?
    let mut prev: Option<(&OptionItem, (u16, &OptionId))> = None;
    for o in options {
        let key = (o.order_index, &o.option_id);
        if let Some((_po, pk)) = prev.as_ref() {
            if key < *pk {
                issues.push(ValidationIssue {
                    severity: Severity::Warning,
                    code: "Option.OutOfOrder",
                    message: "options are not in canonical (order_index, option_id) order".to_string(),
                    where_: EntityRef::Option(o.option_id.clone()),
                });
                // Keep scanning to collect all warnings
            }
        }
        prev = Some((o, key));
    }

    issues
}
// ------------------------------------------------------------------------------------------------
// Sorting / utilities
// ------------------------------------------------------------------------------------------------

fn sort_issues_stably(issues: &mut Vec<ValidationIssue>) {
    issues.sort_by(|a, b| issue_sort_key(a).cmp(&issue_sort_key(b)));
}

/// Primary stable key: (vm_var_bucket, vm_var_num, code, where_key, message)
/// - vm_var_bucket: 0 if tied to a VM-VAR id (Param("VM-VAR-###")), else 1
/// - vm_var_num: parsed numeric id when present, else u16::MAX
fn issue_sort_key(i: &ValidationIssue) -> (u8, u16, &str, (u8, String), &str) {
    let (bucket, vmvar_num) = match &i.where_ {
        EntityRef::Param(name) => {
            if let Some(n) = parse_vm_var_num(name) {
                (0u8, n)
            } else {
                (1u8, u16::MAX)
            }
        }
        _ => (1u8, u16::MAX),
    };

    (bucket, vmvar_num, i.code, entity_ref_sort_key(&i.where_), i.message.as_str())
}

/// Extract a deterministic ordering key for EntityRef.
/// Variant rank ensures stable cross-run ordering, then a string key.
fn entity_ref_sort_key(r: &EntityRef) -> (u8, String) {
    match r {
        EntityRef::Root => (0, "root".to_string()),
        EntityRef::Unit(id) => (1, format!("unit:{:?}", id)),
        EntityRef::Option(id) => (2, format!("option:{:?}", id)),
        EntityRef::Param(name) => (3, format!("param:{name}")),
        EntityRef::TallyUnit(id) => (4, format!("tally_unit:{:?}", id)),
        EntityRef::Adjacency(a, b) => (5, format!("adj:{:?}->{:?}", a, b)),
    }
}

/// Parse "VM-VAR-###" → ### (u16). Returns None if not in the expected form.
fn parse_vm_var_num(s: &str) -> Option<u16> {
    const PREFIX: &str = "VM-VAR-";
    if !s.starts_with(PREFIX) {
        return None;
    }
    let digits = &s[PREFIX.len()..];
    if digits.is_empty() || digits.len() > 5 {
        return None;
    }
    digits.parse::<u16>().ok()
}

// ------------------------------------------------------------------------------------------------
// Scaffolds (placeholders to be filled as more fields/types land in vm_core)
// ------------------------------------------------------------------------------------------------

#[allow(unused_variables)]
fn check_params_vs_tally(/*params: &Params,*/ /*tallies: &UnitTallies*/) -> Vec<ValidationIssue> {
    // TODO: Presence & domain checks for Included VM-VARs; shape match to tallies.
    Vec::new()
}

#[allow(unused_variables)]
fn check_tally_sanity_plurality(/*...*/) -> Vec<ValidationIssue> {
    // TODO: Sum(votes) <= valid_ballots; FK to registry.
    Vec::new()
}

#[allow(unused_variables)]
fn check_tally_sanity_approval(/*...*/) -> Vec<ValidationIssue> {
    Vec::new()
}

#[allow(unused_variables)]
fn check_tally_sanity_score(/*...*/) -> Vec<ValidationIssue> {
    Vec::new()
}

#[allow(unused_variables)]
fn check_tally_sanity_ranked_irv(/*...*/) -> Vec<ValidationIssue> {
    Vec::new()
}

#[allow(unused_variables)]
fn check_tally_sanity_ranked_condorcet(/*...*/) -> Vec<ValidationIssue> {
    Vec::new()
}

#[allow(unused_variables)]
fn check_wta_constraint(/*units: &[Unit], params: &Params*/) -> Vec<ValidationIssue> {
    Vec::new()
}

#[allow(unused_variables)]
fn check_quorum_data(/*units: &[Unit], tallies: &UnitTallies, params: &Params*/) -> Vec<ValidationIssue> {
    Vec::new()
}

#[allow(unused_variables)]
fn check_double_majority_family(/*params: &Params, reg: &DivisionRegistry*/) -> Vec<ValidationIssue> {
    Vec::new()
}

#[allow(unused_variables)]
fn check_frontier_prereqs(/*params: &Params, reg: &DivisionRegistry*/) -> Vec<ValidationIssue> {
    // TODO: Ensure frontier variables are present/enabled only with required inputs.
    Vec::new()
}

#[allow(unused_variables)]
fn check_tie_seed(/*params: &Params*/) -> Vec<ValidationIssue> {
    // TODO: If tie_policy=random then tie_seed must be present and within domain; otherwise ignored.
    Vec::new()
}

// ------------------------------------------------------------------------------------------------
// (optional) tests — can be kept or removed based on your policy
// ------------------------------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_vm_var_num_ok() {
        assert_eq!(parse_vm_var_num("VM-VAR-050"), Some(50));
        assert_eq!(parse_vm_var_num("VM-VAR-5"), Some(5));
    }

    #[test]
    fn parse_vm_var_num_bad() {
        assert_eq!(parse_vm_var_num("VAR-050"), None);
        assert_eq!(parse_vm_var_num("VM-VAR-"), None);
        assert_eq!(parse_vm_var_num("VM-VAR-99999"), None);
    }

    #[test]
    fn sort_vmvar_first() {
        let mut issues = vec![
            ValidationIssue {
                severity: Severity::Error,
                code: "E-OTHER",
                message: "x".into(),
                where_: EntityRef::Unit(UnitId::from_raw(2)),
            },
            ValidationIssue {
                severity: Severity::Error,
                code: "E-PARAM",
                message: "y".into(),
                where_: EntityRef::Param("VM-VAR-060"),
            },
            ValidationIssue {
                severity: Severity::Error,
                code: "E-PARAM",
                message: "z".into(),
                where_: EntityRef::Param("VM-VAR-010"),
            },
        ];
        sort_issues_stably(&mut issues);
        // VM-VAR-010 should come before VM-VAR-060, both before the Unit-scoped issue.
        assert!(matches!(issues[0].where_, EntityRef::Param("VM-VAR-010")));
        assert!(matches!(issues[1].where_, EntityRef::Param("VM-VAR-060")));
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/tabulate.rs
--------------------------------------------------------------------------------
//! crates/vm_pipeline/src/tabulate.rs
//! TABULATE stage: compute per-Unit `UnitScores` deterministically from the loaded,
//! canonicalized inputs according to VM-VAR-001. Integer-only; no RNG here.
//!
//! Inputs are provided through a minimal `LoadedContext` view (defined here to keep
//! this module self-contained). The pipeline may later replace it with a richer type.

use std::collections::BTreeMap;

use vm_core::{
    entities::{OptionItem, TallyTotals as Turnout},
    ids::{OptionId, UnitId},
    variables::Params,
};
use vm_algo::{
    tabulation, // pure algorithm entry points
    IrvLog, Pairwise, UnitScores,
};

// ----- Context & unit inputs --------------------------------------------------------------------

/// Minimal, stable view of what TABULATE needs.
#[derive(Clone, Debug, Default)]
pub struct LoadedContext {
    /// Units to process, already canonicalized upstream (units ↑ by UnitId; options ↑ by (order_index, id)).
    pub units: Vec<UnitInput>,
}

/// Per-unit input shape supporting all ballot types; unused fields are ignored
/// by the relevant per-type dispatcher.
#[derive(Clone, Debug, Default)]
pub struct UnitInput {
    pub unit_id: UnitId,
    pub options: Vec<OptionItem>,                  // canonical order
    pub turnout: Turnout,                          // valid/invalid/total (as aggregated upstream)

    // Plurality/Approval/Score
    pub plurality_votes: BTreeMap<OptionId, u64>,  // plurality
    pub approvals: BTreeMap<OptionId, u64>,        // approval
    pub score_sums: BTreeMap<OptionId, u64>,       // score (already domain-checked upstream)

    // Ranked (IRV/Condorcet): compressed ballots (ranking, multiplicity)
    pub ranked_ballots: Vec<(Vec<OptionId>, u64)>,
}

// ----- Audit sidecar ---------------------------------------------------------------------------

/// Optional, lightweight log of a Condorcet completion (kept here until vm_algo exposes one).
#[derive(Clone, Debug, Default)]
pub struct CondorcetLog {
    pub steps: Vec<String>,
}

/// Audit payload emitted by TABULATE. Downstream stages (allocation, reporting, ties)
/// may read from these sidecars.
#[derive(Clone, Debug, Default)]
pub struct TabulateAudit {
    pub irv_logs: BTreeMap<UnitId, IrvLog>,
    pub condorcet_pairwise: BTreeMap<UnitId, Pairwise>,
    pub condorcet_logs: BTreeMap<UnitId, CondorcetLog>,
    /// Pending tie contexts (e.g., IRV elimination deadlocks) are collected here by a later
    /// revision once `crate::ties::TieContext` lands.
    pub pending_ties: Vec<()>, // placeholder; replaced by crate::ties::TieContext later
}

// ----- Param view (only what we need from VM-VAR-001..007 here) --------------------------------

trait TabulateParamView {
    fn ballot_is_plurality_001(&self) -> bool;
    fn ballot_is_approval_001(&self) -> bool;
    fn ballot_is_score_001(&self) -> bool;
    fn ballot_is_ranked_irv_001(&self) -> bool;
    fn ballot_is_ranked_condorcet_001(&self) -> bool;
}

impl TabulateParamView for Params {
    // Forwarders must call inherent `Params` methods; avoid recursive self-calls.
    #[inline]
    fn ballot_is_plurality_001(&self) -> bool {
        vm_core::variables::Params::ballot_is_plurality_001(self)
    }
    #[inline]
    fn ballot_is_approval_001(&self) -> bool {
        vm_core::variables::Params::ballot_is_approval_001(self)
    }
    #[inline]
    fn ballot_is_score_001(&self) -> bool {
        vm_core::variables::Params::ballot_is_score_001(self)
    }
    #[inline]
    fn ballot_is_ranked_irv_001(&self) -> bool {
        vm_core::variables::Params::ballot_is_ranked_irv_001(self)
    }
    #[inline]
    fn ballot_is_ranked_condorcet_001(&self) -> bool {
        vm_core::variables::Params::ballot_is_ranked_condorcet_001(self)
    }
}

// ----- Public entry point ----------------------------------------------------------------------

/// Tabulate all units in canonical order, producing per-unit `UnitScores` and audit sidecars.
/// No ratios/shares are computed here; those happen downstream (aggregation/reporting).
pub fn tabulate_all(
    ctx: &LoadedContext,
    p: &Params,
) -> (BTreeMap<UnitId, UnitScores>, TabulateAudit) {
    let mut out_scores: BTreeMap<UnitId, UnitScores> = BTreeMap::new();
    let mut audit = TabulateAudit::default();

    if p.ballot_is_plurality_001() {
        for u in &ctx.units {
            let sc = tabulate_unit_plurality(u);
            out_scores.insert(u.unit_id.clone(), sc);
        }
        return (out_scores, audit);
    }

    if p.ballot_is_approval_001() {
        for u in &ctx.units {
            let sc = tabulate_unit_approval(u);
            out_scores.insert(u.unit_id.clone(), sc);
        }
        return (out_scores, audit);
    }

    if p.ballot_is_score_001() {
        for u in &ctx.units {
            let sc = tabulate_unit_score(u, p);
            out_scores.insert(u.unit_id.clone(), sc);
        }
        return (out_scores, audit);
    }

    if p.ballot_is_ranked_irv_001() {
        for u in &ctx.units {
            let (sc, maybe_log /*, maybe_tie */) = tabulate_unit_ranked_irv(u, p);
            if let Some(log) = maybe_log {
                audit.irv_logs.insert(u.unit_id.clone(), log);
            }
            // if let Some(tc) = maybe_tie { audit.pending_ties.push(tc); }
            out_scores.insert(u.unit_id.clone(), sc);
        }
        return (out_scores, audit);
    }

    if p.ballot_is_ranked_condorcet_001() {
        for u in &ctx.units {
            let (sc, maybe_pw, maybe_log) = tabulate_unit_ranked_condorcet(u, p);
            if let Some(pw) = maybe_pw {
                audit.condorcet_pairwise.insert(u.unit_id.clone(), pw);
            }
            if let Some(lg) = maybe_log {
                audit.condorcet_logs.insert(u.unit_id.clone(), lg);
            }
            out_scores.insert(u.unit_id.clone(), sc);
        }
        return (out_scores, audit);
    }

    // Unknown ballot type – return empty with no scores; a higher layer should surface an error.
    (out_scores, audit)
}

// ----- Per-type dispatchers (thin wrappers around vm_algo::tabulation) --------------------------

fn tabulate_unit_plurality(unit: &UnitInput) -> UnitScores {
    // vm_algo requires (unit_id, votes, turnout, options)
    tabulation::tabulate_plurality(
        unit.unit_id.clone(),
        &unit.plurality_votes,
        unit.turnout,
        &unit.options,
    )
    .expect("tabulate_plurality: inputs must be validated upstream")
}

fn tabulate_unit_approval(unit: &UnitInput) -> UnitScores {
    // vm_algo requires (unit_id, approvals, turnout, options)
    tabulation::tabulate_approval(
        unit.unit_id.clone(),
        &unit.approvals,
        unit.turnout,
        &unit.options,
    )
    .expect("tabulate_approval: inputs must be validated upstream")
}

fn tabulate_unit_score(unit: &UnitInput, p: &Params) -> UnitScores {
    // vm_algo requires (unit_id, score_sums, turnout, params, options)
    tabulation::tabulate_score(
        unit.unit_id.clone(),
        &unit.score_sums,
        unit.turnout,
        p,
        &unit.options,
    )
    .expect("tabulate_score: inputs must be validated upstream")
}

fn tabulate_unit_ranked_irv(
    unit: &UnitInput,
    p: &Params,
) -> (UnitScores, Option<IrvLog> /*, Option<crate::ties::TieContext>*/) {
    // vm_algo requires (unit_id, ballots, options, turnout, params)
    let (sc, log) = tabulation::tabulate_ranked_irv(
        unit.unit_id.clone(),
        &unit.ranked_ballots,
        &unit.options,
        unit.turnout,
        p,
    );
    (sc, Some(log) /*, None*/)
}

fn tabulate_unit_ranked_condorcet(
    unit: &UnitInput,
    p: &Params,
) -> (UnitScores, Option<Pairwise>, Option<CondorcetLog>) {
    // vm_algo requires (unit_id, ballots, options, turnout, params) and returns (scores, pairwise, log)
    let (sc, pw, _algo_log) = tabulation::tabulate_ranked_condorcet(
        unit.unit_id.clone(),
        &unit.ranked_ballots,
        &unit.options,
        unit.turnout,
        p,
    );
    // Until a concrete CondorcetLog type is exposed here, stash a minimal placeholder.
    (sc, Some(pw), Some(CondorcetLog { steps: vec!["condorcet: see algorithm log".into()] }))
}

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/allocate.rs
--------------------------------------------------------------------------------
// crates/vm_pipeline/src/allocate.rs — Part 1/2 (patched)
//
// Spec-aligned allocation stage: local error types, small structs, and helpers.
// Pairs with Part 2/2 (which contains the per-unit and all-units allocation).
//
// Alignment anchors (Docs 1–7 + Annexes A–C):
// • VM-VAR-050  tie_policy: { deterministic_order | random | status_quo }  (Included)
// • VM-VAR-052  tie_seed   (Excluded; must be logged in RunRecord integrity)
// • PR entry thresholds apply *before* apportionment (Doc 4 S4; Doc 6 tests)
// • Do NOT signal structural errors via “tie contexts”; use typed errors.
// • Determinism: stable iteration (UnitId asc), option ordering = registry order
//   when emitting; if a map is stored, re-order at packaging time (Doc 7).
// • Frontier/tie logging: emit concrete tie contexts for last-seat ties; random
//   policy later records RNG crumbs (resolved by the tie resolver).

use std::collections::{BTreeMap, BTreeSet};

use vm_core::{
    entities::{OptionItem, TallyTotals, UnitMeta, UnitScores},
    ids::{OptionId, UnitId},
};

use vm_algo::enums::{LrQuotaKind, TiePolicy};
use vm_pipeline::ties::{TieContext, TieKind};
use vm_pipeline::PipelineError;

// ---------- Local error taxonomy (no ties used for errors) ----------

#[derive(Debug)]
pub enum AllocateError {
    MissingScores { unit: UnitId },
    OptionSetMismatch {
        unit: UnitId,
        missing_in_scores: BTreeSet<OptionId>,
        extra_in_scores: BTreeSet<OptionId>,
    },
    LrQuotaMissing { unit: UnitId },
    WtaRequiresMagnitude1 { unit: UnitId, got: u32 },
    StatusQuoAnchorMissing { unit: UnitId },
}

impl From<AllocateError> for PipelineError {
    fn from(e: AllocateError) -> Self {
        use AllocateError::*;
        match e {
            MissingScores { unit } => PipelineError::Allocate(format!("missing scores for unit {unit}")),
            OptionSetMismatch { unit, missing_in_scores, extra_in_scores } => {
                PipelineError::Allocate(format!(
                    "option set mismatch for unit {unit}: missing_in_scores={:?}, extra_in_scores={:?}",
                    missing_in_scores, extra_in_scores
                ))
            }
            LrQuotaMissing { unit } => PipelineError::Allocate(format!(
                "LargestRemainder requires a quota kind (Doc 4 §S4); missing for unit {unit}"
            )),
            WtaRequiresMagnitude1 { unit, got } => PipelineError::Allocate(format!(
                "WinnerTakeAll requires magnitude=1 (Doc 4B); unit {unit} has magnitude={got}"
            )),
            StatusQuoAnchorMissing { unit } => PipelineError::Allocate(format!(
                "tie_policy=status_quo requires an anchor (Annex C); missing for unit {unit}"
            )),
        }
    }
}

// ---------- Small data structures used within allocate ----------

#[derive(Debug, Clone)]
pub struct UnitAllocation {
    /// Seats (or power for WTA if your schema requires) by option.
    pub seats_by_option: BTreeMap<OptionId, u32>,
    /// Whether the last seat on this unit was awarded on a tie.
    pub last_seat_tie: bool,
}

#[derive(Debug, Default)]
pub struct AllocateOutputs {
    pub per_unit: BTreeMap<UnitId, UnitAllocation>,
    /// All tie contexts observed during allocation (e.g., last-seat ties).
    pub ties: Vec<TieContext>,
}

// ---------- Helper functions (spec-aligned) ----------

/// Ensure the set of options in `scores` matches the registry `options` for this unit.
/// We *do not* synthesize “empty scores”; misalignment is structural and must be rejected.
pub fn assert_option_set_alignment(
    unit: &UnitId,
    options: &[OptionItem],
    scores: &UnitScores,
) -> Result<(), AllocateError> {
    let reg_set: BTreeSet<OptionId> = options.iter().map(|o| o.id.clone()).collect();
    let scr_set: BTreeSet<OptionId> = scores.by_option.keys().cloned().collect();

    if reg_set == scr_set {
        return Ok(());
    }

    let missing_in_scores = &reg_set - &scr_set;
    let extra_in_scores = &scr_set - &reg_set;
    Err(AllocateError::OptionSetMismatch {
        unit: unit.clone(),
        missing_in_scores,
        extra_in_scores,
    })
}

/// Apply PR entry threshold before apportionment, returning a filtered
/// (option_id → score) map. Threshold semantics are **inclusive**:
/// option is eligible if (score / valid_ballots) * 100 >= threshold_pct.
/// (If your spec requires strict “>”, change the comparison accordingly.)
pub fn apply_pr_threshold(
    scores: &UnitScores,
    turnout: &TallyTotals,
    threshold_pct: f64,
) -> BTreeMap<OptionId, u64> {
    if threshold_pct <= 0.0 {
        return scores.by_option.clone();
    }

    let valid = turnout.valid_ballots as f64;
    if valid <= 0.0 {
        // Degenerate case: no valid ballots → nobody passes (algo should yield 0 seats)
        return BTreeMap::new();
    }

    let mut filtered = BTreeMap::new();
    for (opt, &sc) in &scores.by_option {
        let pct = (sc as f64) * 100.0 / valid;
        if pct + f64::EPSILON >= threshold_pct {
            filtered.insert(opt.clone(), sc);
        }
    }
    filtered
}

/// Build a **last-seat** tie context for reporting/resolution downstream.
/// The resolver will use VM-VAR-050/052 to pick the winner if needed.
pub fn make_last_seat_tie_context(
    unit: &UnitId,
    contenders: &[OptionId],
    policy: TiePolicy, // VM-VAR-050
) -> TieContext {
    let mut c = contenders.to_vec();
    c.sort(); // stable canonical payload
    TieContext {
        unit_id: unit.clone(),
        kind: TieKind::LastSeat,
        contenders: c,
        policy,
    }
}

/// Validate WTA magnitude at the allocation stage boundary. In a strictly
/// validated pipeline this should be unreachable; we keep the guard to defend
/// against upstream drift and map it to an AllocateError.
pub fn ensure_wta_magnitude(unit: &UnitId, magnitude: u32) -> Result<(), AllocateError> {
    if magnitude == 1 {
        Ok(())
    } else {
        Err(AllocateError::WtaRequiresMagnitude1 {
            unit: unit.clone(),
            got: magnitude,
        })
    }
}

/// Ensure LR quota presence when method == LargestRemainder.
/// In a strictly validated pipeline this should be unreachable.
pub fn ensure_lr_quota(unit: &UnitId, quota: Option<LrQuotaKind>) -> Result<LrQuotaKind, AllocateError> {
    match quota {
        Some(q) => Ok(q),
        None => Err(AllocateError::LrQuotaMissing { unit: unit.clone() }),
    }
}
// crates/vm_pipeline/src/allocate.rs — Part 2/2 (patched)
//
// Full allocation routine with spec-aligned tie handling and guards.
// Pairs with Part 1/2 in this same module file. No blocks are split mid-way.

use std::collections::BTreeMap;

use vm_core::{
    entities::{OptionItem, TallyTotals, UnitMeta, UnitScores},
    ids::{OptionId, UnitId},
};
use vm_algo::enums::{AllocationMethod, LrQuotaKind, TiePolicy};
use vm_pipeline::ties::{TieContext, TieKind};
use vm_pipeline::PipelineError;

use crate::vm_pipeline::allocate::{
    // From Part 1/2 (same module file)
    apply_pr_threshold, assert_option_set_alignment, ensure_lr_quota, ensure_wta_magnitude,
    make_last_seat_tie_context, AllocateError, AllocateOutputs, UnitAllocation,
};

// ------------------------- public entrypoints -------------------------

/// Allocate seats for all units, returning per-unit allocations and any tie
/// contexts that must be resolved/logged downstream.
pub fn allocate_all_units(
    options_by_unit: &BTreeMap<UnitId, Vec<OptionItem>>,
    scores_by_unit: &BTreeMap<UnitId, UnitScores>,
    meta_by_unit: &BTreeMap<UnitId, UnitMeta>,
    tie_policy: TiePolicy, // VM-VAR-050 (Included)
) -> Result<AllocateOutputs, PipelineError> {
    let mut out = AllocateOutputs::default();

    // Iterate in stable UnitId order (BTreeMap guarantees).
    for (unit_id, options) in options_by_unit {
        // Fetch scores/meta
        let scores = scores_by_unit
            .get(unit_id)
            .ok_or_else(|| AllocateError::MissingScores { unit: unit_id.clone() })?;
        let meta = meta_by_unit
            .get(unit_id)
            .ok_or_else(|| PipelineError::Allocate(format!("missing meta for unit {unit_id}")))?;

        // Guard: option set alignment (structural)
        assert_option_set_alignment(unit_id, options, scores)?;

        let (alloc, mut ties) = allocate_one_unit(unit_id, options, scores, meta, tie_policy)?;
        out.per_unit.insert(unit_id.clone(), alloc);
        out.ties.append(&mut ties);
    }

    Ok(out)
}

/// Allocate a single unit according to its allocation method and parameters.
/// Emits a `UnitAllocation` and zero or more `TieContext`s (e.g., last-seat ties).
pub fn allocate_one_unit(
    unit: &UnitId,
    options: &[OptionItem],
    scores: &UnitScores,
    meta: &UnitMeta,
    tie_policy: TiePolicy, // VM-VAR-050
) -> Result<(UnitAllocation, Vec<TieContext>), PipelineError> {
    let mut ties: Vec<TieContext> = Vec::new();

    // Pull per-unit method/magnitude/threshold/quota from metadata.
    let method = get_method(meta);
    let magnitude = get_magnitude(meta);
    let pr_threshold = get_pr_threshold_pct(meta);
    let lr_quota = get_lr_quota_kind(meta);

    match method {
        AllocationMethod::WinnerTakeAll => {
            // Winner-take-all: magnitude MUST be 1 (validated upstream; checked here defensively)
            ensure_wta_magnitude(unit, magnitude)?;

            // Detect top score and candidates; WTA doesn’t need PR thresholding.
            let mut max_votes: u64 = 0;
            for &v in scores.by_option.values() {
                if v > max_votes {
                    max_votes = v;
                }
            }

            // Collect all contenders tied at max
            let mut contenders: Vec<OptionId> = scores
                .by_option
                .iter()
                .filter_map(|(opt, &v)| if v == max_votes { Some(opt.clone()) } else { None })
                .collect();

            let mut seats: BTreeMap<OptionId, u32> = options.iter().map(|o| (o.id.clone(), 0u32)).collect();
            let mut last_seat_tie = false;

            if contenders.is_empty() {
                // Degenerate: no options present (normally blocked upstream). Nothing to allocate.
                // Leave all zeros; no tie.
            } else if contenders.len() == 1 {
                // Single winner
                seats.insert(contenders[0].clone(), 1);
            } else {
                // Tie for the seat → log for downstream resolver
                last_seat_tie = true;

                // Emit a concrete tie context for the resolver/logs
                let mut contenders_ctx = contenders.clone();
                contenders_ctx.sort(); // stable order for context payload
                ties.push(make_last_seat_tie_context(unit, &contenders_ctx, tie_policy));

                // Status-quo requires an anchor we don't have here → refuse deterministically
                if tie_policy == TiePolicy::StatusQuo {
                    return Err(AllocateError::StatusQuoAnchorMissing { unit: unit.clone() }.into());
                }

                // Deterministic placeholder to keep structure consistent until resolver runs:
                // - deterministic_order → registry order (order_index, then OptionId)
                // - random              → lexicographically smallest OptionId
                let winner = if tie_policy == TiePolicy::DeterministicOrder {
                    // sort by registry order
                    let mut items: Vec<OptionId> = contenders.into_iter().collect();
                    items.sort_by_key(|id| {
                        options
                            .iter()
                            .find(|o| o.id == *id)
                            .map(|o| (o.order_index, id.clone()))
                            .unwrap_or((u32::MAX, id.clone()))
                    });
                    items[0].clone()
                } else {
                    // random policy: resolver will later record RNG crumbs (VM-VAR-052)
                    contenders.sort();
                    contenders[0].clone()
                };

                seats.insert(winner, 1);
            }

            let alloc = UnitAllocation {
                seats_by_option: seats,
                last_seat_tie,
            };
            Ok((alloc, ties))
        }

        AllocationMethod::Dhondt => {
            // Apply PR entry threshold first
            let turnout = get_turnout(scores);
            let filtered = apply_pr_threshold(scores, &turnout, pr_threshold);

            // Run the allocator in vm_algo. If your vm_algo exposes last-seat tie
            // details, propagate them here; else we conservatively set false.
            let seats = vm_algo::allocation::dhondt_allocate(magnitude, &filtered)
                .map_err(|m| PipelineError::Allocate(format!("dhondt: {m}")))?;

            let alloc = UnitAllocation {
                seats_by_option: reorder_to_registry(options, seats),
                last_seat_tie: false, // TODO: set true and push context if vm_algo exposes contenders
            };
            Ok((alloc, ties))
        }

        AllocationMethod::SainteLague => {
            let turnout = get_turnout(scores);
            let filtered = apply_pr_threshold(scores, &turnout, pr_threshold);

            let seats = vm_algo::allocation::sainte_lague_allocate(magnitude, &filtered)
                .map_err(|m| PipelineError::Allocate(format!("sainte_lague: {m}")))?;

            let alloc = UnitAllocation {
                seats_by_option: reorder_to_registry(options, seats),
                last_seat_tie: false, // TODO: propagate tie details if available
            };
            Ok((alloc, ties))
        }

        AllocationMethod::LargestRemainder => {
            let turnout = get_turnout(scores);
            let filtered = apply_pr_threshold(scores, &turnout, pr_threshold);

            let quota = ensure_lr_quota(unit, lr_quota)?;

            let seats = vm_algo::allocation::largest_remainder_allocate(magnitude, &filtered, quota)
                .map_err(|m| PipelineError::Allocate(format!("largest_remainder: {m}")))?;

            let alloc = UnitAllocation {
                seats_by_option: reorder_to_registry(options, seats),
                last_seat_tie: false, // TODO: propagate tie details if available
            };
            Ok((alloc, ties))
        }

        // If you have additional methods (e.g., MixedLocalCorrection), either dispatch
        // here to the appropriate vm_algo entrypoint or mark unreachable if validated upstream.
        other => Err(PipelineError::Allocate(format!(
            "unsupported allocation method for unit {unit}: {other:?}"
        ))),
    }
}

// ------------------------- small getters / adapters -------------------------

/// Get allocation method from unit meta (adjust if your API differs).
#[inline]
fn get_method(meta: &UnitMeta) -> AllocationMethod {
    meta.allocation_method
}

/// Get magnitude from unit meta (adjust if your API differs).
#[inline]
fn get_magnitude(meta: &UnitMeta) -> u32 {
    meta.magnitude
}

/// Get PR entry threshold pct from unit meta or params; default to 0.0 if unspecified.
/// Adjust if your API differs (e.g., Option<f64> in meta or computed from ParameterSet).
#[inline]
fn get_pr_threshold_pct(meta: &UnitMeta) -> f64 {
    meta.pr_threshold_pct.unwrap_or(0.0)
}

/// Get LR quota kind for Largest Remainder (adjust if your API differs).
#[inline]
fn get_lr_quota_kind(meta: &UnitMeta) -> Option<LrQuotaKind> {
    meta.lr_quota_kind
}

/// Extract turnout totals from UnitScores (adjust field/method name if needed).
#[inline]
fn get_turnout(scores: &UnitScores) -> TallyTotals {
    // If your struct exposes `totals` or `turnout`, adjust accordingly.
    scores.totals.clone()
}

/// Reorder seats map to registry order (order_index, then OptionId) for stable emission.
/// NOTE: This returns a BTreeMap keyed by OptionId; the *iteration* order here will be
/// OptionId-lexicographic. The packaging/reporting stage must use `options` to emit in
/// registry order when order matters (Doc 7).
#[inline]
fn reorder_to_registry(
    options: &[OptionItem],
    seats_by_option: BTreeMap<OptionId, u32>,
) -> BTreeMap<OptionId, u32> {
    let mut out = BTreeMap::new();
    // We keep a map here for compatibility; order-sensitive emission happens later.
    // Still, ensure all known options are present (fill zeros) to avoid sparse maps.
    let known: BTreeMap<OptionId, u32> = options.iter().map(|o| (o.id.clone(), 0u32)).collect();
    for (k, v) in known {
        let val = *seats_by_option.get(&k).unwrap_or(&0);
        out.insert(k, val);
    }
    out
}

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/aggregate.rs
--------------------------------------------------------------------------------
//! APPLY_RULES stage: evaluate legitimacy gates in fixed order
//! Quorum → Majority/Supermajority → Double-majority (optional) → Symmetry (optional).
//!
//! Pure integer/rational math; no RNG. Approval majority uses approvals_for_change / valid_ballots.
//! This module intentionally does not perform frontier mapping or tie handling.

use std::collections::{BTreeMap, BTreeSet};

use vm_core::{
    ids::UnitId,
    rounding::{ge_percent, Ratio},
    variables::{BallotType, Params},
};

/// Minimal aggregate row used by gate math.
#[derive(Clone, Copy, Debug, Default)]
pub struct AggregateRow {
    pub ballots_cast: u64,
    pub invalid_or_blank: u64,
    pub valid_ballots: u64,
    pub eligible_roll: u64,
    pub approvals_for_change: Option<u64>, // present for approval ballots
}

#[derive(Clone, Debug, Default)]
pub struct AggregatesView {
    pub national: AggregateRow,
    pub by_region: BTreeMap<UnitId, AggregateRow>, // empty if not needed
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum DenomPolicy {
    /// Majority over valid ballots only.
    ValidBallots,
    /// Majority over valid + blank/invalid when VM-VAR-007 toggles this for gates.
    ValidPlusBlank,
    /// Approval support: approvals_for_change / valid_ballots (fixed).
    ApprovalRateValid,
}

#[derive(Clone, Copy, Debug)]
pub struct GateOutcome {
    pub observed: Ratio,   // exact rational; packaging converts to numbers later
    pub threshold_pct: u8, // integer percent
    pub pass: bool,
}

#[derive(Clone, Debug)]
pub struct DoubleOutcome {
    pub national: GateOutcome,
    pub family: GateOutcome,
    pub pass: bool,
    pub members: Vec<UnitId>, // affected family (canonical order)
}

#[derive(Clone, Debug)]
pub struct SymmetryOutcome {
    pub respected: bool,
    pub exceptions: Vec<String>, // codes from Params (VM-VAR-029), if any
}

#[derive(Clone, Debug)]
pub struct QuorumDetail {
    pub national: GateOutcome,                          // turnout Σ ballots_cast / Σ eligible_roll
    pub per_unit_flags: Option<BTreeMap<UnitId, bool>>, // per-unit turnout pass/fail if configured
}

#[derive(Clone, Debug)]
pub struct LegitimacyReport {
    pub pass: bool,
    pub reasons: Vec<String>, // stable machine-readable strings
    pub quorum: QuorumDetail,
    pub majority: GateOutcome,
    pub double_majority: Option<DoubleOutcome>,
    pub symmetry: Option<SymmetryOutcome>,
}

// -------------------------------------------------------------------------------------------------
// Public API
// -------------------------------------------------------------------------------------------------

/// Evaluate decision rules in fixed order. The returned `LegitimacyReport` is deterministic.
///
/// `per_unit_turnout` is optional input to annotate per-unit quorum flags (when configured).
pub fn apply_decision_rules(
    agg: &AggregatesView,
    p: &Params,
    per_unit_turnout: Option<&BTreeMap<UnitId, AggregateRow>>,
) -> LegitimacyReport {
    let mut reasons: Vec<String> = Vec::new();

    // A) Quorum (national + optional per-unit flags)
    let (quorum_detail, quorum_pass) = eval_quorum(agg, p, per_unit_turnout);
    if !quorum_pass {
        reasons.push("Quorum.NationalBelowThreshold".to_string());
    }

    // B) Majority / Supermajority (national)
    let (majority_outcome, maj_pass) = eval_majority(agg, p);
    if !maj_pass {
        reasons.push("Majority.BelowThreshold".to_string());
    }

    // C) Double-majority (optional)
    let (double_outcome_opt, dm_pass) = eval_double_majority(agg, p);
    if !dm_pass {
        // Be specific if we can, otherwise use a generic code.
        let code = if double_outcome_opt.is_none() && p.double_majority_enabled() {
            "DoubleMajority.FamilyUnresolved"
        } else if p.double_majority_enabled() {
            "DoubleMajority.BelowThreshold"
        } else {
            // Not enabled → this gate is not part of pass/fail.
            "DoubleMajority.Disabled"
        };
        if p.double_majority_enabled() {
            reasons.push(code.to_string());
        }
    }

    // D) Symmetry (optional)
    let symmetry_opt = eval_symmetry(p);
    let symmetry_ok = symmetry_opt.as_ref().map(|s| s.respected).unwrap_or(true);
    if !symmetry_ok {
        reasons.push("Symmetry.ExceptionsPresent".to_string());
    }

    // Overall pass: all enabled gates must pass.
    let overall_pass = quorum_pass && maj_pass && dm_pass && symmetry_ok;

    LegitimacyReport {
        pass: overall_pass,
        reasons,
        quorum: quorum_detail,
        majority: majority_outcome,
        double_majority: double_outcome_opt,
        symmetry: symmetry_opt,
    }
}

// -------------------------------------------------------------------------------------------------
// Helpers (pure, deterministic)
// -------------------------------------------------------------------------------------------------

/// ballots_cast / eligible_roll (den>0; if eligible_roll==0, treat as 0/1).
fn turnout_ratio(row: &AggregateRow) -> Ratio {
    let num = row.ballots_cast as i128;
    let den = if row.eligible_roll == 0 { 1 } else { row.eligible_roll } as i128;
    Ratio { num, den } // invariant den > 0
}

/// Determine national support ratio and the denominator policy.
/// - Approval ballots: approvals_for_change / valid_ballots (ApprovalRateValid).
/// - Otherwise: valid (or valid+blank if VM-VAR-007 on).
fn support_ratio_national(agg: &AggregatesView, p: &Params) -> (Ratio, DenomPolicy) {
    match p.ballot_type() {
        BallotType::Approval => {
            let num_u64 = agg.national.approvals_for_change.unwrap_or(0);
            let den_u64 = agg.national.valid_ballots;
            let den = if den_u64 == 0 { 1 } else { den_u64 };
            (
                Ratio {
                    num: num_u64 as i128,
                    den: den as i128,
                },
                DenomPolicy::ApprovalRateValid,
            )
        }
        _ => {
            let include_blank = p.include_blank_in_denominator();
            let valid = agg.national.valid_ballots;
            let den_u64 = if include_blank {
                agg.national.valid_ballots
                    .saturating_add(agg.national.invalid_or_blank)
            } else {
                valid
            };
            // For non-approval ballots, the numerator (support for change) must come from upstream
            // aggregation. If not provided at this stage, we conservatively treat it as 0.
            // Validation should ensure meaningful configuration before reaching here.
            let observed_num = agg.national.approvals_for_change.unwrap_or(0);
            let den = if den_u64 == 0 { 1 } else { den_u64 };
            let policy = if include_blank {
                DenomPolicy::ValidPlusBlank
            } else {
                DenomPolicy::ValidBallots
            };
            (
                Ratio {
                    num: observed_num as i128,
                    den: den as i128,
                },
                policy,
            )
        }
    }
}

/// Resolve affected family members per Params. In absence of a richer resolver,
/// default to all keys in `by_region` (canonical `UnitId` order) when double-majority is enabled.
fn family_units(agg: &AggregatesView, p: &Params) -> Vec<UnitId> {
    if !p.double_majority_enabled() {
        return Vec::new();
    }
    agg.by_region.keys().cloned().collect()
}

/// Family support ratio computed consistently with national policy.
/// When approval: sum approvals_for_change / sum valid.
/// Else: sum (numerators supplied upstream via approvals_for_change if applicable) / sum denom per policy.
fn support_ratio_family(agg: &AggregatesView, members: &[UnitId], p: &Params) -> (Ratio, DenomPolicy) {
    match p.ballot_type() {
        BallotType::Approval => {
            let mut num_sum: u128 = 0;
            let mut den_sum: u128 = 0;
            for u in members {
                if let Some(row) = agg.by_region.get(u) {
                    num_sum = num_sum.saturating_add(row.approvals_for_change.unwrap_or(0) as u128);
                    den_sum = den_sum.saturating_add(row.valid_ballots as u128);
                }
            }
            let den = if den_sum == 0 { 1 } else { den_sum } as i128;
            (
                Ratio {
                    num: num_sum as i128,
                    den,
                },
                DenomPolicy::ApprovalRateValid,
            )
        }
        _ => {
            let include_blank = p.include_blank_in_denominator();
            let mut num_sum: u128 = 0;
            let mut den_sum: u128 = 0;
            for u in members {
                if let Some(row) = agg.by_region.get(u) {
                    // As above: if upstream didn’t supply a numerator, treat as 0.
                    num_sum = num_sum.saturating_add(row.approvals_for_change.unwrap_or(0) as u128);
                    let unit_den = if include_blank {
                        row.valid_ballots.saturating_add(row.invalid_or_blank)
                    } else {
                        row.valid_ballots
                    } as u128;
                    den_sum = den_sum.saturating_add(unit_den);
                }
            }
            let den = if den_sum == 0 { 1 } else { den_sum } as i128;
            let policy = if include_blank {
                DenomPolicy::ValidPlusBlank
            } else {
                DenomPolicy::ValidBallots
            };
            (
                Ratio {
                    num: num_sum as i128,
                    den,
                },
                policy,
            )
        }
    }
}

/// Quorum evaluation: national + optional per-unit flags (when threshold > 0 and input provided).
fn eval_quorum(
    agg: &AggregatesView,
    p: &Params,
    per_unit_turnout: Option<&BTreeMap<UnitId, AggregateRow>>,
) -> (QuorumDetail, bool) {
    let q_nat_pct = p.quorum_global_pct();
    // National turnout
    let nat_ratio = turnout_ratio(&agg.national);
    let nat_pass = ge_percent(
        nat_ratio.num,
        nat_ratio.den,
        q_nat_pct,
    ).unwrap_or(false);

    // Per-unit flags only if configured and data is provided.
    let per_unit_pct = p.quorum_per_unit_pct();
    let per_unit_flags = if per_unit_pct > 0 {
        per_unit_turnout.map(|m| {
            let mut flags = BTreeMap::<UnitId, bool>::new();
            for (uid, row) in m.iter() {
                let r = turnout_ratio(row);
                let ok = ge_percent(r.num, r.den, per_unit_pct).unwrap_or(false);
                flags.insert(uid.clone(), ok);
            }
            flags
        })
    } else {
        None
    };

    let detail = QuorumDetail {
        national: GateOutcome {
            observed: nat_ratio,
            threshold_pct: q_nat_pct,
            pass: nat_pass,
        },
        per_unit_flags,
    };

    (detail, nat_pass)
}

/// National majority/supermajority gate.
fn eval_majority(agg: &AggregatesView, p: &Params) -> (GateOutcome, bool) {
    let (ratio, _policy) = support_ratio_national(agg, p);
    let pct = p.national_majority_pct();
    let pass = ge_percent(ratio.num, ratio.den, pct).unwrap_or(false);
    (
        GateOutcome {
            observed: ratio,
            threshold_pct: pct,
            pass,
        },
        pass,
    )
}

/// Optional double-majority gate. Returns (None, true) when not enabled.
fn eval_double_majority(agg: &AggregatesView, p: &Params) -> (Option<DoubleOutcome>, bool) {
    if !p.double_majority_enabled() {
        return (None, true);
    }

    // National outcome (reuse majority calculation for consistency).
    let (nat_ratio, _) = support_ratio_national(agg, p);
    let nat_pct = p.national_majority_pct();
    let nat_pass = ge_percent(nat_ratio.num, nat_ratio.den, nat_pct).unwrap_or(false);

    // Resolve family members; empty -> failure.
    let members = family_units(agg, p);
    if members.is_empty() {
        return (None, false);
    }

    let (fam_ratio, _) = support_ratio_family(agg, &members, p);
    let fam_pct = p.regional_majority_pct();
    let fam_pass = ge_percent(fam_ratio.num, fam_ratio.den, fam_pct).unwrap_or(false);

    let overall = nat_pass && fam_pass;
    let outcome = DoubleOutcome {
        national: GateOutcome {
            observed: nat_ratio,
            threshold_pct: nat_pct,
            pass: nat_pass,
        },
        family: GateOutcome {
            observed: fam_ratio,
            threshold_pct: fam_pct,
            pass: fam_pass,
        },
        pass: overall,
        members,
    };
    (Some(outcome), overall)
}

/// Optional symmetry check. If disabled, returns None (treated as respected).
fn eval_symmetry(p: &Params) -> Option<SymmetryOutcome> {
    if !p.symmetry_enabled() {
        return None;
    }
    // If exceptions are declared, we report respected = false.
    let exceptions: Vec<String> = p
        .symmetry_exceptions()
        .unwrap_or_default()
        .into_iter()
        .collect();
    let respected = exceptions.is_empty();
    Some(SymmetryOutcome { respected, exceptions })
}

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/apply_rules.rs
--------------------------------------------------------------------------------
//! MAP_FRONTIER stage (runs only if gates PASSED).
//! - Assign one status per Unit via configured bands
//! - Build components using allowed edge types
//! - Apply corridor/island policy (modeled via allowed-edge mask here)
//! - Enforce protected/quorum blocks
//! - Flag mediation (isolated pre-block change) and enclaves (post-block surrounded)
//!
//! Pure integer/rational math; no RNG.

use std::collections::{BTreeMap, BTreeSet, VecDeque};

use vm_core::{
    ids::UnitId,
    entities::EdgeType,      // expected: Land | Bridge | Water
    rounding::{ge_percent, Ratio},
    variables::Params,
};

// ---------- Public view inputs ----------

#[derive(Clone, Debug, Default)]
pub struct UnitsView {
    /// All known units (stable set; determines iteration order)
    pub all: BTreeSet<UnitId>,
    /// Units that must not change status; frontier assignment is forced to "none"
    pub protected: BTreeSet<UnitId>,
}

#[derive(Clone, Debug, Default)]
pub struct AdjacencyView {
    /// Undirected edges (a,b,kind). Each pair may appear once.
    pub edges: Vec<(UnitId, UnitId, EdgeType)>,
}

// ---------- Local types ----------

pub type AllowedEdges = BTreeSet<EdgeType>;

#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Debug)]
pub enum FrontierMode {
    None,
    SlidingScale,
    AutonomyLadder,
}

#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Debug)]
pub enum IslandCorridorRule {
    None,
    FerryAllowed,
    CorridorRequired,
}

#[derive(Clone, Debug)]
pub struct Band {
    pub min_pct: u8,        // inclusive
    pub max_pct: u8,        // inclusive
    pub status: String,     // machine-readable label
    pub ap_id: Option<String>,
}

#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Debug)]
pub struct ComponentId(pub u32);

#[derive(Default, Clone, Debug)]
pub struct UnitFlags {
    pub mediation: bool,
    pub enclave: bool,
    pub protected_blocked: bool,
    pub quorum_blocked: bool,
}

#[derive(Clone, Debug)]
pub struct UnitFrontier {
    pub status: String,                // one of bands[].status or "none" when blocked/mode=None
    pub band_index: Option<usize>,     // index in configured bands (None for "none")
    pub component: ComponentId,
    pub flags: UnitFlags,
}

#[derive(Default, Clone, Debug)]
pub struct FrontierMap {
    pub units: BTreeMap<UnitId, UnitFrontier>,
    pub summary_by_status: BTreeMap<String, u32>,
    /// "mediation","enclave","protected_blocked","quorum_blocked"
    pub summary_flags: BTreeMap<&'static str, u32>,
}

// ---------- Public API ----------

pub fn map_frontier(
    units: &UnitsView,
    unit_support_pct: &BTreeMap<UnitId, Ratio>,
    adjacency: &AdjacencyView,
    p: &Params,
    per_unit_quorum: Option<&BTreeMap<UnitId, bool>>,
) -> FrontierMap {
    // Resolve configured mode & bands
    let (mode, bands) = resolve_mode_and_bands(p);

    // Allowed edges + corridor rule
    let allowed = allowed_edges_from_params(p);
    let corridor = corridor_rule_from_params(p);

    // Components first (deterministic numbering)
    let (comp_of, components) = build_components(adjacency, &allowed, corridor);

    // Fast exit when mode=None: assign "none" to all units but still keep components.
    if matches!(mode, FrontierMode::None) {
        let mut out = FrontierMap::default();
        for uid in &units.all {
            let comp = comp_of.get(uid).cloned().unwrap_or(ComponentId(0));
            out.units.insert(
                uid.clone(),
                UnitFrontier {
                    status: "none".to_string(),
                    band_index: None,
                    component: comp,
                    flags: UnitFlags::default(),
                },
            );
        }
        update_summaries(&mut out);
        return out;
    }

    // Pass 1: compute intended (pre-block) status from bands
    let mut planned_status: BTreeMap<UnitId, (String, Option<usize>)> = BTreeMap::new();
    for uid in &units.all {
        let support = unit_support_pct
            .get(uid)
            .cloned()
            .unwrap_or(Ratio { num: 0, den: 1 });
        planned_status.insert(uid.clone(), pick_band_status(support, &bands));
    }

    // Pass 2: instantiate UnitFrontier entries with blocks (protected/quorum), but keep
    // a copy of the original planned status for mediation analysis.
    let mut out = FrontierMap::default();
    for uid in &units.all {
        let (mut status, mut band_idx) = planned_status[uid].clone();
        let comp = comp_of.get(uid).cloned().unwrap_or(ComponentId(0));
        let mut flags = UnitFlags::default();

        apply_protection_and_quorum(uid, &mut status, &mut band_idx, &mut flags, units, per_unit_quorum);

        out.units.insert(
            uid.clone(),
            UnitFrontier {
                status,
                band_index: band_idx,
                component: comp,
                flags,
            },
        );
    }

    // Pass 3: mediation — if a unit planned a non-"none" status, but has no neighbor
    // with the same planned status (under allowed edges), mark mediation and force "none".
    // (We look at planned statuses to capture isolation independent of blocks.)
    {
        // Build adjacency map constrained to allowed edges, to check same-status neighbors.
        let adj = adjacency_map(adjacency, &allowed);

        for uid in &units.all {
            let (planned, _) = &planned_status[uid];
            if planned == "none" {
                continue;
            }
            // Does it have any neighbor planning the same status?
            let mut has_same_neighbor = false;
            if let Some(neis) = adj.get(uid) {
                for v in neis {
                    if let Some((nbr_planned, _)) = planned_status.get(v) {
                        if nbr_planned == planned {
                            has_same_neighbor = true;
                            break;
                        }
                    }
                }
            }
            if !has_same_neighbor {
                if let Some(uf) = out.units.get_mut(uid) {
                    uf.flags.mediation = true;
                    uf.status = "none".to_string();
                    uf.band_index = None;
                }
            }
        }
    }

    // Pass 4: enclaves — after final statuses, a unit with status != "none" is an enclave
    // if all its neighbors (within allowed edges) are "none". Require at least one neighbor.
    {
        let adj = adjacency_map(adjacency, &allowed);
        for uid in &units.all {
            let mut has_neighbor = false;
            let mut all_neighbors_none = true;
            if let Some(uf) = out.units.get(uid) {
                if uf.status == "none" {
                    continue;
                }
                if let Some(neis) = adj.get(uid) {
                    for v in neis {
                        has_neighbor = true;
                        let ns = &out.units[v].status;
                        if ns != "none" {
                            all_neighbors_none = false;
                            break;
                        }
                    }
                }
                if has_neighbor && all_neighbors_none {
                    if let Some(ufm) = out.units.get_mut(uid) {
                        ufm.flags.enclave = true;
                    }
                }
            }
        }
    }

    update_summaries(&mut out);
    out
}

// ---------- Internals ----------

fn resolve_mode_and_bands(p: &Params) -> (FrontierMode, Vec<Band>) {
    // These accessors mirror the variables noted in the spec. If Params exposes different
    // method names in your tree, wire them here.
    let mode = match p.frontier_mode() {
        // Assume vm_core::variables::FrontierMode isomorphic to ours:
        vm_core::variables::FrontierMode::None => FrontierMode::None,
        vm_core::variables::FrontierMode::SlidingScale => FrontierMode::SlidingScale,
        vm_core::variables::FrontierMode::AutonomyLadder => FrontierMode::AutonomyLadder,
    };

    let mut bands = Vec::<Band>::new();
    for b in p.frontier_bands().unwrap_or_default() {
        // Assume `b` exposes (min,max,status,ap_id?) getters
        bands.push(Band {
            min_pct: b.min_pct(),
            max_pct: b.max_pct(),
            status: b.status().to_string(),
            ap_id: b.ap_id(),
        });
    }
    (mode, bands)
}

fn allowed_edges_from_params(p: &Params) -> AllowedEdges {
    // Expect Params to expose a set of EdgeType values; default to {Land, Bridge} if absent.
    let mut set: AllowedEdges = p.frontier_allowed_edge_types().unwrap_or_default();
    if set.is_empty() {
        set.insert(EdgeType::Land);
        set.insert(EdgeType::Bridge);
    }
    set
}

fn corridor_rule_from_params(p: &Params) -> IslandCorridorRule {
    match p.island_corridor_rule() {
        vm_core::variables::IslandCorridorRule::None => IslandCorridorRule::None,
        vm_core::variables::IslandCorridorRule::FerryAllowed => IslandCorridorRule::FerryAllowed,
        vm_core::variables::IslandCorridorRule::CorridorRequired => IslandCorridorRule::CorridorRequired,
    }
}

/// Create adjacency lists filtered by `allowed` edge kinds.
fn adjacency_map(
    adjacency: &AdjacencyView,
    allowed: &AllowedEdges,
) -> BTreeMap<UnitId, BTreeSet<UnitId>> {
    let mut map: BTreeMap<UnitId, BTreeSet<UnitId>> = BTreeMap::new();
    for (a, b, kind) in &adjacency.edges {
        if allowed.contains(kind) {
            map.entry(a.clone()).or_default().insert(b.clone());
            map.entry(b.clone()).or_default().insert(a.clone());
        }
    }
    map
}

fn build_components(
    adjacency: &AdjacencyView,
    allowed: &AllowedEdges,
    _corridor: IslandCorridorRule,
) -> (BTreeMap<UnitId, ComponentId>, Vec<BTreeSet<UnitId>>) {
    // NOTE: Corridor policy is represented by the allowed-edge mask here. If your engine
    // adds corridor metadata, incorporate it into `allowed` before reaching this point.

    let adj = adjacency_map(adjacency, allowed);

    // Collect all vertices mentioned by edges; isolated vertices can be injected by callers via UnitsView.
    let mut all: BTreeSet<UnitId> = BTreeSet::new();
    for (u, neis) in &adj {
        all.insert(u.clone());
        for v in neis {
            all.insert(v.clone());
        }
    }

    // Build connected components via BFS in UnitId order for determinism.
    let mut seen: BTreeSet<UnitId> = BTreeSet::new();
    let mut comps: Vec<BTreeSet<UnitId>> = Vec::new();

    for start in &all {
        if seen.contains(start) {
            continue;
        }
        let mut comp = BTreeSet::<UnitId>::new();
        let mut q = VecDeque::<UnitId>::new();
        q.push_back(start.clone());
        seen.insert(start.clone());
        comp.insert(start.clone());

        while let Some(u) = q.pop_front() {
            if let Some(neis) = adj.get(&u) {
                for v in neis {
                    if !seen.contains(v) {
                        seen.insert(v.clone());
                        comp.insert(v.clone());
                        q.push_back(v.clone());
                    }
                }
            }
        }
        comps.push(comp);
    }

    // Sort components by their smallest UnitId to fix numbering, then assign IDs 0..N-1.
    comps.sort_by(|a, b| a.iter().next().cmp(&b.iter().next()));

    let mut comp_of: BTreeMap<UnitId, ComponentId> = BTreeMap::new();
    for (idx, comp) in comps.iter().enumerate() {
        let cid = ComponentId(idx as u32);
        for u in comp {
            comp_of.insert(u.clone(), cid);
        }
    }

    (comp_of, comps)
}

/// Inclusive band check: pick the first band b where min ≤ pct(support) ≤ max.
fn pick_band_status(support: Ratio, bands: &[Band]) -> (String, Option<usize>) {
    for (i, b) in bands.iter().enumerate() {
        let ge_min = ge_percent(support.num, support.den, b.min_pct).unwrap_or(false);
        // For the inclusive upper bound, check NOT (support ≥ max+1)
        let lt_next = if b.max_pct < 100 {
            !ge_percent(support.num, support.den, b.max_pct.saturating_add(1)).unwrap_or(false)
        } else {
            true // max=100 means anything ≥100% still qualifies
        };
        if ge_min && lt_next {
            return (b.status.clone(), Some(i));
        }
    }
    ("none".to_string(), None)
}

fn apply_protection_and_quorum(
    unit_id: &UnitId,
    intended_status: &mut String,
    band_idx: &mut Option<usize>,
    flags: &mut UnitFlags,
    units: &UnitsView,
    per_unit_quorum: Option<&BTreeMap<UnitId, bool>>,
) {
    if units.protected.contains(unit_id) && intended_status.as_str() != "none" {
        flags.protected_blocked = true;
        *intended_status = "none".to_string();
        *band_idx = None;
    }
    if let Some(map) = per_unit_quorum {
        if let Some(false) = map.get(unit_id).copied() {
            flags.quorum_blocked = true;
            *intended_status = "none".to_string();
            *band_idx = None;
        }
    }
}

fn tag_mediation_and_enclaves(
    _unit_id: &UnitId,
    _unit_map: &mut BTreeMap<UnitId, UnitFrontier>,
    _components: &Vec<BTreeSet<UnitId>>,
    _allowed: &AllowedEdges,
) {
    // (kept for parity with the design doc; mediation/enclave tagging happens inline in map_frontier())
}

fn update_summaries(out: &mut FrontierMap) {
    // Status counts
    let mut by_status: BTreeMap<String, u32> = BTreeMap::new();
    // Flag counts
    let mut f_mediation = 0u32;
    let mut f_enclave = 0u32;
    let mut f_prot = 0u32;
    let mut f_quorum = 0u32;

    for (_u, entry) in &out.units {
        *by_status.entry(entry.status.clone()).or_insert(0) += 1;
        if entry.flags.mediation {
            f_mediation += 1;
        }
        if entry.flags.enclave {
            f_enclave += 1;
        }
        if entry.flags.protected_blocked {
            f_prot += 1;
        }
        if entry.flags.quorum_blocked {
            f_quorum += 1;
        }
    }

    out.summary_by_status = by_status;
    out.summary_flags.insert("mediation", f_mediation);
    out.summary_flags.insert("enclave", f_enclave);
    out.summary_flags.insert("protected_blocked", f_prot);
    out.summary_flags.insert("quorum_blocked", f_quorum);
}

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/map_frontier.rs
--------------------------------------------------------------------------------
//! crates/vm_pipeline/src/map_frontier.rs
//! NOTE: This module implements *allocation-affecting tie resolution* per VM-VAR-050 (tie_policy)
//! and VM-VAR-052 (tie_seed). RNG is used **only** when policy = "random" and a real tie occurs.
//!
//! Log vocabulary (Doc 6 / Annex A):
//!   policy ∈ {"status_quo","deterministic_order","random"}
//!   context is a stable code (e.g., "WTA U:<unit>", "LAST_SEAT U:<unit>", "IRV_ELIM U:<unit>").
//!
//! This file is delivered in two parts; this is Part 1 (types, policy surface, and models).

#![forbid(unsafe_code)]

use std::collections::{BTreeMap, BTreeSet};

use vm_core::{
    entities::OptionItem,
    ids::{OptionId, UnitId},
    variables::Params,
};
use vm_core::rng::{tie_rng_from_seed, TieRng}; // seed: u64 → deterministic RNG

/* ------------------------------ Public policy surface ------------------------------ */

/// Effective tie policy derived from `Params` (VM-VAR-050,052).
#[derive(Clone, Debug)]
pub enum TiePolicy {
    /// Prefer the status-quo option if (and only if) exactly one candidate matches it.
    StatusQuo { status_quo: OptionId },
    /// Deterministic by registry order (order_index, then OptionId).
    DeterministicOrder,
    /// Random among candidates, seeded by VM-VAR-052.
    Random { seed: u64 }, // VM-VAR-052
}

impl TiePolicy {
    /// Build the effective policy from `Params` and an optional status-quo option id for this context.
    pub fn from_params(p: &Params, status_quo: OptionId) -> Self {
        match p.v050_tie_policy.as_str() {
            // Allowed spellings; align to canonical tokens upstream if needed.
            "status_quo" | "status-quo" | "sq" => TiePolicy::StatusQuo { status_quo },
            "deterministic_order" | "deterministic" | "order" => TiePolicy::DeterministicOrder,
            "random" => TiePolicy::Random { seed: p.v052_tie_seed },
            other => {
                // Unknown → fall back to deterministic (spec-safe default).
                tracing::warn!("unknown tie_policy '{}', falling back to deterministic_order", other);
                TiePolicy::DeterministicOrder
            }
        }
    }
}

/* ----------------------------------- Input model ----------------------------------- */

/// What kind of tie is being resolved (stable code used in logging).
#[derive(Clone, Debug)]
pub enum TieKind {
    Wta,          // winner-take-all
    LastSeat,     // last seat fill
    IrvElim,      // IRV elimination
    Custom(&'static str),
}

impl TieKind {
    #[inline]
    pub fn code(&self) -> &'static str {
        match self {
            TieKind::Wta => "WTA",
            TieKind::LastSeat => "LAST_SEAT",
            TieKind::IrvElim => "IRV_ELIM",
            TieKind::Custom(s) => s,
        }
    }
}

/// One tie to resolve.
#[derive(Clone, Debug)]
pub struct TieContext {
    pub unit_id: UnitId,
    pub kind: TieKind,
    /// Candidates among which to pick a winner.
    pub candidates: Vec<OptionId>,
    /// Optional status-quo candidate for this context (used only if policy = StatusQuo).
    pub status_quo: Option<OptionId>,
    /// Canonical options for this unit (ordered by (order_index, OptionId)).
    pub options: Vec<OptionItem>,
}

/* ------------------------------------ Outputs -------------------------------------- */

#[derive(Clone, Debug)]
pub struct TieOutcome {
    pub unit_id: UnitId,
    pub winner: OptionId,
    pub log: TieLogEntry,
}

/// Log entry for one tie resolution (Doc 6 acceptance).
#[derive(Clone, Debug)]
pub struct TieLogEntry {
    pub context: String,       // e.g., "WTA U:<unit>"
    pub policy: &'static str,  // "status_quo" | "deterministic_order" | "random"
    pub detail: TieDetail,
    pub candidates: Vec<OptionId>, // canonicalized candidates (stable order)
}

#[derive(Clone, Debug)]
pub enum TieDetail {
    /// Winner is the status-quo option (must be uniquely present among candidates).
    StatusQuo { option: OptionId },
    /// Winner is the lowest (order_index, OptionId) among candidates.
    OrderIndex { order_index: u32 },
    /// Winner chosen uniformly at random among candidates using VM-VAR-052.
    Rng { seed: u64 /*, word_index: u128 (optional if available)*/ },
}

/// Result for a batch of ties.
#[derive(Clone, Debug, Default)]
pub struct ResolveResult {
    pub outcomes: Vec<TieOutcome>,
    /// True iff at least one tie used the "random" policy (callers should echo rng_seed in RunRecord).
    pub used_random: bool,
}

/* ------------------------------------ Errors --------------------------------------- */

#[derive(thiserror::Error, Debug)]
pub enum ResolveError {
    #[error("empty candidate set")]
    EmptyCandidates,
    #[error("unknown candidate id: {0}")]
    UnknownCandidate(String),
    #[error("status_quo not present among candidates")]
    StatusQuoNotInCandidates,
}

/* ------------- Part 2 (functions & helpers) continues in the next chunk ------------ */
/* --------------------------------- Entry points ------------------------------------ */

/// Resolve a batch of ties. Returns outcomes and whether any random policy fired.
pub fn resolve_many(
    ties: &[TieContext],
    policy: &TiePolicy,
) -> Result<ResolveResult, ResolveError> {
    let mut out = ResolveResult::default();
    for t in ties {
        let outcome = resolve_one(t, policy)?;
        if matches!(outcome.log.policy, "random") {
            out.used_random = true;
        }
        out.outcomes.push(outcome);
    }
    Ok(out)
}

/// Resolve a single tie.
pub fn resolve_one(t: &TieContext, policy: &TiePolicy) -> Result<TieOutcome, ResolveError> {
    // Canonicalize candidates: check existence and sort by (order_index, OptionId)
    let index = index_options(&t.options);
    let cands = canonicalize_candidates(&t.candidates, &index)?;

    // Build stable context string for logs
    let ctx_str = format!("{} U:{}", t.kind.code(), t.unit_id);

    // Apply policy
    let (winner, log) = match policy {
        TiePolicy::StatusQuo { status_quo: _ } => {
            if let Some(sq) = &t.status_quo {
                // Status-quo applies only if the SQ candidate is in the tie set; else deterministic fallback.
                if !cands.iter().any(|id| id == sq) {
                    let (w, oi) = pick_by_order(&cands, &index);
                    let log = TieLogEntry {
                        context: ctx_str,
                        policy: "deterministic_order",
                        detail: TieDetail::OrderIndex { order_index: oi },
                        candidates: cands.clone(),
                    };
                    (w, log)
                } else {
                    let log = TieLogEntry {
                        context: ctx_str,
                        policy: "status_quo",
                        detail: TieDetail::StatusQuo { option: sq.clone() },
                        candidates: cands.clone(),
                    };
                    (sq.clone(), log)
                }
            } else {
                // No SQ provided → deterministic fallback
                let (w, oi) = pick_by_order(&cands, &index);
                let log = TieLogEntry {
                    context: ctx_str,
                    policy: "deterministic_order",
                    detail: TieDetail::OrderIndex { order_index: oi },
                    candidates: cands.clone(),
                };
                (w, log)
            }
        }

        TiePolicy::DeterministicOrder => {
            let (w, oi) = pick_by_order(&cands, &index);
            let log = TieLogEntry {
                context: ctx_str,
                policy: "deterministic_order",
                detail: TieDetail::OrderIndex { order_index: oi },
                candidates: cands.clone(),
            };
            (w, log)
        }

        TiePolicy::Random { seed } => {
            let (w, _idx) = pick_by_rng(&cands, *seed)?; // unbiased, deterministic
            let log = TieLogEntry {
                context: ctx_str,
                policy: "random",
                detail: TieDetail::Rng { seed: *seed },
                candidates: cands.clone(),
            };
            (w, log)
        }
    };

    Ok(TieOutcome {
        unit_id: t.unit_id.clone(),
        winner,
        log,
    })
}

/* --------------------------------- Helpers ----------------------------------------- */

/// Build a quick lookup from OptionId → (order_index, OptionItem)
fn index_options(options: &[OptionItem]) -> BTreeMap<OptionId, (&OptionItem, u32)> {
    let mut m = BTreeMap::new();
    for o in options {
        m.insert(o.option_id.clone(), (o, o.order_index));
    }
    m
}

/// Verify that every candidate exists in the unit's options and return them sorted canonically.
fn canonicalize_candidates(
    candidates: &[OptionId],
    index: &BTreeMap<OptionId, (&OptionItem, u32)>,
) -> Result<Vec<OptionId>, ResolveError> {
    if candidates.is_empty() {
        return Err(ResolveError::EmptyCandidates);
    }
    // Use a set to deduplicate while preserving canonical sort via (order_index, OptionId).
    let mut set: BTreeSet<(u32, OptionId)> = BTreeSet::new();
    for id in candidates {
        if let Some((_, oi)) = index.get(id) {
            set.insert((*oi, id.clone()));
        } else {
            return Err(ResolveError::UnknownCandidate(id.to_string()));
        }
    }
    Ok(set.into_iter().map(|(_, id)| id).collect())
}

/// Deterministic pick by lowest (order_index, OptionId).
fn pick_by_order(
    cands: &[OptionId],
    index: &BTreeMap<OptionId, (&OptionItem, u32)>,
) -> (OptionId, u32) {
    let mut best: Option<(&OptionId, u32)> = None;
    for id in cands {
        let (_, oi) = index.get(id).expect("candidate must exist in index");
        match best {
            None => best = Some((id, *oi)),
            Some((_, cur)) if *oi < cur => best = Some((id, *oi)),
            _ => {}
        }
    }
    let (id, oi) = best.expect("non-empty candidates");
    (id.clone(), oi)
}

/// Unbiased random pick using engine RNG (seeded with VM-VAR-052).
fn pick_by_rng(cands: &[OptionId], seed: u64) -> Result<(OptionId, usize), ResolveError> {
    if cands.is_empty() {
        return Err(ResolveError::EmptyCandidates);
    }
    let mut rng: TieRng = tie_rng_from_seed(seed);
    // Prefer engine helper to avoid modulo bias and to keep determinism stable.
    let idx = rng
        .gen_range(cands.len())
        .expect("engine gen_range must handle non-zero upper bound");
    Ok((cands[idx].clone(), idx))
}

/* --------------------------------- Tests (optional) -------------------------------- */
// See Part 1 for commented tests scaffolding; enable once fixtures are available.

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/resolve_ties.rs
--------------------------------------------------------------------------------
//! Final decisiveness labeling (Decisive | Marginal | Invalid).
//!
//! Inputs are gate outcomes, national margin vs threshold (pp), and optional
//! frontier-risk flags. No I/O, no RNG. Deterministic across platforms.

#[cfg(feature = "use_smol_str")]
use smol_str::SmolStr;
#[cfg(not(feature = "use_smol_str"))]
type SmolStr = String;

//
// Public types (minimal mirrors of upstream stages)
//

#[derive(Copy, Clone, Eq, PartialEq, Debug)]
pub enum Label {
    Decisive,
    Marginal,
    Invalid,
}

#[derive(Clone, Debug)]
pub struct DecisivenessLabel {
    pub label: Label,
    /// Short, machine-readable reason (snake_case).
    pub reason: SmolStr,
}

/// Minimal mirror of the gate report we need here.
pub struct LegitimacyReport {
    pub pass: bool,
    pub reasons: Vec<String>, // if pass=false, first item should explain failure
}

#[derive(Copy, Clone, Eq, PartialEq, Debug, Default)]
pub struct FrontierFlags {
    pub mediation_flagged: bool,
    pub enclave: bool,
    pub protected_override_used: bool,
}

#[derive(Copy, Clone, Eq, PartialEq, Debug)]
pub struct LabelConfig {
    /// VM-VAR-062: minimum national margin (pp) required for "Decisive".
    pub decisive_margin_pp: i32,
}

//
// Public API
//

/// Main entry (explicit threshold provided via LabelConfig).
pub fn label_decisiveness_cfg(
    legit: &LegitimacyReport,
    national_margin_pp: i32,
    frontier_flags: Option<&FrontierFlags>,
    cfg: LabelConfig,
) -> DecisivenessLabel {
    // 1) If gates failed → Invalid
    if !legit.pass {
        return DecisivenessLabel {
            label: Label::Invalid,
            reason: first_failure_reason(legit),
        };
    }

    // 2) Margin & frontier risk logic
    if national_margin_pp < cfg.decisive_margin_pp {
        return DecisivenessLabel {
            label: Label::Marginal,
            reason: SmolStr::from("margin_below_threshold"),
        };
    }

    if has_frontier_risk(frontier_flags) {
        return DecisivenessLabel {
            label: Label::Marginal,
            reason: SmolStr::from("frontier_risk_flags_present"),
        };
    }

    DecisivenessLabel {
        label: Label::Decisive,
        reason: SmolStr::from("margin_meets_threshold"),
    }
}

/// Convenience entry that reads VM-VAR-062 from Params.
pub fn label_decisiveness(
    legit: &LegitimacyReport,
    national_margin_pp: i32,
    frontier_flags: Option<&FrontierFlags>,
    params: &vm_core::variables::Params,
) -> DecisivenessLabel {
    let cfg = LabelConfig {
        decisive_margin_pp: params.decisive_margin_pp(),
    };
    label_decisiveness_cfg(legit, national_margin_pp, frontier_flags, cfg)
}

//
// Internal helpers (pure)
//

fn first_failure_reason(legit: &LegitimacyReport) -> SmolStr {
    if let Some(first) = legit.reasons.first() {
        return SmolStr::from(first.as_str());
    }
    SmolStr::from("gates_failed")
}

fn has_frontier_risk(ff: Option<&FrontierFlags>) -> bool {
    if let Some(f) = ff {
        f.mediation_flagged || f.enclave || f.protected_override_used
    } else {
        false
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn lr(pass: bool, reasons: &[&str]) -> LegitimacyReport {
        LegitimacyReport {
            pass,
            reasons: reasons.iter().map(|s| s.to_string()).collect(),
        }
    }

    #[test]
    fn gates_fail_yields_invalid() {
        let legit = lr(false, &["Quorum.NationalBelowThreshold"]);
        let out = label_decisiveness_cfg(&legit, 10, None, LabelConfig { decisive_margin_pp: 5 });
        assert_eq!(out.label, Label::Invalid);
        assert_eq!(out.reason, "Quorum.NationalBelowThreshold");
    }

    #[test]
    fn margin_below_threshold_is_marginal() {
        let legit = lr(true, &[]);
        let out = label_decisiveness_cfg(&legit, 4, None, LabelConfig { decisive_margin_pp: 5 });
        assert_eq!(out.label, Label::Marginal);
        assert_eq!(out.reason, "margin_below_threshold");
    }

    #[test]
    fn equal_to_threshold_is_decisive_when_no_risk() {
        let legit = lr(true, &[]);
        let out = label_decisiveness_cfg(&legit, 5, None, LabelConfig { decisive_margin_pp: 5 });
        assert_eq!(out.label, Label::Decisive);
        assert_eq!(out.reason, "margin_meets_threshold");
    }

    #[test]
    fn frontier_risk_forces_marginal() {
        let legit = lr(true, &[]);
        let ff = FrontierFlags { mediation_flagged: true, enclave: false, protected_override_used: false };
        let out = label_decisiveness_cfg(&legit, 12, Some(&ff), LabelConfig { decisive_margin_pp: 5 });
        assert_eq!(out.label, Label::Marginal);
        assert_eq!(out.reason, "frontier_risk_flags_present");
    }

    #[test]
    fn fallback_reason_when_missing() {
        let legit = lr(false, &[]);
        let out = label_decisiveness_cfg(&legit, 0, None, LabelConfig { decisive_margin_pp: 0 });
        assert_eq!(out.label, Label::Invalid);
        assert_eq!(out.reason, "gates_failed");
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/label.rs
--------------------------------------------------------------------------------
//! BUILD_RESULT — compose the Result artifact from prior pipeline stages.
//!
//! Deterministic assembly only: no I/O and no hashing here. The caller is
//! responsible for canonical serialization + hashing and assigning the
//! Result ID afterwards.

use std::collections::BTreeMap;

use vm_core::{
    ids::{OptionId, UnitId},
    rounding::Ratio,
};

use crate::apply_rules::LegitimacyReport;
use crate::label::{DecisivenessLabel, Label};

/// Engine-level numeric precision when converting exact ratios to JSON numbers.
/// (This is *not* a display precision; callers may pretty-print later.)
const ENGINE_SHARE_PRECISION: f64 = 1e-9;

// ---------- Public surface ----------

/// Opaque FrontierMap ID (e.g., "FR:<hex64>").
pub type FrontierId = String;

/// Error composing Result (kept tiny and deterministic).
#[derive(Debug)]
pub enum BuildError {
    MissingFormulaId,
}

/// Compose a Result (without IDs/hashes). Caller will assign `id` after hashing.
pub fn build_result(
    formula_id: &str,
    agg: &AggregateResults,
    gates: &LegitimacyReport,
    label: &DecisivenessLabel,
    frontier_id: Option<FrontierId>,
) -> Result<ResultDoc, BuildError> {
    if formula_id.is_empty() {
        return Err(BuildError::MissingFormulaId);
    }

    let units = write_unit_blocks(agg);
    let aggregates = write_aggregates_as_numbers(agg);
    let gates_out = write_gates_as_numbers(gates);

    let label_str = match label.label {
        Label::Decisive => "Decisive",
        Label::Marginal => "Marginal",
        Label::Invalid => "Invalid",
    }
    .to_string();

    let mut out = ResultDoc {
        id: None, // assigned by caller after canonicalization + hashing
        formula_id: formula_id.to_string(),
        label: label_str,
        label_reason: label.reason.clone().into(),
        units,
        aggregates,
        gates: gates_out,
        frontier_map_id: None,
    };

    if let Some(fid) = frontier_id {
        out.frontier_map_id = Some(fid);
    }

    Ok(out)
}

// ---------- Conversion helpers ----------

/// Build per-unit blocks in stable UnitId order.
pub fn write_unit_blocks(agg: &AggregateResults) -> Vec<UnitBlock> {
    let mut out = Vec::with_capacity(agg.units.len());
    for (unit_id, u) in &agg.units {
        // Scores / allocation maps are already BTreeMap for stable key order.
        out.push(UnitBlock {
            unit_id: unit_id.clone(),
            turnout: u.turnout.clone(),
            scores: u.scores.clone(),
            allocation: u.allocation.clone(),
            flags: u.flags.clone(),
        });
    }
    out
}

/// Convert exact ratios in aggregates to JSON numbers at engine precision.
pub fn write_aggregates_as_numbers(agg: &AggregateResults) -> AggregatesOut {
    let shares_num = agg
        .shares
        .iter()
        .map(|(opt, r)| (opt.clone(), ratio_to_number(r)))
        .collect::<BTreeMap<_, _>>();

    AggregatesOut {
        totals: agg.totals.clone(),
        shares: shares_num,
        turnout: agg.turnout.clone(),
        weighting_method: agg.weighting_method.clone(),
    }
}

/// Convert gate outcomes’ observed ratios to JSON numbers.
pub fn write_gates_as_numbers(g: &LegitimacyReport) -> GatesOut {
    let quorum = GatePanel {
        observed: ratio_to_number(&g.quorum.national.observed),
        threshold_pct: g.quorum.national.threshold_pct,
        pass: g.quorum.national.pass,
    };

    let majority = GatePanel {
        observed: ratio_to_number(&g.majority.observed),
        threshold_pct: g.majority.threshold_pct,
        pass: g.majority.pass,
    };

    let double_majority = g.double_majority.as_ref().map(|dm| DoubleMajorityOut {
        national: GatePanel {
            observed: ratio_to_number(&dm.national.observed),
            threshold_pct: dm.national.threshold_pct,
            pass: dm.national.pass,
        },
        regional: GatePanel {
            observed: ratio_to_number(&dm.family.observed),
            threshold_pct: dm.family.threshold_pct,
            pass: dm.family.pass,
        },
        pass: dm.pass,
    });

    let symmetry = g
        .symmetry
        .as_ref()
        .map(|s| SymmetryOut { pass: s.respected });

    GatesOut {
        quorum,
        majority,
        double_majority,
        symmetry,
    }
}

// ---------- Local numeric helper ----------

#[inline]
fn ratio_to_number(r: &Ratio) -> f64 {
    // Exact conversion to f64 (engine precision governs consumer expectations).
    // Guard den==0 defensively: treat as 0.0 (validate should prevent this).
    if r.den == 0 {
        return 0.0;
    }
    let v = (r.num as f64) / (r.den as f64);
    // Optionally snap tiny negatives/overflows to 0..1 range if desired:
    // keep as-is for transparency; callers can clamp for presentation.
    (v / ENGINE_SHARE_PRECISION).round() * ENGINE_SHARE_PRECISION
}

// ============================================================================
// Minimal, schema-shaped types for this builder
// (Replace with your canonical crate types if you already have them.)
// ============================================================================

/// Caller attaches canonicalized + hashed id (e.g., "RES:<hex64>") later.
#[derive(Clone, Debug)]
pub struct ResultDoc {
    pub id: Option<String>, // assigned by caller
    pub formula_id: String, // REQUIRED
    pub label: String,      // "Decisive" | "Marginal" | "Invalid"
    pub label_reason: String,
    pub units: Vec<UnitBlock>,
    pub aggregates: AggregatesOut,
    pub gates: GatesOut,
    pub frontier_map_id: Option<FrontierId>,
}

/// One unit’s block in the Result.
#[derive(Clone, Debug)]
pub struct UnitBlock {
    pub unit_id: UnitId,
    pub turnout: UnitTurnoutOut,
    pub scores: BTreeMap<OptionId, u64>,
    pub allocation: AllocationOut,
    pub flags: UnitFlagsOut,
}

/// Allocation representation.
/// - PR: `seats` present, sum equals unit magnitude.
/// - WTA: `power_pct` == 100 for the winner (winner OptionId included for clarity).
#[derive(Clone, Debug)]
pub struct AllocationOut {
    pub seats: Option<BTreeMap<OptionId, u32>>,
    pub wta_winner: Option<OptionId>,
    pub power_pct: Option<u32>, // typically 100 when WTA is used
}

#[derive(Clone, Debug, Default)]
pub struct UnitFlagsOut {
    pub unit_data_ok: bool,
    pub unit_quorum_met: bool,
    pub unit_pr_threshold_met: bool,
    pub protected_override_used: bool,
    pub mediation_flagged: bool,
}

#[derive(Clone, Debug, Default)]
pub struct UnitTurnoutOut {
    pub ballots_cast: u64,
    pub invalid_or_blank: u64,
    pub valid_ballots: u64,
}

/// Aggregates: totals + shares as *numbers* and turnout.
#[derive(Clone, Debug)]
pub struct AggregatesOut {
    pub totals: BTreeMap<OptionId, u64>,
    pub shares: BTreeMap<OptionId, f64>, // numbers, not {num,den}
    pub turnout: AggregatedTurnoutOut,
    pub weighting_method: String,
}

#[derive(Clone, Debug, Default)]
pub struct AggregatedTurnoutOut {
    pub ballots_cast: u64,
    pub invalid_or_blank: u64,
    pub valid_ballots: u64,
    pub eligible_roll: u64,
}

/// Gates panel — observed values as *numbers*.
#[derive(Clone, Debug)]
pub struct GatesOut {
    pub quorum: GatePanel,
    pub majority: GatePanel,
    pub double_majority: Option<DoubleMajorityOut>,
    pub symmetry: Option<SymmetryOut>,
}

#[derive(Clone, Debug)]
pub struct GatePanel {
    pub observed: f64,     // number at engine precision
    pub threshold_pct: u8, // integer percent
    pub pass: bool,
}

#[derive(Clone, Debug)]
pub struct DoubleMajorityOut {
    pub national: GatePanel,
    pub regional: GatePanel,
    pub pass: bool,
}

#[derive(Clone, Debug)]
pub struct SymmetryOut {
    pub pass: bool,
}

// ============================================================================
// Minimal AggregateResults input model (produced upstream by AGGREGATE).
// Replace with your canonical type if already defined.
// ============================================================================

#[derive(Clone, Debug)]
pub struct AggregateResults {
    /// Per-unit view in stable UnitId order (BTreeMap guarantees determinism).
    pub units: BTreeMap<UnitId, UnitAggregate>,
    /// National totals by option (integers).
    pub totals: BTreeMap<OptionId, u64>,
    /// National shares by option (exact ratios).
    pub shares: BTreeMap<OptionId, Ratio>,
    /// National turnout row.
    pub turnout: AggregatedTurnoutOut,
    /// Echo of weighting method (e.g., VM-VAR-030).
    pub weighting_method: String,
}

#[derive(Clone, Debug)]
pub struct UnitAggregate {
    pub turnout: UnitTurnoutOut,
    pub scores: BTreeMap<OptionId, u64>,
    pub allocation: AllocationOut,
    pub flags: UnitFlagsOut,
}

// ============================================================================
// Tests (narrow, deterministic)
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    fn ratio(n: i64, d: i64) -> Ratio {
        Ratio { num: n, den: d }
    }

    #[test]
    fn ratios_convert_to_numbers() {
        assert!((ratio_to_number(&ratio(1, 2)) - 0.5).abs() < 1e-12);
        assert!((ratio_to_number(&ratio(2, 3)) - (2.0 / 3.0)).abs() < 1e-9);
        assert_eq!(ratio_to_number(&ratio(0, 0)), 0.0); // defensive
    }

    #[test]
    fn builds_minimal_result() {
        let unit = UnitAggregate {
            turnout: UnitTurnoutOut {
                ballots_cast: 100,
                invalid_or_blank: 0,
                valid_ballots: 100,
            },
            scores: BTreeMap::new(),
            allocation: AllocationOut {
                seats: None,
                wta_winner: None,
                power_pct: None,
            },
            flags: UnitFlagsOut {
                unit_data_ok: true,
                ..Default::default()
            },
        };

        let mut units = BTreeMap::new();
        let uid = UnitId::from("U:001");
        units.insert(uid.clone(), unit);

        let agg = AggregateResults {
            units,
            totals: BTreeMap::new(),
            shares: BTreeMap::new(),
            turnout: AggregatedTurnoutOut {
                ballots_cast: 100,
                invalid_or_blank: 0,
                valid_ballots: 100,
                eligible_roll: 120,
            },
            weighting_method: "natural".into(),
        };

        // Fake-up a tiny legitimacy report with passing gates
        // (shapes mirror crate::apply_rules types).
        let gates = crate::apply_rules::LegitimacyReport {
            pass: true,
            reasons: vec![],
            quorum: crate::apply_rules::QuorumDetail {
                national: crate::apply_rules::GateOutcome {
                    observed: ratio(100, 120),
                    threshold_pct: 50,
                    pass: true,
                },
                per_unit_flags: None,
            },
            majority: crate::apply_rules::GateOutcome {
                observed: ratio(55, 100),
                threshold_pct: 50,
                pass: true,
            },
            double_majority: None,
            symmetry: None,
        };

        let label = DecisivenessLabel {
            label: Label::Decisive,
            reason: "margin_meets_threshold".into(),
        };

        let res = build_result("abcdef", &agg, &gates, &label, None).expect("ok");
        assert_eq!(res.formula_id, "abcdef");
        assert_eq!(res.label, "Decisive");
        assert!(res.frontier_map_id.is_none());
        assert_eq!(res.units.len(), 1);
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/build_result.rs
--------------------------------------------------------------------------------
//! build_result.rs — Part 1/2
//! Types, inputs, and validators to build a canonical Result artifact.
//! Part 2 will assemble the idless payload, compute sha256 → RES:<sha>,
//! and return (ResultDoc, result_sha256).

use chrono::{DateTime, SecondsFormat, Utc};
use serde::{Deserialize, Serialize};
use serde_json::{self as json};

use crate::{ResultDoc, ResultSummary, UnitResult};

/// ---------- Errors specific to building a Result ----------
#[derive(Debug)]
pub enum BuildResultError {
    BadUtc(&'static str, String),
    BadHex64(&'static str, String),
    UnitsOrder(String),
    Spec(String),
}

/// ---------- Inputs for building a Result (caller provides units + tie count) ----------
#[derive(Debug, Clone)]
pub struct ResultInputs {
    /// FID (sha256 of the Normative Manifest) — hex64 lowercase.
    pub formula_id: String,
    /// Engine version token, e.g., "VM-ENGINE v0".
    pub engine_version: String,
    /// RFC3339 UTC; will be normalized and echoed as `created_at`.
    pub created_at_utc: String,
    /// Ordered per-unit outcomes (must already be in canonical order).
    pub units: Vec<UnitResult>,
    /// Presentation-only label (already computed by caller per Doc 7 rules).
    pub label: Option<String>,
    /// Total number of tie events encountered during allocation (for summary).
    pub tie_count: u64,
}

/// ---------- Internal: idless Result shape used for canonical hashing ----------
#[derive(Debug, Clone, Serialize)]
struct ResultNoId {
    pub formula_id: String,
    pub engine_version: String,
    pub created_at: String,        // normalized RFC3339 Z
    pub summary: ResultSummary,
    pub units: Vec<UnitResult>,    // ordered
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,     // presentation-only
}

/// ---------- Validators & helpers (pure, deterministic) ----------

/// Parse+normalize an RFC3339 UTC (must end with 'Z'); returns normalized string.
pub fn normalize_rfc3339_utc(name: &'static str, ts: &str) -> Result<String, BuildResultError> {
    let dt: DateTime<Utc> = ts
        .parse::<DateTime<Utc>>()
        .map_err(|_| BuildResultError::BadUtc(name, ts.to_string()))?;
    Ok(dt.to_rfc3339_opts(SecondsFormat::Secs, true))
}

/// Lowercase hex64 check.
pub fn is_hex64(s: &str) -> bool {
    if s.len() != 64 {
        return false;
    }
    s.bytes().all(|b| matches!(b, b'0'..=b'9' | b'a'..=b'f'))
}

pub fn validate_hex64(name: &'static str, s: &str) -> Result<(), BuildResultError> {
    if is_hex64(s) {
        Ok(())
    } else {
        Err(BuildResultError::BadHex64(name, s.to_string()))
    }
}

/// Ensure units are in canonical order (lexicographic by unit_id).
/// We do not reorder here; we fail fast to keep the pipeline explicit.
pub fn check_units_canonical_order(units: &[UnitResult]) -> Result<(), BuildResultError> {
    for i in 1..units.len() {
        if units[i - 1].unit_id > units[i].unit_id {
            return Err(BuildResultError::UnitsOrder(format!(
                "units not sorted: {} > {} at index {}",
                units[i - 1].unit_id, units[i].unit_id, i
            )));
        }
    }
    Ok(())
}

/// Compute the summary block deterministically.
pub fn compute_summary(units: &[UnitResult], tie_count: u64) -> ResultSummary {
    let unit_count = units.len() as u64;
    let allocation_count = units
        .iter()
        .filter(|u| u.assigned_to.is_some())
        .count() as u64;
    ResultSummary {
        unit_count,
        allocation_count,
        tie_count,
    }
}

/// Validate high-level inputs and return normalized fields ready for assembly.
pub fn validate_result_inputs(inp: &ResultInputs) -> Result<(String, String), BuildResultError> {
    // FID sanity
    validate_hex64("formula_id (sha256)", &inp.formula_id)?;
    // Engine version must not be empty
    if inp.engine_version.trim().is_empty() {
        return Err(BuildResultError::Spec("engine_version is empty".into()));
    }
    // Normalize timestamp
    let created_at_norm = normalize_rfc3339_utc("created_at_utc", &inp.created_at_utc)?;
    // Units canonical order
    check_units_canonical_order(&inp.units)?;
    Ok((inp.formula_id.clone(), created_at_norm))
}
//! build_result.rs — Part 2/2
//! Assemble idless payload → canonical bytes → sha256,
//! form "RES:<sha256>", self-verify, and return (ResultDoc, result_sha256).

use std::path::Path;
use std::fs::File;
use std::io::Write;

use vm_io::{
    canonical_json::to_canonical_bytes,
    hasher::sha256_hex,
};

use crate::{ResultDoc, ResultSummary, UnitResult};

use super::{
    BuildResultError,
    ResultInputs,
    ResultNoId,
    compute_summary,
    validate_result_inputs,
};

/// Build the canonical Result artifact and return `(ResultDoc, result_sha256)`.
pub fn build_result(inp: ResultInputs) -> Result<(ResultDoc, String), BuildResultError> {
    // ---- Validate & normalize inputs ----
    let (_fid_ok, created_at_norm) = validate_result_inputs(&inp)?;
    let summary: ResultSummary = compute_summary(&inp.units, inp.tie_count);

    // ---- Idless payload (used for canonical hashing) ----
    let noid = ResultNoId {
        formula_id: inp.formula_id.clone(),
        engine_version: inp.engine_version.clone(),
        created_at: created_at_norm.clone(),
        summary,
        units: inp.units.clone(),
        label: inp.label.clone(),
    };

    // ---- Canonical bytes → sha256 ----
    let canon_bytes = to_canonical_bytes(&noid)
        .map_err(|_| BuildResultError::Spec("canonicalization failed".into()))?;
    let res_sha = sha256_hex(&canon_bytes);
    let res_id = format!("RES:{res_sha}");

    // ---- Assemble final document ----
    let doc = ResultDoc {
        id: res_id.clone(),
        formula_id: noid.formula_id,
        engine_version: noid.engine_version,
        created_at: created_at_norm,
        summary: noid.summary,
        units: noid.units,
        label: noid.label,
    };

    // ---- Self-verify (light) ----
    if !doc.id.starts_with("RES:") || &doc.id[4..] != res_sha {
        return Err(BuildResultError::Spec("Result ID does not match canonical bytes".into()));
    }

    Ok((doc, res_sha))
}

/// Convenience: get canonical bytes of a finalized Result (useful for writing/tests).
pub fn result_canonical_bytes(doc: &ResultDoc) -> Result<Vec<u8>, BuildResultError> {
    to_canonical_bytes(doc)
        .map_err(|_| BuildResultError::Spec("canonicalization failed".into()))
}

/// Optional helper to write a finalized Result to disk as canonical JSON (LF).
pub fn write_result(path: &Path, doc: &ResultDoc) -> Result<(), BuildResultError> {
    let bytes = result_canonical_bytes(doc)?;
    let mut f = File::create(path).map_err(|e| BuildResultError::Spec(format!("io: {e}")))?;
    f.write_all(&bytes).map_err(|e| BuildResultError::Spec(format!("io: {e}")))?;
    Ok(())
}

--------------------------------------------------------------------------------
FILE: crates/vm_pipeline/src/build_run_record.rs
--------------------------------------------------------------------------------
// crates/vm_pipeline/src/build_run_record.rs — Half 1/2
//
// Foundations for building the RunRecord and Integrity sections.
// This half is self-contained: types, errors, helpers for canonical IDs,
// and a thin public API surface (the full population happens in Half 2/2).
//
// Spec anchors (Docs 1–7 + Annexes A–C):
// - Result ID (RID) = SHA-256 of the canonical **result.json** payload.
// - Run ID          = SHA-256 of the canonical **run_record.json** payload
//                     (computed after full assembly; see Half 2/2).
// - Formula ID (FID)= SHA-256 of the canonical **Included-only VM-VARs**
//                     normative manifest (Annex A). VM-VAR-052 (tie seed) is
//                     explicitly **Excluded** from FID.
// - Frontier ID     = SHA-256 of the canonical **frontier_map.json** if present.
// - Engine meta is recorded verbatim (vendor/name/version/build).
// - Tie seed (VM-VAR-052) must be **logged** in Integrity, but **excluded** from FID.
//
// Design notes:
// - We canonically hash **JSON values** by recursively sorting object keys,
//   then serializing with `serde_json::to_string` (stable given that order).
//   This avoids pulling vm_io::canonical_json here and keeps this module
//   independent of I/O. Keep the same algorithm everywhere hashing IDs.

use std::fmt;

use crate::EngineMeta;
use serde_json::{Map as JsonMap, Value as Json};

/// Errors while building canonical IDs or assembling the run record.
#[derive(Debug)]
pub enum BuildRecordError {
    Canonicalize(&'static str),
    Hash(&'static str),
    Json(String),
    Unimplemented(&'static str),
}

impl fmt::Display for BuildRecordError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use BuildRecordError::*;
        match self {
            Canonicalize(m) => write!(f, "canonicalization error: {m}"),
            Hash(m) => write!(f, "hash error: {m}"),
            Json(m) => write!(f, "json error: {m}"),
            Unimplemented(m) => write!(f, "not yet implemented: {m}"),
        }
    }
}
impl std::error::Error for BuildRecordError {}

/// Convenience result alias.
pub type BuildResult<T> = Result<T, BuildRecordError>;

/// Integrity block as required by Doc 7.
/// Note: `run_id_hex` is filled in Half 2/2 after the full run_record is assembled.
#[derive(Debug, Clone)]
pub struct IntegrityFields {
    pub result_id_hex: String,
    pub run_id_hex: Option<String>,
    pub formula_id_hex: String,
    pub frontier_id_hex: Option<String>,
    pub engine_vendor: String,
    pub engine_name: String,
    pub engine_version: String,
    pub engine_build: String,
    /// VM-VAR-052 (excluded from FID); logged for determinism provenance.
    pub tie_seed_hex: Option<String>,
}

/// Build IntegrityFields from component documents.
/// - `result_json`     : full result payload (already canonical or canonicalizable)
/// - `nm_included_json`: **Included-only** normative manifest (Annex A)
/// - `frontier_json`   : frontier map payload (if any)
/// - `engine_meta`     : engine identity/version/build
/// - `tie_seed`        : optional seed (VM-VAR-052) to log (not part of FID)
pub fn compute_integrity_fields(
    result_json: &Json,
    nm_included_json: &Json,
    frontier_json: Option<&Json>,
    engine_meta: &EngineMeta,
    tie_seed: Option<u64>,
) -> BuildResult<IntegrityFields> {
    let result_id_hex = sha256_hex_of_canonical_json(result_json)?;
    let formula_id_hex = sha256_hex_of_canonical_json(nm_included_json)?;
    let frontier_id_hex = match frontier_json {
        Some(v) => Some(sha256_hex_of_canonical_json(v)?),
        None => None,
    };
    let tie_seed_hex = tie_seed.map(seed_hex64);

    Ok(IntegrityFields {
        result_id_hex,
        run_id_hex: None, // filled after full run_record is assembled (Half 2/2)
        formula_id_hex,
        frontier_id_hex,
        engine_vendor: engine_meta.vendor.clone(),
        engine_name: engine_meta.name.clone(),
        engine_version: engine_meta.version.clone(),
        engine_build: engine_meta.build.clone(),
        tie_seed_hex,
    })
}

/// Compute the **Run ID** from a fully-assembled run record JSON (Half 2/2 calls this).
pub fn compute_run_id_hex(run_record_json: &Json) -> BuildResult<String> {
    sha256_hex_of_canonical_json(run_record_json)
}

// --------------------------------------------------------------------------------------
// Canonical JSON → SHA-256 helpers (no I/O; stable across platforms)
// --------------------------------------------------------------------------------------

/// Produce a canonicalized clone of `value` with all object keys sorted
/// recursively (arrays preserve order; scalars unchanged).
fn canonicalize_json(value: &Json) -> Json {
    match value {
        Json::Null | Json::Bool(_) | Json::Number(_) | Json::String(_) => value.clone(),
        Json::Array(items) => {
            let canon_items = items.iter().map(canonicalize_json).collect::<Vec<_>>();
            Json::Array(canon_items)
        }
        Json::Object(map) => {
            // Rebuild as a new Object with sorted keys
            let mut keys: Vec<&String> = map.keys().collect();
            keys.sort();
            let mut out = JsonMap::new();
            for k in keys {
                let v = map.get(k).expect("key from keys() must exist");
                out.insert(k.clone(), canonicalize_json(v));
            }
            Json::Object(out)
        }
    }
}

/// Compute lower-case 64-hex SHA-256 of the canonical JSON value.
fn sha256_hex_of_canonical_json(value: &Json) -> BuildResult<String> {
    let canon = canonicalize_json(value);
    let s = serde_json::to_string(&canon).map_err(|_| BuildRecordError::Canonicalize("serialize"))?;
    Ok(sha256_hex(s.as_bytes()))
}

/// Compute lower-case 64-hex SHA-256 of `bytes`.
fn sha256_hex(bytes: &[u8]) -> String {
    use sha2::{Digest, Sha256};
    let mut hasher = Sha256::new();
    hasher.update(bytes);
    let digest = hasher.finalize();
    // hex encode
    let mut out = String::with_capacity(64);
    for b in digest {
        out.push(hex_digit((b >> 4) & 0x0F));
        out.push(hex_digit(b & 0x0F));
    }
    out
}

#[inline]
fn hex_digit(n: u8) -> char {
    const HEX: &[u8; 16] = b"0123456789abcdef";
    HEX[n as usize] as char
}

/// Render VM-VAR-052 as fixed-width 16-hex uppercase (human-facing).
/// Note: We keep IDs (hashes) lower-case; seeds are often shown uppercase.
fn seed_hex64(seed: u64) -> String {
    format!("{seed:016X}")
}

// --------------------------------------------------------------------------------------
// Public API surface (population comes in Half 2/2)
// --------------------------------------------------------------------------------------

/// Build the full run_record JSON (Doc 7) from normalized inputs.
/// This is a **thin entrypoint**; Half 2/2 will implement the population.
/// Returning an error here keeps this file compilable without partial structs.
///
/// Inputs expected (normalized by earlier pipeline stages):
/// - `result_json`      : canonical result payload
/// - `run_inputs_json`  : minimal provenance bundle (paths/digests/timestamps) if you track it
/// - `nm_included_json` : Included-only VM-VARs manifest (Annex A; already normalized)
/// - `frontier_json`    : optional frontier map
/// - `engine_meta`      : engine identity
/// - `tie_seed`         : VM-VAR-052 (logged only; excluded from FID)
/// - `gates_summary`    : optional precomputed gates summary block
#[allow(unused)]
pub fn build_run_record(
    result_json: &Json,
    run_inputs_json: &Json,
    nm_included_json: &Json,
    frontier_json: Option<&Json>,
    engine_meta: &EngineMeta,
    tie_seed: Option<u64>,
    gates_summary: Option<&Json>,
) -> BuildResult<Json> {
    // Half 2/2 will assemble the full structure and then call `compute_run_id_hex`.
    let _ = (result_json, run_inputs_json, nm_included_json, frontier_json, engine_meta, tie_seed, gates_summary);
    Err(BuildRecordError::Unimplemented("Half 2/2 will populate run_record"))
}
// crates/vm_pipeline/src/build_run_record.rs — Half 2/2
//
// Full population of the run_record JSON (Doc 7) using the helpers from Half 1/2.
// - Builds Integrity (result_id/formula_id/frontier_id/engine/tie_seed)
// - Assembles the full run_record body (inputs, included-only manifest, frontier, gates)
// - Computes run_id over the **run_record without the run_id field**, then injects run_id
//   (so the hash is stable and well-defined).

use serde_json::{json, Map as JsonMap, Value as Json};

/// Assemble the complete run_record (Doc 7) with a correct run_id.
///
/// Inputs:
/// - `result_json`      : canonical result payload
/// - `run_inputs_json`  : provenance bundle (paths/digests/timestamps) if tracked
/// - `nm_included_json` : Included-only VM-VAR manifest (Annex A; already normalized)
/// - `frontier_json`    : optional frontier map
/// - `engine_meta`      : engine identity
/// - `tie_seed`         : VM-VAR-052 (logged only; excluded from FID)
/// - `gates_summary`    : optional summary block
///
/// Output:
/// - Fully assembled JSON with:
///     { integrity: {...}, inputs: {...}, nm_included: {...}, frontier_map?: {...}, gates_summary?: {...} }
pub fn build_run_record(
    result_json: &Json,
    run_inputs_json: &Json,
    nm_included_json: &Json,
    frontier_json: Option<&Json>,
    engine_meta: &crate::EngineMeta,
    tie_seed: Option<u64>,
    gates_summary: Option<&Json>,
) -> crate::build_run_record::BuildResult<Json> {
    // 1) Integrity (without run_id for now)
    let integ = super::compute_integrity_fields(
        result_json,
        nm_included_json,
        frontier_json,
        engine_meta,
        tie_seed,
    )?;

    // 2) Build run_record **without** run_id (this is what we hash to get run_id)
    let run_record_wo_run_id = assemble_run_record_json(&integ, false, run_inputs_json, nm_included_json, frontier_json, gates_summary)?;

    // 3) Compute run_id over the canonicalized run_record without run_id
    let run_id_hex = super::compute_run_id_hex(&run_record_wo_run_id)?;

    // 4) Rebuild integrity **with** run_id, then assemble the final run_record
    let run_record = {
        // clone the integrity with run_id set
        let integ_with_run = IntegrityJson {
            result_id_hex: integ.result_id_hex.clone(),
            run_id_hex: Some(run_id_hex),
            formula_id_hex: integ.formula_id_hex.clone(),
            frontier_id_hex: integ.frontier_id_hex.clone(),
            engine_vendor: integ.engine_vendor.clone(),
            engine_name: integ.engine_name.clone(),
            engine_version: integ.engine_version.clone(),
            engine_build: integ.engine_build.clone(),
            tie_seed_hex: integ.tie_seed_hex.clone(),
        };
        assemble_run_record_json_raw(&integ_with_run, run_inputs_json, nm_included_json, frontier_json, gates_summary)
    };

    Ok(run_record)
}

// ------------------- internal helpers -------------------

/// Mirror of IntegrityFields for JSON emission with control over including run_id.
#[derive(Debug, Clone)]
struct IntegrityJson {
    result_id_hex: String,
    run_id_hex: Option<String>,
    formula_id_hex: String,
    frontier_id_hex: Option<String>,
    engine_vendor: String,
    engine_name: String,
    engine_version: String,
    engine_build: String,
    tie_seed_hex: Option<String>,
}

/// Assemble run_record object with a choice to include or omit run_id in integrity.
fn assemble_run_record_json(
    integ: &super::IntegrityFields,
    include_run_id: bool,
    run_inputs_json: &Json,
    nm_included_json: &Json,
    frontier_json: Option<&Json>,
    gates_summary: Option<&Json>,
) -> crate::build_run_record::BuildResult<Json> {
    let tmp = IntegrityJson {
        result_id_hex: integ.result_id_hex.clone(),
        run_id_hex: if include_run_id { integ.run_id_hex.clone() } else { None },
        formula_id_hex: integ.formula_id_hex.clone(),
        frontier_id_hex: integ.frontier_id_hex.clone(),
        engine_vendor: integ.engine_vendor.clone(),
        engine_name: integ.engine_name.clone(),
        engine_version: integ.engine_version.clone(),
        engine_build: integ.engine_build.clone(),
        tie_seed_hex: integ.tie_seed_hex.clone(),
    };
    Ok(assemble_run_record_json_raw(
        &tmp,
        run_inputs_json,
        nm_included_json,
        frontier_json,
        gates_summary,
    ))
}

/// Build the final JSON object from parts (caller decides whether `run_id` is present).
fn assemble_run_record_json_raw(
    integ: &IntegrityJson,
    run_inputs_json: &Json,
    nm_included_json: &Json,
    frontier_json: Option<&Json>,
    gates_summary: Option<&Json>,
) -> Json {
    // integrity
    let mut integrity = JsonMap::new();
    integrity.insert("result_id".to_string(), Json::String(integ.result_id_hex.clone()));
    if let Some(run) = &integ.run_id_hex {
        integrity.insert("run_id".to_string(), Json::String(run.clone()));
    }
    integrity.insert("formula_id_hex".to_string(), Json::String(integ.formula_id_hex.clone()));
    if let Some(fr) = &integ.frontier_id_hex {
        integrity.insert("frontier_id".to_string(), Json::String(fr.clone()));
    }
    integrity.insert("engine_vendor".to_string(), Json::String(integ.engine_vendor.clone()));
    integrity.insert("engine_name".to_string(), Json::String(integ.engine_name.clone()));
    integrity.insert("engine_version".to_string(), Json::String(integ.engine_version.clone()));
    integrity.insert("engine_build".to_string(), Json::String(integ.engine_build.clone()));
    if let Some(seed) = &integ.tie_seed_hex {
        integrity.insert("tie_seed".to_string(), Json::String(seed.clone()));
    }

    // root object
    let mut root = JsonMap::new();
    root.insert("integrity".to_string(), Json::Object(integrity));
    root.insert("inputs".to_string(), run_inputs_json.clone());
    // embed Included-only manifest for audit (Annex A)
    root.insert("nm_included".to_string(), nm_included_json.clone());
    if let Some(fr) = frontier_json {
        root.insert("frontier_map".to_string(), fr.clone());
    }
    if let Some(gs) = gates_summary {
        root.insert("gates_summary".to_string(), gs.clone());
    }

    Json::Object(root)
}

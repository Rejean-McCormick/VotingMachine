# bundle: vm_algo

--------------------------------------------------------------------------------
FILE: crates/vm_algo/Cargo.toml
--------------------------------------------------------------------------------
[package]
name = "vm_algo"
version = "0.1.0"
edition = "2021"
rust-version = "1.77"
license = "Apache-2.0 OR MIT"
description = "Algorithm layer: tabulation, seat allocation, gates/frontier; depends only on vm_core."
# repository = "..."; readme = "README.md"

[lib]
name = "vm_algo"
path = "src/lib.rs"
crate-type = ["rlib"]

[features]
# Keep this crate algorithmic-only; features gate families without changing public types.
default     = ["std", "tab_ranked", "tab_score", "pr_methods", "mmp", "gates", "frontier"]
std         = []
tab_ranked  = []
tab_score   = []
pr_methods  = []
mmp         = []
gates       = []
frontier    = []

[dependencies]
vm_core = { path = "../vm_core" }  # RNG and rounding come from vm_core

[dev-dependencies]
proptest    = "1"      # property tests
rand_chacha = "0.3"    # tests only; runtime RNG is vm_core::rng

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/lib.rs
--------------------------------------------------------------------------------
//! crates/vm_algo/src/lib.rs
//! Public surface for pure algorithm primitives (tabulation, allocation, gates/frontier).
//! No I/O, no JSON; deterministic ordering; RNG only for ties per 050/052.
//!
//! Ordering rules (normative reminders):
//! - Units iterate by ascending `unit_id`; options by `(order_index, option_id)`; allocations mirror registry order. :contentReference[oaicite:4]{index=4}
//! - RNG is used only for random tie policy (050) and seeded from 052 by the pipeline. :contentReference[oaicite:5]{index=5}

#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

use alloc::collections::BTreeMap;
use alloc::vec::Vec;

pub use vm_core::{
    ids::{OptionId, UnitId},
    rng::TieRng,
    // For API clarity, alias vm_core's TallyTotals as Turnout here.
    entities::TallyTotals as Turnout,
    // Ratio type (integer rational compare/formatting) lives in vm_core.
    rounding::Ratio,
    // Variable enums (tie policy, allocation method, etc.) are defined in vm_core::variables.
    variables::{AllocationMethod, OverhangPolicy, TiePolicy, TotalSeatsModel},
    // Registry option metadata (order_index) used for canonical ordering.
    entities::OptionItem,
};

/// Raw scores per unit, ready for allocation/aggregation.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct UnitScores {
    pub unit_id: UnitId,
    pub turnout: Turnout,                 // valid/invalid/total ballots
    pub scores: BTreeMap<OptionId, u64>,  // plurality=votes; approval=approvals; score=score sums
}

/// Per-unit allocation result; deterministic ordering by (order_index, OptionId).
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Allocation {
    pub unit_id: UnitId,
    /// For PR methods: seats per option. For WTA single-member: winner may be represented as 1 seat
    /// (pipeline interprets accordingly). Ordering mirrors registry option order. :contentReference[oaicite:6]{index=6}
    pub seats_or_power: BTreeMap<OptionId, u32>,
    /// True iff a tie policy decided a last seat / winner. (Pipeline logs tie details.) :contentReference[oaicite:7]{index=7}
    pub last_seat_tie: bool,
}

/// IRV round transfer/audit data (minimal, engine-agnostic).
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct IrvRound {
    pub eliminated: OptionId,
    pub transfers: BTreeMap<OptionId, u64>,
    pub exhausted: u64,
}

/// IRV log across rounds.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct IrvLog {
    pub rounds: Vec<IrvRound>,
    pub winner: OptionId,
}

/// Pairwise wins map for Condorcet completions.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Pairwise {
    /// (A,B) = votes preferring A over B.
    pub wins: BTreeMap<(OptionId, OptionId), u64>,
}

/// Gate outcome (ratios are integer rationals; no floats).
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct GateOutcome {
    pub pass: bool,
    pub observed: Ratio,
    pub threshold_pct: u8,
}

/// Double-majority composition (e.g., national + regional).
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct DoubleMajority {
    pub national: GateOutcome,
    pub regional: GateOutcome,
    pub pass: bool,
}

// ---- Module layout (stubs). Implementations live in sibling modules. ---------------------------
// The pipeline calls these in the step order defined in Doc 4A/5A; tests conform to Doc 6A–6C.
// (We provide function signatures here with `unimplemented!()` to make the public API explicit.)

/// Tabulation primitives (plurality/approval/score, IRV, Condorcet).
pub mod tabulation {
    use super::*;

    /// Plurality: raw vote counts per option for a unit.
    pub fn tabulate_plurality(
        unit_id: UnitId,
        votes: &BTreeMap<OptionId, u64>,
        turnout: Turnout,
    ) -> UnitScores {
        let _ = (unit_id, votes, turnout);
        unimplemented!("tabulate_plurality (4A S1)"); // :contentReference[oaicite:8]{index=8}
    }

    /// Approval: approvals per option; denominator for shares is valid_ballots. :contentReference[oaicite:9]{index=9}
    pub fn tabulate_approval(
        unit_id: UnitId,
        approvals: &BTreeMap<OptionId, u64>,
        turnout: Turnout,
    ) -> UnitScores {
        let _ = (unit_id, approvals, turnout);
        unimplemented!("tabulate_approval (4A S1)");
    }

    /// Score: sums of scores per option. Scale domain validated upstream; integer-only here. :contentReference[oaicite:10]{index=10}
    pub fn tabulate_score(
        unit_id: UnitId,
        score_sums: &BTreeMap<OptionId, u64>,
        turnout: Turnout,
    ) -> UnitScores {
        let _ = (unit_id, score_sums, turnout);
        unimplemented!("tabulate_score (4A S1)");
    }

    /// IRV on compressed ranked ballots; fixed exhaustion policy per spec; deterministic ties via 050/052. :contentReference[oaicite:11]{index=11}
    pub fn tabulate_ranked_irv(
        ballots: &[(Vec<OptionId>, u64)],   // unique options per ranking; multiplicity
        options: &[OptionItem],             // ordered by (order_index, id)
    ) -> (UnitScores, IrvLog) {
        let _ = (ballots, options);
        unimplemented!("tabulate_ranked_irv (4A S1 + 4C ties)");
    }

    /// Condorcet: pairwise tallies + completion; deterministic ordering. :contentReference[oaicite:12]{index=12}
    pub fn tabulate_ranked_condorcet(
        ballots: &[(Vec<OptionId>, u64)],
        options: &[OptionItem],
    ) -> (UnitScores, Pairwise) {
        let _ = (ballots, options);
        unimplemented!("tabulate_ranked_condorcet (4A S1)");
    }
}

/// Allocation methods within a unit (WTA, divisors, largest remainder).
pub mod allocation {
    use super::*;

    /// Winner-take-all for single-member magnitude. Ties via policy 050; RNG only if Random (052). :contentReference[oaicite:13]{index=13}
    pub fn allocate_wta(
        scores: &UnitScores,
        magnitude: u32,
        options: &[OptionItem],
        tie_policy: TiePolicy,
        mut rng: Option<&mut TieRng>,
    ) -> Allocation {
        let _ = (scores, magnitude, options, tie_policy, &mut rng);
        unimplemented!("allocate_wta (4A S4 + 4C ties)");
    }

    /// D’Hondt (Jefferson). Deterministic order per registry options. :contentReference[oaicite:14]{index=14}
    pub fn allocate_dhondt(
        seats: u32,
        scores: &BTreeMap<OptionId, u64>,
        options: &[OptionItem],
    ) -> BTreeMap<OptionId, u32> {
        let _ = (seats, scores, options);
        unimplemented!("allocate_dhondt (4A S4)");
    }

    /// Sainte-Laguë (Webster). Deterministic order per registry options. :contentReference[oaicite:15]{index=15}
    pub fn allocate_sainte_lague(
        seats: u32,
        scores: &BTreeMap<OptionId, u64>,
        options: &[OptionItem],
    ) -> BTreeMap<OptionId, u32> {
        let _ = (seats, scores, options);
        unimplemented!("allocate_sainte_lague (4A S4)");
    }

    /// Largest Remainder with threshold (% of valid ballots before quota). :contentReference[oaicite:16]{index=16}
    pub fn allocate_largest_remainder(
        seats: u32,
        scores: &BTreeMap<OptionId, u64>,
        threshold_pct: u8,
        options: &[OptionItem],
    ) -> BTreeMap<OptionId, u32> {
        let _ = (seats, scores, threshold_pct, options);
        unimplemented!("allocate_largest_remainder (4A S4)");
    }
}

/// Mixed-member proportional helpers (targets & top-ups).
pub mod mmp {
    use super::*;

    /// Compute per-option seat targets from vote totals using a PR method baseline. :contentReference[oaicite:17]{index=17}
    pub fn mmp_target_shares(
        total_seats: u32,
        vote_totals: &BTreeMap<OptionId, u64>,
        method: AllocationMethod,
    ) -> BTreeMap<OptionId, u32> {
        let _ = (total_seats, vote_totals, method);
        unimplemented!("mmp_target_shares");
    }

    /// Compute top-ups given local seats and targets; policies control overhang & total seats. :contentReference[oaicite:18]{index=18}
    pub fn mmp_topups(
        local_seats: &BTreeMap<OptionId, u32>,
        targets: &BTreeMap<OptionId, u32>,
        overhang_policy: OverhangPolicy,
        total_seats_model: TotalSeatsModel,
    ) -> BTreeMap<OptionId, u32> {
        let _ = (local_seats, targets, overhang_policy, total_seats_model);
        unimplemented!("mmp_topups");
    }
}

/// Gates & frontier helpers (integer ratio math; no floats).
pub mod gates_frontier {
    use super::*;

    /// Quorum: observed = valid_ballots / eligible_roll; rational compare against threshold. :contentReference[oaicite:19]{index=19}
    pub fn gate_quorum(valid_ballots: u64, eligible_roll: u64, threshold_pct: u8) -> GateOutcome {
        let _ = (valid_ballots, eligible_roll, threshold_pct);
        unimplemented!("gate_quorum (4B)");
    }

    /// Majority: observed = approvals_for_change / valid_ballots (denominator is valid ballots). :contentReference[oaicite:20]{index=20}
    pub fn gate_majority(
        valid_ballots: u64,
        approvals_for_change: u64,
        threshold_pct: u8,
    ) -> GateOutcome {
        let _ = (valid_ballots, approvals_for_change, threshold_pct);
        unimplemented!("gate_majority (4B)");
    }

    /// Double-majority composition (national + regional). :contentReference[oaicite:21]{index=21}
    pub fn gate_double_majority(national: GateOutcome, regional: GateOutcome) -> DoubleMajority {
        let _ = (national, regional);
        unimplemented!("gate_double_majority (4B)");
    }

    /// Frontier support ratio helper (approval rate), used by frontier diagnostics. :contentReference[oaicite:22]{index=22}
    pub fn frontier_support_ratio(approvals_for_change: u64, valid_ballots: u64) -> Ratio {
        let _ = (approvals_for_change, valid_ballots);
        unimplemented!("frontier_support_ratio (4C)");
    }
}

// Re-exports for ergonomic use by pipeline/tests.
pub use allocation::*;
pub use gates_frontier::*;
pub use tabulation::*;
pub use mmp::*;

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/tabulation/plurality.rs
--------------------------------------------------------------------------------
//! Plurality tabulation (deterministic, integers-only).
//!
//! Inputs:
//! - `unit_id`: the unit identifier
//! - `votes`:   per-option vote counts (may omit options → treated as 0)
//! - `turnout`: valid/invalid ballots summary
//! - `options`: canonical option list ordered by (order_index, OptionId)
//!
//! Output:
//! - `UnitScores { unit_id, turnout, scores }` where `scores` is a `BTreeMap<OptionId, u64>`.
//!
//! Notes:
//! - Unknown option keys present in `votes` are rejected.
//! - Σ(option votes) must be ≤ `turnout.valid_ballots`.
//! - No RNG, no floats. Downstream should iterate results using the provided
//!   canonical `options` slice to preserve on-wire order.

use std::collections::{BTreeMap, BTreeSet};

use vm_core::{
    entities::{OptionItem, TallyTotals},
    ids::{OptionId, UnitId},
};

use crate::UnitScores;

/// Tabulation errors for plurality counting.
#[derive(Debug)]
pub enum TabError {
    /// `votes` contained an option ID not present in the canonical `options` list.
    UnknownOption(OptionId),
    /// Sum of per-option votes exceeded the unit's `valid_ballots`.
    TallyExceedsValid { sum_votes: u64, valid_ballots: u64 },
}

/// Deterministic plurality tabulation (integers only; no RNG).
pub fn tabulate_plurality(
    unit_id: UnitId,
    votes: &BTreeMap<OptionId, u64>,
    turnout: TallyTotals,
    options: &[OptionItem],
) -> Result<UnitScores, TabError> {
    let (scores, sum) = canonicalize_scores(votes, options)?;
    check_tally_sanity(sum, &turnout)?;
    Ok(UnitScores {
        unit_id,
        turnout,
        scores,
    })
}

/// Build a canonical score map from provided `votes` and canonical `options`.
/// Iterates `options` in (order_index, OptionId) order; missing keys → 0;
/// rejects unknown keys present in `votes`.
fn canonicalize_scores(
    votes: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
) -> Result<(BTreeMap<OptionId, u64>, u64), TabError> {
    // Fast membership set for unknown-key detection.
    let allowed: BTreeSet<&OptionId> = options.iter().map(|o| &o.option_id).collect();

    // Reject any vote keyed by an unknown option.
    if let Some((bad_id, _)) = votes.iter().find(|(k, _)| !allowed.contains(k)) {
        return Err(TabError::UnknownOption((*bad_id).clone()));
    }

    // Build scores by traversing options in canonical order.
    let mut scores: BTreeMap<OptionId, u64> = BTreeMap::new();
    let mut sum: u64 = 0;

    for opt in options {
        let count = votes.get(&opt.option_id).copied().unwrap_or(0);

        // Detect improbable u64 overflow early and treat as exceeds-valid.
        let (new_sum, overflow) = sum.overflowing_add(count);
        if overflow {
            return Err(TabError::TallyExceedsValid {
                sum_votes: u64::MAX,
                valid_ballots: 0, // will be overwritten by caller-side sanity; set 0 here defensively
            });
        }
        sum = new_sum;

        scores.insert(opt.option_id.clone(), count);
    }

    Ok((scores, sum))
}

/// Sanity: Σ option votes must not exceed `valid_ballots`.
fn check_tally_sanity(sum_votes: u64, turnout: &TallyTotals) -> Result<(), TabError> {
    let valid = turnout.valid_ballots;
    if sum_votes > valid {
        return Err(TabError::TallyExceedsValid {
            sum_votes,
            valid_ballots: valid,
        });
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use vm_core::entities::OptionItem;

    fn opt(id: &str, idx: u16) -> OptionItem {
        OptionItem::new(
            id.parse().expect("opt id"),
            "name".to_string(),
            idx,
        )
        .expect("option")
    }

    #[test]
    fn happy_path_builds_scores_in_canonical_order() {
        // Options in canonical order by (order_index, option_id)
        let options = vec![opt("O-A", 0), opt("O-B", 1), opt("O-C", 2)];

        // Votes map insertion order is irrelevant.
        let mut votes = BTreeMap::<OptionId, u64>::new();
        votes.insert("O-B".parse().unwrap(), 20);
        votes.insert("O-A".parse().unwrap(), 10);
        votes.insert("O-C".parse().unwrap(), 30);

        let turnout = TallyTotals::new(60, 0);

        let (scores, sum) = canonicalize_scores(&votes, &options).expect("ok");
        assert_eq!(sum, 60);

        // Iteration over BTreeMap is lex by OptionId; downstream will iterate via `options`.
        assert_eq!(scores.get(&"O-A".parse().unwrap()).copied(), Some(10));
        assert_eq!(scores.get(&"O-B".parse().unwrap()).copied(), Some(20));
        assert_eq!(scores.get(&"O-C".parse().unwrap()).copied(), Some(30));

        // Full tabulate
        let unit_id: UnitId = "U-001".parse().unwrap();
        let us = tabulate_plurality(unit_id, &votes, turnout, &options).expect("ok");
        assert_eq!(us.turnout.valid_ballots, 60);
    }

    #[test]
    fn missing_keys_are_zero_unknown_are_error() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut votes = BTreeMap::<OptionId, u64>::new();
        votes.insert("O-A".parse().unwrap(), 5);
        votes.insert("O-X".parse().unwrap(), 1); // unknown

        let err = canonicalize_scores(&votes, &options).unwrap_err();
        match err {
            TabError::UnknownOption(id) => assert_eq!(id.to_string(), "O-X"),
            _ => panic!("expected UnknownOption"),
        }
    }

    #[test]
    fn sanity_sum_must_not_exceed_valid() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut votes = BTreeMap::<OptionId, u64>::new();
        votes.insert("O-A".parse().unwrap(), 50);
        votes.insert("O-B".parse().unwrap(), 51);

        let turnout = TallyTotals::new(100, 0);
        let (scores, sum) = canonicalize_scores(&votes, &options).expect("ok");
        assert_eq!(sum, 101);

        let err = check_tally_sanity(sum, &turnout).unwrap_err();
        match err {
            TabError::TallyExceedsValid { sum_votes, valid_ballots } => {
                assert_eq!(sum_votes, 101);
                assert_eq!(valid_ballots, 100);
            }
            _ => panic!("expected TallyExceedsValid"),
        }
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/tabulation/approval.rs
--------------------------------------------------------------------------------
//! Approval tabulation (deterministic, integers-only).
//!
//! Inputs:
//! - `unit_id`: the unit identifier
//! - `approvals`: per-option approval counts (may omit options → treated as 0)
//! - `turnout`: per-unit totals { valid_ballots, invalid_ballots } (Doc 1B names)
//! - `options`: canonical option list ordered by (order_index, OptionId)
//!
////! Output:
//! - `UnitScores { unit_id, turnout, scores }` where `scores` is a `BTreeMap<OptionId, u64>`.
//!
//! Notes:
//! - Unknown option keys present in `approvals` are rejected.
//! - Per-option cap: approvals_for_option ≤ valid_ballots.
//! - Σ approvals may exceed valid_ballots (multiple approvals per ballot are allowed).
//! - No RNG, no floats. Downstream should iterate results using the provided
//!   canonical `options` slice to preserve on-wire order.

use std::collections::{BTreeMap, BTreeSet};

use vm_core::{
    entities::{OptionItem, TallyTotals},
    ids::{OptionId, UnitId},
};

use crate::UnitScores;

/// Tabulation errors for approval counting.
#[derive(Debug)]
pub enum TabError {
    /// `approvals` contained an option ID not present in the canonical `options` list.
    UnknownOption(OptionId),
    /// A single option's approvals exceeded the unit's `valid_ballots`.
    OptionExceedsValid {
        option: OptionId,
        approvals: u64,
        valid_ballots: u64,
    },
}

/// Deterministic approval tabulation (integers only; no RNG).
pub fn tabulate_approval(
    unit_id: UnitId,
    approvals: &BTreeMap<OptionId, u64>,
    turnout: TallyTotals,
    options: &[OptionItem],
) -> Result<UnitScores, TabError> {
    let scores = canonicalize_scores(approvals, options)?;
    check_per_option_caps(&scores, &turnout)?;
    Ok(UnitScores {
        unit_id,
        turnout,
        scores,
    })
}

/// Build a canonical score map from provided `approvals` and canonical `options`.
/// Iterates `options` in (order_index, OptionId) order; missing keys → 0;
/// rejects unknown keys present in `approvals`.
fn canonicalize_scores(
    approvals: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
) -> Result<BTreeMap<OptionId, u64>, TabError> {
    // Fast membership set for unknown-key detection.
    let allowed: BTreeSet<&OptionId> = options.iter().map(|o| &o.option_id).collect();

    // Reject any approval keyed by an unknown option.
    if let Some((bad_id, _)) = approvals.iter().find(|(k, _)| !allowed.contains(k)) {
        return Err(TabError::UnknownOption((*bad_id).clone()));
    }

    // Build scores by traversing options in canonical order.
    let mut scores: BTreeMap<OptionId, u64> = BTreeMap::new();
    for opt in options {
        let count = approvals.get(&opt.option_id).copied().unwrap_or(0);
        scores.insert(opt.option_id.clone(), count);
    }
    Ok(scores)
}

/// Sanity: per-option approvals must not exceed `valid_ballots`.
fn check_per_option_caps(
    scores: &BTreeMap<OptionId, u64>,
    turnout: &TallyTotals,
) -> Result<(), TabError> {
    let valid = turnout.valid_ballots;
    for (opt, &count) in scores {
        if count > valid {
            return Err(TabError::OptionExceedsValid {
                option: opt.clone(),
                approvals: count,
                valid_ballots: valid,
            });
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use vm_core::entities::OptionItem;

    fn opt(id: &str, idx: u16) -> OptionItem {
        OptionItem::new(
            id.parse().expect("opt id"),
            "name".to_string(),
            idx,
        )
        .expect("option")
    }

    #[test]
    fn happy_path_builds_scores_in_canonical_order() {
        let options = vec![opt("O-A", 0), opt("O-B", 1), opt("O-C", 2)];

        // Insertion order of approvals map is irrelevant.
        let mut approvals = BTreeMap::<OptionId, u64>::new();
        approvals.insert("O-B".parse().unwrap(), 20);
        approvals.insert("O-A".parse().unwrap(), 10);
        approvals.insert("O-C".parse().unwrap(), 40);

        let turnout = TallyTotals::new(100, 0);

        let scores = canonicalize_scores(&approvals, &options).expect("ok");
        assert_eq!(scores.get(&"O-A".parse().unwrap()).copied(), Some(10));
        assert_eq!(scores.get(&"O-B".parse().unwrap()).copied(), Some(20));
        assert_eq!(scores.get(&"O-C".parse().unwrap()).copied(), Some(40));

        // Full tabulate
        let unit_id: UnitId = "U-001".parse().unwrap();
        let us = tabulate_approval(unit_id, &approvals, turnout, &options).expect("ok");
        assert_eq!(us.turnout.valid_ballots, 100);
    }

    #[test]
    fn unknown_option_rejected() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut approvals = BTreeMap::<OptionId, u64>::new();
        approvals.insert("O-A".parse().unwrap(), 5);
        approvals.insert("O-X".parse().unwrap(), 1); // unknown

        let err = canonicalize_scores(&approvals, &options).unwrap_err();
        match err {
            TabError::UnknownOption(id) => assert_eq!(id.to_string(), "O-X"),
            _ => panic!("expected UnknownOption"),
        }
    }

    #[test]
    fn per_option_caps_enforced() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut approvals = BTreeMap::<OptionId, u64>::new();
        approvals.insert("O-A".parse().unwrap(), 51);
        approvals.insert("O-B".parse().unwrap(), 50);

        let turnout = TallyTotals::new(50, 0);

        let scores = canonicalize_scores(&approvals, &options).expect("ok");
        let err = check_per_option_caps(&scores, &turnout).unwrap_err();
        match err {
            TabError::OptionExceedsValid {
                option,
                approvals,
                valid_ballots,
            } => {
                assert_eq!(option.to_string(), "O-A");
                assert_eq!(approvals, 51);
                assert_eq!(valid_ballots, 50);
            }
            _ => panic!("expected OptionExceedsValid"),
        }
    }

    #[test]
    fn zero_valid_ballots_forces_zeros() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut approvals = BTreeMap::<OptionId, u64>::new();
        approvals.insert("O-A".parse().unwrap(), 0);
        approvals.insert("O-B".parse().unwrap(), 0);

        let turnout = TallyTotals::new(0, 0);
        let scores = canonicalize_scores(&approvals, &options).expect("ok");
        check_per_option_caps(&scores, &turnout).expect("ok");
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/tabulation/score.rs
--------------------------------------------------------------------------------
//! Score tabulation (deterministic, integers-only).
//!
//! Inputs:
//! - `unit_id`: the unit identifier
//! - `score_sums`: per-option **summed scores** (already aggregated upstream)
//! - `turnout`: per-unit totals { valid_ballots, invalid_ballots } (Doc 1B names)
//! - `params`: typed parameter set (used for scale/normalization if defined per release)
//! - `options`: canonical option list ordered by (order_index, OptionId)
//!
//! Output:
//! - `UnitScores { unit_id, turnout, scores }` where `scores` is a `BTreeMap<OptionId, u64>`.
//!
//! Rules/enforcement in this layer (domain-only):
//! - Unknown option keys present in `score_sums` are rejected.
//! - If `valid_ballots == 0`: all option sums must be 0 → otherwise error.
//! - If a max per-ballot score is available from Params, enforce per-option cap
//!   `sum_for_option <= valid_ballots * max_scale` (widened arithmetic).
//!
//! No RNG, no floats. Downstream should iterate results using the provided
//! canonical `options` slice to preserve on-wire order.

use std::collections::{BTreeMap, BTreeSet};

use vm_core::{
    entities::{OptionItem, TallyTotals},
    ids::{OptionId, UnitId},
    variables::Params,
};

use crate::UnitScores;

/// Tabulation errors for score counting.
#[derive(Debug)]
pub enum TabError {
    /// `score_sums` contained an option ID not present in the canonical `options` list.
    UnknownOption(OptionId),
    /// Turnout says there are zero valid ballots but some option has a non-zero sum.
    InconsistentTurnout { non_zero_total: u64 },
    /// A single option's summed score exceeded the plausible cap: `valid_ballots * max_scale`.
    OptionExceedsCap {
        option: OptionId,
        sum: u64,
        cap: u128,
    },
    /// (Reserved) Invalid scale bounds in parameters, if enforced per release.
    InvalidScaleBounds,
}

/// Deterministic score tabulation (integers only; no RNG).
pub fn tabulate_score(
    unit_id: UnitId,
    score_sums: &BTreeMap<OptionId, u64>,
    turnout: TallyTotals,
    params: &Params,
    options: &[OptionItem],
) -> Result<UnitScores, TabError> {
    let scores = canonicalize_scores(score_sums, options)?;
    check_scale_and_caps(&scores, &turnout, params)?;
    Ok(UnitScores {
        unit_id,
        turnout,
        scores,
    })
}

/// Build a canonical score map from provided `score_sums` and canonical `options`.
/// Iterates `options` in (order_index, OptionId) order; missing keys → 0;
/// rejects unknown keys present in `score_sums`.
fn canonicalize_scores(
    score_sums: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
) -> Result<BTreeMap<OptionId, u64>, TabError> {
    // Fast membership set for unknown-key detection.
    let allowed: BTreeSet<&OptionId> = options.iter().map(|o| &o.option_id).collect();

    // Reject any score keyed by an unknown option.
    if let Some((bad_id, _)) = score_sums.iter().find(|(k, _)| !allowed.contains(k)) {
        return Err(TabError::UnknownOption((*bad_id).clone()));
    }

    // Build scores by traversing options in canonical order.
    let mut scores: BTreeMap<OptionId, u64> = BTreeMap::new();
    for opt in options {
        let sum = score_sums.get(&opt.option_id).copied().unwrap_or(0);
        scores.insert(opt.option_id.clone(), sum);
    }
    Ok(scores)
}

/// Domain checks:
/// * If valid_ballots == 0 ⇒ all sums must be 0.
/// * If a max per-ballot score is available in Params (per release), enforce
///   sum_for_option <= valid_ballots * max_scale using widened arithmetic.
fn check_scale_and_caps(
    scores: &BTreeMap<OptionId, u64>,
    turnout: &TallyTotals,
    params: &Params,
) -> Result<(), TabError> {
    let v = turnout.valid_ballots;

    if v == 0 {
        // All sums must be zero in a zero-valid-ballots unit.
        let non_zero_total: u64 = scores.values().copied().sum();
        if non_zero_total != 0 {
            return Err(TabError::InconsistentTurnout { non_zero_total });
        }
        return Ok(()); // nothing else to check
    }

    // Try to extract a per-ballot max scale from Params (per release).
    // NOTE: The core ParameterSet in this repository does not define a generic
    // score scale. If your release does, wire it into this extractor.
    if let Some(max_scale) = extract_max_scale(params) {
        let cap_per_option: u128 = (v as u128) * (max_scale as u128);
        for (opt, &sum) in scores {
            if (sum as u128) > cap_per_option {
                return Err(TabError::OptionExceedsCap {
                    option: opt.clone(),
                    sum,
                    cap: cap_per_option,
                });
            }
        }
    }

    Ok(())
}

/// Attempt to extract a per-ballot max score from Params.
/// Returns `None` if the current release does not expose such a variable
/// in the ParameterSet (common in canonical inputs where score scales are
/// part of ingestion rather than runtime params).
fn extract_max_scale(_params: &Params) -> Option<u64> {
    // Placeholder: wire to a real field if/when defined per release.
    None
}

#[cfg(test)]
mod tests {
    use super::*;
    use vm_core::entities::OptionItem;

    fn opt(id: &str, idx: u16) -> OptionItem {
        OptionItem::new(
            id.parse().expect("opt id"),
            "name".to_string(),
            idx,
        )
        .expect("option")
    }

    #[test]
    fn happy_path_builds_scores_in_canonical_order() {
        let options = vec![opt("O-A", 0), opt("O-B", 1), opt("O-C", 2)];

        // Insertion order of map is irrelevant.
        let mut sums = BTreeMap::<OptionId, u64>::new();
        sums.insert("O-B".parse().unwrap(), 200);
        sums.insert("O-A".parse().unwrap(), 100);
        sums.insert("O-C".parse().unwrap(), 400);

        let turnout = TallyTotals::new(100, 0);
        let params = Params::default();

        let scores = canonicalize_scores(&sums, &options).expect("ok");
        assert_eq!(scores.get(&"O-A".parse().unwrap()).copied(), Some(100));
        assert_eq!(scores.get(&"O-B".parse().unwrap()).copied(), Some(200));
        assert_eq!(scores.get(&"O-C".parse().unwrap()).copied(), Some(400));

        // Full tabulate
        let unit_id: UnitId = "U-001".parse().unwrap();
        let us = tabulate_score(unit_id, &sums, turnout, &params, &options).expect("ok");
        assert_eq!(us.turnout.valid_ballots, 100);
    }

    #[test]
    fn unknown_option_rejected() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut sums = BTreeMap::<OptionId, u64>::new();
        sums.insert("O-A".parse().unwrap(), 5);
        sums.insert("O-X".parse().unwrap(), 1); // unknown

        let err = canonicalize_scores(&sums, &options).unwrap_err();
        match err {
            TabError::UnknownOption(id) => assert_eq!(id.to_string(), "O-X"),
            _ => panic!("expected UnknownOption"),
        }
    }

    #[test]
    fn zero_valid_ballots_requires_all_zero_sums() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut sums = BTreeMap::<OptionId, u64>::new();
        sums.insert("O-A".parse().unwrap(), 0);
        sums.insert("O-B".parse().unwrap(), 0);

        let turnout = TallyTotals::new(0, 0);
        let params = Params::default();

        tabulate_score("U-1".parse().unwrap(), &sums, turnout, &params, &options).expect("ok");
    }

    #[test]
    fn zero_valid_ballots_with_non_zero_fails() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut sums = BTreeMap::<OptionId, u64>::new();
        sums.insert("O-A".parse().unwrap(), 1);
        sums.insert("O-B".parse().unwrap(), 0);

        let turnout = TallyTotals::new(0, 0);
        let params = Params::default();

        let err = tabulate_score("U-1".parse().unwrap(), &sums, turnout, &params, &options)
            .unwrap_err();
        match err {
            TabError::InconsistentTurnout { non_zero_total } => {
                assert_eq!(non_zero_total, 1);
            }
            _ => panic!("expected InconsistentTurnout"),
        }
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/tabulation/ranked_irv.rs
--------------------------------------------------------------------------------
//! IRV tabulation (deterministic, integers-only, no RNG).
//!
//! Contract (aligned with Doc 1B & engine rules):
//! - Inputs are compressed ballot groups: (ranking, multiplicity).
//! - Options are provided in canonical order: (order_index, option_id).
//! - Majority test is against the **continuing denominator** (reduce-on-exhaustion).
//! - Elimination tie-break is deterministic by canonical option order.
//! - We recompute tallies from scratch each round given the current continuing set
//!   (pure, simple, and deterministic), and separately log transfers/exhausted for
//!   the eliminated option in that round.
//!
//! Outputs:
//! - `UnitScores.scores` are the **final-round tallies** in canonical option order
//!   (eliminated options end at 0).
//! - `IrvLog` contains per-round eliminations, transfers, and exhausted counts,
//!   plus the winner option_id.

use std::collections::{BTreeMap, BTreeSet, HashMap};

use vm_core::{
    entities::{OptionItem, TallyTotals},
    ids::{OptionId, UnitId},
    variables::Params,
};

use crate::UnitScores;

/// One IRV elimination round.
#[derive(Debug, Clone)]
pub struct IrvRound {
    /// The eliminated option in this round.
    pub eliminated: OptionId,
    /// Transfers from the eliminated option to next continuing preferences.
    /// Keys are destination option IDs; values are transferred multiplicities.
    pub transfers: BTreeMap<OptionId, u64>,
    /// Ballots that had no further continuing preference and thus exhausted this round.
    pub exhausted: u64,
}

/// Full IRV audit log for a unit.
#[derive(Debug, Clone)]
pub struct IrvLog {
    pub rounds: Vec<IrvRound>,
    pub winner: OptionId,
}

/// Deterministic IRV tabulation with reduce-on-exhaustion denominator.
pub fn tabulate_ranked_irv(
    unit_id: UnitId,
    ballots: &[(Vec<OptionId>, u64)],
    options: &[OptionItem],
    turnout: TallyTotals,
    params: &Params, // currently unused (policy fixed); present for forward compatibility
) -> (UnitScores, IrvLog) {
    let _ = params; // suppress unused for now

    // Canonical option order (tie-break order).
    let order: Vec<OptionId> = options.iter().map(|o| o.option_id.clone()).collect();
    let ord_idx: HashMap<&OptionId, usize> = order
        .iter()
        .enumerate()
        .map(|(i, id)| (id, i))
        .collect();

    // Continuing set starts as all options.
    let mut continuing: BTreeSet<OptionId> = order.iter().cloned().collect();

    // Continuing denominator starts at valid ballots; shrinks by per-round exhausted.
    let mut continuing_total: u64 = turnout.valid_ballots;

    // Zero-valid case: deterministic fallback to the first option by canonical order.
    if continuing_total == 0 {
        let winner = order
            .get(0)
            .cloned()
            .unwrap_or_else(|| "UNKNOWN".parse().unwrap_or_else(|_| OptionId::from("UNKNOWN")));
        let final_scores = finalize_scores(BTreeMap::new(), options);
        let scores = UnitScores {
            unit_id,
            turnout,
            scores: final_scores,
        };
        let log = IrvLog {
            rounds: Vec::new(),
            winner,
        };
        return (scores, log);
    }

    let mut rounds: Vec<IrvRound> = Vec::new();
    let winner: OptionId;

    loop {
        // 1) Tally first preferences among continuing options.
        let tallies = first_preferences(ballots, &continuing);

        // 2) Majority check (strict > 50% of continuing_total).
        if let Some(w) = majority_winner(&tallies, continuing_total) {
            winner = w;
            break;
        }

        // 3) Single remaining => winner.
        if continuing.len() == 1 {
            winner = continuing.iter().next().unwrap().clone();
            break;
        }

        // 4) Pick lowest tally; tie-break by canonical order.
        let eliminated = pick_lowest(&tallies, &ord_idx, &continuing);

        // 5) Compute transfers and exhausted (from ballots whose current top is `eliminated`).
        let (transfers, exhausted) =
            transfer_from_eliminated(ballots, &eliminated, &continuing);

        // 6) Apply exhaustion policy: reduce continuing denominator.
        continuing_total = continuing_total.saturating_sub(exhausted);

        // 7) Remove eliminated from continuing set.
        continuing.remove(&eliminated);

        // 8) Log round.
        rounds.push(IrvRound {
            eliminated,
            transfers,
            exhausted,
        });

        // Continue to next round.
    }

    // Final tallies with the last continuing set.
    let final_tallies = first_preferences(ballots, &continuing);
    let final_scores = finalize_scores(final_tallies, options);

    let scores = UnitScores {
        unit_id,
        turnout,
        scores: final_scores,
    };
    let log = IrvLog { rounds, winner };
    (scores, log)
}

/// Build first-preference tallies among the provided `continuing` set.
fn first_preferences(
    ballots: &[(Vec<OptionId>, u64)],
    continuing: &BTreeSet<OptionId>,
) -> BTreeMap<OptionId, u64> {
    let mut out: BTreeMap<OptionId, u64> = BTreeMap::new();
    for (ranking, n) in ballots {
        if let Some(first) = first_pref_in_set(ranking, continuing) {
            *out.entry(first).or_insert(0) += *n;
        }
    }
    out
}

/// Return the first option in `ranking` that is a member of `set`.
fn first_pref_in_set<'a>(
    ranking: &'a [OptionId],
    set: &BTreeSet<OptionId>,
) -> Option<OptionId> {
    for id in ranking {
        if set.contains(id) {
            return Some(id.clone());
        }
    }
    None
}

/// Choose the lowest-tally continuing option; tie-break by canonical order via `ord_idx`.
fn pick_lowest(
    tallies: &BTreeMap<OptionId, u64>,
    ord_idx: &HashMap<&OptionId, usize>,
    continuing: &BTreeSet<OptionId>,
) -> OptionId {
    // Build (tally, order_index, id) tuples for continuing options; missing tallies treated as 0.
    let mut best: Option<(u64, usize, OptionId)> = None;
    for id in continuing {
        let t = *tallies.get(id).unwrap_or(&0);
        let oi = *ord_idx.get(id).unwrap_or(&usize::MAX);
        let cand = (t, oi, id.clone());
        if best.is_none() || cand < best.as_ref().unwrap().clone() {
            best = Some(cand);
        }
    }
    best.expect("continuing non-empty").3
}

/// For ballots currently allocated to `eliminated`, compute the transfers to next continuing
/// preferences (with `eliminated` removed) and the exhausted count.
fn transfer_from_eliminated(
    ballots: &[(Vec<OptionId>, u64)],
    eliminated: &OptionId,
    continuing: &BTreeSet<OptionId>,
) -> (BTreeMap<OptionId, u64>, u64) {
    let mut transfers: BTreeMap<OptionId, u64> = BTreeMap::new();
    let mut exhausted: u64 = 0;

    // Continuing set without the eliminated option (borrow-then-clone on demand).
    // We'll test membership dynamically for clarity.
    for (ranking, n) in ballots {
        // Is this ballot currently allocated to `eliminated`?
        if let Some(first_now) = first_pref_in_set(ranking, continuing) {
            if &first_now == eliminated {
                // Find the next preference in the *remaining* continuing set (excluding `eliminated`).
                if let Some(next_dest) =
                    next_pref_after_eliminated(ranking, eliminated, continuing)
                {
                    *transfers.entry(next_dest).or_insert(0) += *n;
                } else {
                    exhausted = exhausted.saturating_add(*n);
                }
            }
        }
    }

    (transfers, exhausted)
}

/// Scan forward in `ranking` to find the *next* continuing preference after the first encounter
/// of `eliminated`. If none exists, returns None (the ballot exhausts on this round).
fn next_pref_after_eliminated(
    ranking: &[OptionId],
    eliminated: &OptionId,
    continuing: &BTreeSet<OptionId>,
) -> Option<OptionId> {
    let mut passed_elim = false;
    for id in ranking {
        if !continuing.contains(id) {
            continue;
        }
        if !passed_elim {
            if id == eliminated {
                passed_elim = true;
            } else {
                // First continuing is NOT the eliminated; this ballot isn't allocated to eliminated.
                return None;
            }
        } else {
            // This is the next continuing choice after the eliminated one.
            return Some(id.clone());
        }
    }
    // No further continuing preference.
    if passed_elim {
        None
    } else {
        // Never encountered the eliminated as a continuing choice => not allocated to it.
        None
    }
}

/// If any option has a strict majority of the continuing denominator, return it.
fn majority_winner(
    tallies: &BTreeMap<OptionId, u64>,
    continuing_total: u64,
) -> Option<OptionId> {
    let threshold = continuing_total / 2; // need > threshold
    let mut best: Option<(u64, OptionId)> = None;
    for (id, &t) in tallies {
        if t > threshold {
            let cand = (t, id.clone());
            if best.as_ref().map_or(true, |b| cand.0 > b.0) {
                best = Some(cand);
            }
        }
    }
    best.map(|(_, id)| id)
}

/// Render final-round tallies for *all* options in canonical order;
/// eliminated options (not in the final tallies map) receive 0.
fn finalize_scores(
    last_round_tallies: BTreeMap<OptionId, u64>,
    options: &[OptionItem],
) -> BTreeMap<OptionId, u64> {
    let mut out = BTreeMap::<OptionId, u64>::new();
    for opt in options {
        let v = last_round_tallies.get(&opt.option_id).copied().unwrap_or(0);
        out.insert(opt.option_id.clone(), v);
    }
    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use vm_core::entities::OptionItem;

    fn opt(id: &str, idx: u16) -> OptionItem {
        OptionItem::new(
            id.parse().expect("opt id"),
            format!("Name {id}"),
            idx,
        )
        .expect("option")
    }

    #[test]
    fn simple_majority_in_first_round() {
        let options = vec![opt("A", 0), opt("B", 1)];
        let ballots = vec![
            (vec!["A".parse().unwrap()], 60),
            (vec!["B".parse().unwrap()], 40),
        ];
        let turnout = TallyTotals::new(100, 0);
        let params = Params::default();

        let (scores, log) = tabulate_ranked_irv("U-1".parse().unwrap(), &ballots, &options, turnout, &params);
        assert_eq!(log.rounds.len(), 0, "no rounds when majority in R1");
        assert_eq!(log.winner.to_string(), "A");
        assert_eq!(*scores.scores.get(&"A".parse().unwrap()).unwrap(), 60);
        assert_eq!(*scores.scores.get(&"B".parse().unwrap()).unwrap(), 40);
    }

    #[test]
    fn elimination_with_exhaustion() {
        // R1: A=35, B=40, C=25 (100 valid)
        // Eliminate C; suppose 15 go to B, 10 exhaust → continuing_total becomes 90.
        // R2: A=35, B=55 → winner B.
        let options = vec![opt("A", 0), opt("B", 1), opt("C", 2)];
        let ballots = vec![
            (vec!["A".parse().unwrap(), "B".parse().unwrap()], 35),
            (vec!["B".parse().unwrap()], 40),
            (vec!["C".parse().unwrap(), "B".parse().unwrap()], 15),
            (vec!["C".parse().unwrap()], 10), // will exhaust when C eliminated
        ];
        let turnout = TallyTotals::new(100, 0);
        let params = Params::default();

        let (_scores, log) =
            tabulate_ranked_irv("U-1".parse().unwrap(), &ballots, &options, turnout, &params);

        assert_eq!(log.rounds.len(), 1);
        assert_eq!(log.rounds[0].eliminated.to_string(), "C");
        assert_eq!(log.rounds[0].exhausted, 10);
        assert_eq!(
            *log.rounds[0]
                .transfers
                .get(&"B".parse().unwrap())
                .unwrap_or(&0),
            15
        );
        assert_eq!(log.winner.to_string(), "B");
    }

    #[test]
    fn zero_valid_ballots_deterministic_winner() {
        let options = vec![opt("A", 0), opt("B", 1), opt("C", 2)];
        let ballots: Vec<(Vec<OptionId>, u64)> = vec![];
        let turnout = TallyTotals::new(0, 0);
        let params = Params::default();

        let (scores, log) =
            tabulate_ranked_irv("U-1".parse().unwrap(), &ballots, &options, turnout, &params);

        // No rounds, winner is the first by canonical order.
        assert_eq!(log.rounds.len(), 0);
        assert_eq!(log.winner.to_string(), "A");
        // All final tallies are zero.
        for opt in &options {
            assert_eq!(*scores.scores.get(&opt.option_id).unwrap(), 0);
        }
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/tabulation/ranked_condorcet.rs
--------------------------------------------------------------------------------
//! Condorcet tabulation (deterministic, integers-only, no RNG).
//!
//! Contract (Doc 1 / Annex A aligned):
//! - Inputs are compressed ballot groups: (ranking, multiplicity).
//! - Options come in canonical order: (order_index, option_id).
//! - If a Condorcet winner exists (strictly beats every other), select it.
//! - Otherwise resolve cycles via a deterministic completion rule
//!   (default Schulze; Minimax supported). No RNG here.
//!
//! Output:
//! - `UnitScores.scores` are **winner-only** tallies (winner gets V, others 0) in
//!   canonical key order to keep downstream deterministic and simple.
//! - `Pairwise` matrix is emitted for audit; `CondorcetLog` records rule + winner.

use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};

use vm_core::{
    entities::{OptionItem, TallyTotals},
    ids::{OptionId, UnitId},
    variables::Params,
};

use crate::UnitScores;

/// Pairwise audit matrix: wins[(A,B)] = number of ballots that prefer A over B.
#[derive(Debug, Clone)]
pub struct Pairwise {
    pub wins: BTreeMap<(OptionId, OptionId), u64>,
}

/// Completion rule used when no strict Condorcet winner exists.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CompletionRule {
    Schulze,
    Minimax,
}

/// Log for Condorcet tabulation.
#[derive(Debug, Clone)]
pub struct CondorcetLog {
    pub completion_rule: CompletionRule,
    pub winner: OptionId,
    pub pairwise_summary: Pairwise,
}

/// Deterministic Condorcet tabulation.
///
/// Returns `(UnitScores /*winner-only*/, Pairwise, CondorcetLog)`.
pub fn tabulate_ranked_condorcet(
    unit_id: UnitId,
    ballots: &[(Vec<OptionId>, u64)],
    options: &[OptionItem],
    turnout: TallyTotals,
    params: &Params, // used to choose completion rule; default Schulze
) -> (UnitScores, Pairwise, CondorcetLog) {
    // Canonical option list & index map (tie-break order).
    let order: Vec<OptionId> = options.iter().map(|o| o.option_id.clone()).collect();
    let ord_idx: HashMap<&OptionId, usize> = order
        .iter()
        .enumerate()
        .map(|(i, id)| (id, i))
        .collect();

    // Build the pairwise matrix.
    let pairwise = build_pairwise(ballots, &order);

    // Zero-valid case: deterministic fallback to first option by canonical order.
    let v = turnout.valid_ballots;
    let (winner, rule_used) = if v == 0 {
        (
            order
                .get(0)
                .cloned()
                .unwrap_or_else(|| "UNKNOWN".parse().unwrap_or_else(|_| OptionId::from("UNKNOWN"))),
            CompletionRule::Schulze,
        )
    } else if let Some(w) = condorcet_winner(&pairwise, &order) {
        (w, CompletionRule::Schulze) // rule is moot when strict winner exists
    } else {
        // Resolve via completion rule.
        let rule = completion_rule_from_params(params).unwrap_or(CompletionRule::Schulze);
        let w = match rule {
            CompletionRule::Schulze => schulze_winner(&pairwise, &order, &ord_idx),
            CompletionRule::Minimax => minimax_winner(&pairwise, &order, &ord_idx),
        };
        (w, rule)
    };

    // Winner-only scores map: winner gets V, others 0, in canonical key order.
    let scores_map = winner_scores(&winner, v, options);

    let scores = UnitScores {
        unit_id,
        turnout,
        scores: scores_map,
    };
    let log = CondorcetLog {
        completion_rule: rule_used,
        winner: winner.clone(),
        pairwise_summary: pairwise.clone(),
    };
    (scores, pairwise, log)
}

/// Compute the pairwise matrix from ranked ballots in canonical option set `order`.
pub fn build_pairwise(ballots: &[(Vec<OptionId>, u64)], order: &[OptionId]) -> Pairwise {
    let allowed: BTreeSet<OptionId> = order.iter().cloned().collect();
    let mut wins: BTreeMap<(OptionId, OptionId), u64> = BTreeMap::new();

    for (ranking, count) in ballots {
        if *count == 0 {
            continue;
        }
        // Filter to unique, allowed options in ballot order (ignore unknowns/dups).
        let mut seen = HashSet::<&OptionId>::new();
        let mut seq: Vec<&OptionId> = Vec::with_capacity(ranking.len());
        for id in ranking {
            if allowed.contains(id) && !seen.contains(id) {
                seen.insert(id);
                seq.push(id);
            }
        }
        // For each ordered pair (i < j), increment wins[(A,B)] by count.
        for i in 0..seq.len() {
            for j in (i + 1)..seq.len() {
                let a = seq[i].clone();
                let b = seq[j].clone();
                *wins.entry((a.clone(), b.clone())).or_insert(0) += *count;
            }
        }
    }

    Pairwise { wins }
}

/// Return a strict Condorcet winner if one exists.
pub fn condorcet_winner(pw: &Pairwise, order: &[OptionId]) -> Option<OptionId> {
    for x in order {
        let mut beats_all = true;
        for y in order {
            if x == y {
                continue;
            }
            let xy = get_win(pw, x, y);
            let yx = get_win(pw, y, x);
            if xy <= yx {
                beats_all = false;
                break;
            }
        }
        if beats_all {
            return Some(x.clone());
        }
    }
    None
}

/// Schulze method winner (with deterministic tie-break by canonical order).
pub fn schulze_winner(
    pw: &Pairwise,
    order: &[OptionId],
    ord_idx: &HashMap<&OptionId, usize>,
) -> OptionId {
    // d[i][j] = wins(i,j) if wins(i,j) > wins(j,i), else 0
    let n = order.len();
    let mut d = vec![vec![0u64; n]; n];
    for (i, a) in order.iter().enumerate() {
        for (j, b) in order.iter().enumerate() {
            if i == j {
                continue;
            }
            let ab = get_win(pw, a, b);
            let ba = get_win(pw, b, a);
            d[i][j] = if ab > ba { ab } else { 0 };
        }
    }
    // p[i][j] = strength of strongest path from i to j
    let mut p = d.clone();
    for i in 0..n {
        for j in 0..n {
            if i == j {
                continue;
            }
            for k in 0..n {
                if i == k || j == k {
                    continue;
                }
                let via = std::cmp::min(p[j][i], p[i][k]);
                if p[j][k] < via {
                    p[j][k] = via;
                }
            }
        }
    }
    // Candidate i is a winner if for all j != i, p[i][j] >= p[j][i].
    // Collect all winners, then choose the earliest in canonical order.
    let mut winners: Vec<usize> = Vec::new();
    'outer: for i in 0..n {
        for j in 0..n {
            if i != j && p[i][j] < p[j][i] {
                continue 'outer;
            }
        }
        winners.push(i);
    }
    // Deterministic tie-break: pick the one with smallest canonical order index.
    let best = winners
        .into_iter()
        .min_by_key(|&i| ord_idx.get(&order[i]).copied().unwrap_or(usize::MAX))
        .unwrap_or(0);
    order[best].clone()
}

/// Minimax (aka Simpson/Smith) winner: pick candidate minimizing its maximum defeat.
/// Tie-break deterministically by canonical order.
pub fn minimax_winner(
    pw: &Pairwise,
    order: &[OptionId],
    ord_idx: &HashMap<&OptionId, usize>,
) -> OptionId {
    let n = order.len();
    // For each i, compute max defeat margin: max over j of max( wins(j,i) - wins(i,j), 0 )
    let mut max_defeat: Vec<(u64, usize)> = Vec::with_capacity(n);
    for (i, a) in order.iter().enumerate() {
        let mut worst: u64 = 0;
        for (j, b) in order.iter().enumerate() {
            if i == j {
                continue;
            }
            let ai = get_win(pw, a, b);
            let ia = get_win(pw, b, a);
            if ia > ai {
                let margin = ia - ai;
                if margin > worst {
                    worst = margin;
                }
            }
        }
        let oi = ord_idx.get(a).copied().unwrap_or(usize::MAX);
        max_defeat.push((worst, oi));
    }
    // Choose minimal (max_defeat, order_index)
    let mut best_i = 0usize;
    let mut best_key = (u64::MAX, usize::MAX);
    for (i, key) in max_defeat.into_iter().enumerate() {
        if key < best_key {
            best_key = key;
            best_i = i;
        }
    }
    order[best_i].clone()
}

/// Winner-only scores: `{winner: V, others: 0}` in canonical key order.
pub fn winner_scores(
    winner: &OptionId,
    valid_ballots: u64,
    options: &[OptionItem],
) -> BTreeMap<OptionId, u64> {
    let mut out = BTreeMap::<OptionId, u64>::new();
    for opt in options {
        let v = if &opt.option_id == winner {
            valid_ballots
        } else {
            0
        };
        out.insert(opt.option_id.clone(), v);
    }
    out
}

/// Helper: get wins(A,B) from the matrix (0 if absent).
#[inline]
fn get_win(pw: &Pairwise, a: &OptionId, b: &OptionId) -> u64 {
    *pw.wins.get(&(a.clone(), b.clone())).unwrap_or(&0)
}

/// Read a completion rule from params; returns `None` if not specified/recognized.
fn completion_rule_from_params(_params: &Params) -> Option<CompletionRule> {
    // The reference spec keeps this per-release; we default to Schulze.
    // If you later name a param (e.g., v005_aggregation_mode == "minimax"),
    // wire it here (lowercase match).
    None
}

#[cfg(test)]
mod tests {
    use super::*;
    use vm_core::entities::OptionItem;

    fn opt(id: &str, idx: u16) -> OptionItem {
        OptionItem::new(
            id.parse().expect("opt id"),
            format!("Name {id}"),
            idx,
        )
        .expect("option")
    }

    #[test]
    fn strict_condorcet_exists() {
        // A beats B and C; B beats C.
        let options = vec![opt("A", 0), opt("B", 1), opt("C", 2)];
        let ballots = vec![
            (vec!["A".parse().unwrap(), "B".parse().unwrap(), "C".parse().unwrap()], 40),
            (vec!["A".parse().unwrap(), "C".parse().unwrap(), "B".parse().unwrap()], 15),
            (vec!["B".parse().unwrap(), "C".parse().unwrap(), "A".parse().unwrap()], 30),
            (vec!["C".parse().unwrap(), "B".parse().unwrap(), "A".parse().unwrap()], 15),
        ];
        let turnout = TallyTotals::new(100, 0);
        let params = Params::default();

        let (scores, _pw, log) = tabulate_ranked_condorcet(
            "U-1".parse().unwrap(),
            &ballots,
            &options,
            turnout,
            &params,
        );

        assert_eq!(log.winner.to_string(), "A");
        assert_eq!(*scores.scores.get(&"A".parse().unwrap()).unwrap(), 100);
        assert_eq!(*scores.scores.get(&"B".parse().unwrap()).unwrap(), 0);
        assert_eq!(*scores.scores.get(&"C".parse().unwrap()).unwrap(), 0);
    }

    #[test]
    fn cycle_resolved_by_schulze_deterministically() {
        // Rock-Paper-Scissors style cycle:
        // A > B, B > C, C > A with equal margins; Schulze tie-break by canonical order.
        let options = vec![opt("A", 0), opt("B", 1), opt("C", 2)];
        let ballots = vec![
            (vec!["A".parse().unwrap(), "B".parse().unwrap(), "C".parse().unwrap()], 34),
            (vec!["B".parse().unwrap(), "C".parse().unwrap(), "A".parse().unwrap()], 33),
            (vec!["C".parse().unwrap(), "A".parse().unwrap(), "B".parse().unwrap()], 33),
        ];
        let turnout = TallyTotals::new(100, 0);
        let params = Params::default();

        let (_scores, _pw, log) = tabulate_ranked_condorcet(
            "U-1".parse().unwrap(),
            &ballots,
            &options,
            turnout,
            &params,
        );

        // With symmetric strengths, Schulze winners can tie; we pick the earliest by canonical order.
        assert_eq!(log.winner.to_string(), "A");
        assert!(matches!(log.completion_rule, CompletionRule::Schulze));
    }

    #[test]
    fn zero_valid_ballots_fallback() {
        let options = vec![opt("A", 0), opt("B", 1)];
        let ballots: Vec<(Vec<OptionId>, u64)> = vec![];
        let turnout = TallyTotals::new(0, 0);
        let params = Params::default();

        let (scores, _pw, log) = tabulate_ranked_condorcet(
            "U-1".parse().unwrap(),
            &ballots,
            &options,
            turnout,
            &params,
        );

        assert_eq!(log.winner.to_string(), "A");
        for opt in &options {
            assert_eq!(*scores.scores.get(&opt.option_id).unwrap(), 0);
        }
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/allocation/wta.rs
--------------------------------------------------------------------------------
//! Winner-take-all allocation (deterministic; integers only; RNG used only when TiePolicy::Random).
//!
//! Contract (Doc 1 / Annex A aligned):
//! - Magnitude must be exactly 1.
//! - Pick the highest score; if multiple options tie for top, break the tie by the selected policy:
//!     * StatusQuo  → attempt SQ pick (if flagged upstream), otherwise fall back to DeterministicOrder.
//!     * DeterministicOrder → smallest by canonical option order (order_index, then option_id).
//!     * Random → uniform choice using provided `TieRng`; if no RNG is provided, fall back to DeterministicOrder.
//! - Output encodes WTA as 100 “power” for the winner.
//!
//! Notes:
//! - `OptionItem` in vm_core intentionally has no `is_status_quo` flag; if none is known,
//!   StatusQuo policy deterministically falls back to canonical order.

use std::collections::{BTreeMap, BTreeSet};

use vm_core::{
    ids::OptionId,
    entities::OptionItem,
    rng::TieRng,
    variables::TiePolicy,
};

use crate::Allocation;
use crate::UnitScores;

/// Errors for WTA allocation.
#[derive(Debug)]
pub enum AllocError {
    /// WTA requires magnitude == 1.
    InvalidMagnitude { got: u32 },
    /// Defensive: a score key did not exist in the provided options list.
    UnknownOption(OptionId),
}

/// Winner-take-all. Expects `magnitude == 1`.
///
/// *Determinism:* when `tie_policy != Random` (or RNG not supplied), ties are broken by canonical
/// option order `(order_index, option_id)`.
pub fn allocate_wta(
    scores: &UnitScores,
    magnitude: u32,
    options: &[OptionItem],
    tie_policy: TiePolicy,
    mut rng: Option<&mut TieRng>,
) -> Result<Allocation, AllocError> {
    if magnitude != 1 {
        return Err(AllocError::InvalidMagnitude { got: magnitude });
    }

    // Defensive: ensure no unknown option IDs appear in the score map.
    // (Upstream cross-ref in vm_io.loader should already guarantee this.)
    let allowed: BTreeSet<&OptionId> = options.iter().map(|o| &o.option_id).collect();
    for k in scores.scores.keys() {
        if !allowed.contains(k) {
            return Err(AllocError::UnknownOption(k.clone()));
        }
    }

    // Find max score and collect all tied-at-max, using canonical option order.
    let (max_score, tied) = top_by_score(scores, options);

    // Select winner (resolve ties per policy).
    let winner = if tied.len() == 1 {
        tied[0].clone()
    } else {
        break_tie_wta(&tied, options, tie_policy, rng.as_deref_mut())
    };

    // Encode WTA: winner gets 100 "power".
    let mut seats_or_power: BTreeMap<OptionId, u32> = BTreeMap::new();
    if max_score > 0 || !tied.is_empty() {
        seats_or_power.insert(winner.clone(), 100);
    } else {
        // All zero scores but we still must choose deterministically; grant winner 100.
        seats_or_power.insert(winner.clone(), 100);
    }

    Ok(Allocation {
        unit_id: scores.unit_id.clone(),
        seats_or_power,
        last_seat_tie: tied.len() > 1,
    })
}

/// Scan scores in canonical option order and return (max_score, tied_ids_at_max).
fn top_by_score(scores: &UnitScores, options: &[OptionItem]) -> (u64, Vec<OptionId>) {
    let mut max_val: u64 = 0;
    let mut tied: Vec<OptionId> = Vec::new();

    for opt in options {
        let v = *scores.scores.get(&opt.option_id).unwrap_or(&0);
        if v > max_val {
            max_val = v;
            tied.clear();
            tied.push(opt.option_id.clone());
        } else if v == max_val {
            tied.push(opt.option_id.clone());
        }
    }
    (max_val, tied)
}

/// Resolve a tie among `tied` option IDs per policy.
/// If StatusQuo cannot be determined from `options`, falls back to DeterministicOrder.
/// If Random is requested but `rng` is None, falls back to DeterministicOrder.
fn break_tie_wta(
    tied: &[OptionId],
    options: &[OptionItem],
    tie_policy: TiePolicy,
    rng: Option<&mut TieRng>,
) -> OptionId {
    match tie_policy {
        TiePolicy::StatusQuo => {
            // No `is_status_quo` flag in OptionItem in vm_core; fall back to deterministic order.
            pick_deterministic(tied, options)
        }
        TiePolicy::DeterministicOrder => pick_deterministic(tied, options),
        TiePolicy::Random => {
            if let Some(rng) = rng {
                // Build index lookups into `tied` by canonical order to keep behavior stable.
                // Draw uniformly in [0, tied.len()) via rejection sampling.
                let n = tied.len() as u64;
                if n == 0 {
                    // Should not happen; fall back deterministically.
                    return pick_deterministic(tied, options);
                }
                let idx = rng.gen_range(n).unwrap_or(0) as usize;
                tied[idx].clone()
            } else {
                // No RNG supplied → deterministic fallback.
                pick_deterministic(tied, options)
            }
        }
    }
}

/// Deterministic tie-break: choose the earliest by canonical option order `(order_index, option_id)`.
fn pick_deterministic(tied: &[OptionId], options: &[OptionItem]) -> OptionId {
    // Walk options in canonical order; return the first that is in `tied`.
    let tied_set: BTreeSet<&OptionId> = tied.iter().collect();
    for opt in options {
        if tied_set.contains(&opt.option_id) {
            return opt.option_id.clone();
        }
    }
    // Should never happen (tied must be subset of options). Fall back to lexicographic min.
    tied.iter()
        .min()
        .cloned()
        .unwrap_or_else(|| OptionId::from("UNKNOWN"))
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/allocation/dhondt.rs
--------------------------------------------------------------------------------
//! D’Hondt (highest averages) allocation per unit.
//!
//! Contract (Doc 1 / Annex A aligned):
//! - Apply entry threshold on the *natural* totals (plurality votes, approvals, score sums).
//! - Allocate `seats` sequentially by picking max of v/(s+1).
//! - Ties resolved by policy: StatusQuo → fallback deterministic (no SQ flag in core),
//!   DeterministicOrder → canonical `(order_index, option_id)`, Random → seeded `TieRng`.
//! - Pure integers; no division in comparisons (cross-multiply in u128).
//!
//! Determinism:
//! - Iteration/scans run in canonical option order (the `options` slice).
//! - Random ties depend *only* on the provided `TieRng` stream.

use std::collections::{BTreeMap, BTreeSet};

use vm_core::{
    ids::OptionId,
    entities::OptionItem,
    rng::TieRng,
    variables::TiePolicy,
};

#[derive(Debug)]
pub enum AllocError {
    /// After threshold filtering, no options remain eligible while seats > 0.
    NoEligibleOptions,
    /// Policy was Random but no RNG was supplied (and seats > 0).
    MissingRngForRandomPolicy,
}

/// Allocate seats using D’Hondt (highest averages) method.
///
/// *Notes*:
/// - If `seats == 0`, returns an empty map.
/// - Threshold is applied against the sum of provided `scores`.
/// - Keys not present in `scores` are treated as 0 (they rarely pass a positive threshold).
pub fn allocate_dhondt(
    seats: u32,
    scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],      // canonical (order_index, id)
    threshold_pct: u8,
    tie_policy: TiePolicy,
    mut rng: Option<&mut TieRng>,
) -> Result<BTreeMap<OptionId, u32>, AllocError> {
    if seats == 0 {
        return Ok(BTreeMap::new());
    }
    if matches!(tie_policy, TiePolicy::Random) && rng.is_none() {
        return Err(AllocError::MissingRngForRandomPolicy);
    }

    let eligible_scores = filter_by_threshold(scores, threshold_pct);
    if eligible_scores.is_empty() {
        return Err(AllocError::NoEligibleOptions);
    }

    // Initialize seat vector for eligible options only.
    let mut alloc: BTreeMap<OptionId, u32> =
        eligible_scores.keys().cloned().map(|id| (id, 0)).collect();

    for _round in 0..seats {
        let winner = next_award(&alloc, &eligible_scores, options, tie_policy, rng.as_deref_mut());
        // Safe: by construction, winner is eligible.
        *alloc.get_mut(&winner).expect("winner must be in alloc") += 1;
    }

    Ok(alloc)
}

/// Filter by PR threshold using natural totals.
/// Keeps (opt, v) where 100 * v >= threshold_pct * total.
fn filter_by_threshold(
    scores: &BTreeMap<OptionId, u64>,
    threshold_pct: u8,
) -> BTreeMap<OptionId, u64> {
    let total: u128 = scores.values().map(|&v| v as u128).sum();
    // Fast path: threshold 0 keeps all.
    if threshold_pct == 0 {
        return scores.clone();
    }
    let t = threshold_pct as u128;
    scores
        .iter()
        .filter_map(|(k, &v)| {
            let v128 = v as u128;
            // Keep if share >= threshold.
            if v128.saturating_mul(100) >= t.saturating_mul(total) {
                Some((k.clone(), v))
            } else {
                None
            }
        })
        .collect()
}

/// Choose argmax of v/(s+1) across eligible; ties resolved per policy.
fn next_award(
    seats_so_far: &BTreeMap<OptionId, u32>,
    eligible_scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
    tie_policy: TiePolicy,
    rng: Option<&mut TieRng>,
) -> OptionId {
    // Track the current best quotient and tied IDs in canonical order.
    let mut best_ids: Vec<OptionId> = Vec::new();
    let mut best_v: u64 = 0;
    let mut best_s: u32 = 0;
    let mut have_best = false;

    for opt in options {
        if let Some(&v) = eligible_scores.get(&opt.option_id) {
            let s = *seats_so_far.get(&opt.option_id).unwrap_or(&0);
            if !have_best {
                have_best = true;
                best_v = v;
                best_s = s;
                best_ids.clear();
                best_ids.push(opt.option_id.clone());
            } else {
                match cmp_quotients(v, s, best_v, best_s) {
                    core::cmp::Ordering::Greater => {
                        best_v = v;
                        best_s = s;
                        best_ids.clear();
                        best_ids.push(opt.option_id.clone());
                    }
                    core::cmp::Ordering::Equal => {
                        best_ids.push(opt.option_id.clone());
                    }
                    core::cmp::Ordering::Less => {} // keep current best
                }
            }
        }
    }

    if best_ids.len() <= 1 {
        return best_ids
            .into_iter()
            .next()
            // Defensive fallback: if no eligible options were seen (shouldn't happen), pick earliest by options.
            .unwrap_or_else(|| options.first().map(|o| o.option_id.clone()).unwrap_or_else(|| OptionId::from("UNKNOWN")));
    }

    // Resolve tie per policy.
    match tie_policy {
        TiePolicy::StatusQuo => status_quo_pick(&best_ids, options),
        TiePolicy::DeterministicOrder => deterministic_pick(&best_ids, options),
        TiePolicy::Random => {
            // rng presence was enforced at entry when seats > 0.
            let n = best_ids.len() as u64;
            let idx = rng
                .expect("rng must be provided for Random policy")
                .gen_range(n)
                .unwrap_or(0) as usize;
            best_ids[idx].clone()
        }
    }
}

/// Compare D’Hondt quotients v_a/(s_a+1) vs v_b/(s_b+1) without floats.
/// Returns Ordering::Greater if a's quotient is larger.
fn cmp_quotients(v_a: u64, s_a: u32, v_b: u64, s_b: u32) -> core::cmp::Ordering {
    // Compare v_a * (s_b+1) ? v_b * (s_a+1) in u128 to avoid overflow.
    let da = (s_a as u128) + 1;
    let db = (s_b as u128) + 1;
    let lhs = (v_a as u128) * db;
    let rhs = (v_b as u128) * da;
    lhs.cmp(&rhs)
}

/// Deterministic tie-break: pick earliest in canonical option order.
fn deterministic_pick(tied: &[OptionId], options: &[OptionItem]) -> OptionId {
    let set: BTreeSet<&OptionId> = tied.iter().collect();
    for o in options {
        if set.contains(&o.option_id) {
            return o.option_id.clone();
        }
    }
    // Fallback: lexicographic min (should not be needed).
    tied.iter().min().cloned().unwrap_or_else(|| OptionId::from("UNKNOWN"))
}

/// Status-quo resolver: since `OptionItem` has no SQ flag in vm_core, fall back to deterministic.
fn status_quo_pick(tied: &[OptionId], options: &[OptionItem]) -> OptionId {
    deterministic_pick(tied, options)
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/allocation/sainte_lague.rs
--------------------------------------------------------------------------------
//! Sainte-Laguë (highest averages with odd divisors) allocation per unit.
//!
//! Contract (Doc 1 / Annex A aligned):
//! - Apply entry threshold on the natural totals (plurality votes, approvals, score sums).
//! - Allocate `seats` sequentially by picking max of v / (2*s + 1).
//! - Ties resolved by policy: StatusQuo → fallback deterministic (no SQ flag in core),
//!   DeterministicOrder → canonical `(order_index, option_id)`,
//!   Random → seeded `TieRng`.
//! - Pure integers; no division in comparisons (cross-multiply in u128).
//!
//! Determinism:
//! - Scans iterate in canonical option order (the `options` slice).
//! - Random ties depend *only* on the provided `TieRng` stream.

use std::collections::{BTreeMap, BTreeSet};

use vm_core::{
    ids::OptionId,
    entities::OptionItem,
    rng::TieRng,
    variables::TiePolicy,
};

#[derive(Debug)]
pub enum AllocError {
    /// After threshold filtering, no options remain eligible while seats > 0.
    NoEligibleOptions,
    /// Policy was Random but no RNG was supplied (and seats > 0).
    MissingRngForRandomPolicy,
}

/// Allocate seats using Sainte-Laguë (odd divisors 1,3,5,…) method.
///
/// *Notes*:
/// - If `seats == 0`, returns an empty map.
/// - Threshold is applied against the sum of provided `scores`.
/// - Keys not present in `scores` are treated as 0 (they rarely pass a positive threshold).
pub fn allocate_sainte_lague(
    seats: u32,
    scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem], // canonical (order_index, id)
    threshold_pct: u8,
    tie_policy: TiePolicy,
    mut rng: Option<&mut TieRng>,
) -> Result<BTreeMap<OptionId, u32>, AllocError> {
    if seats == 0 {
        return Ok(BTreeMap::new());
    }
    if matches!(tie_policy, TiePolicy::Random) && rng.is_none() {
        return Err(AllocError::MissingRngForRandomPolicy);
    }

    let eligible_scores = filter_by_threshold(scores, threshold_pct);
    if eligible_scores.is_empty() {
        return Err(AllocError::NoEligibleOptions);
    }

    // Initialize seat vector for eligible options only.
    let mut alloc: BTreeMap<OptionId, u32> =
        eligible_scores.keys().cloned().map(|id| (id, 0)).collect();

    for _round in 0..seats {
        let winner =
            next_award(&alloc, &eligible_scores, options, tie_policy, rng.as_deref_mut());
        *alloc.get_mut(&winner).expect("winner must be in alloc") += 1;
    }

    Ok(alloc)
}

/// Keep options whose natural share meets the threshold: 100*v >= threshold_pct*total (u128 math).
fn filter_by_threshold(
    scores: &BTreeMap<OptionId, u64>,
    threshold_pct: u8,
) -> BTreeMap<OptionId, u64> {
    let total: u128 = scores.values().map(|&v| v as u128).sum();
    if threshold_pct == 0 {
        return scores.clone();
    }
    let t = threshold_pct as u128;
    scores
        .iter()
        .filter_map(|(k, &v)| {
            let v128 = v as u128;
            if v128.saturating_mul(100) >= t.saturating_mul(total) {
                Some((k.clone(), v))
            } else {
                None
            }
        })
        .collect()
}

/// Argmax of Sainte-Laguë quotients v / (2*s + 1); ties per policy.
fn next_award(
    seats_so_far: &BTreeMap<OptionId, u32>,
    eligible_scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
    tie_policy: TiePolicy,
    rng: Option<&mut TieRng>,
) -> OptionId {
    // Track the current best quotient and tied IDs in canonical order.
    let mut best_ids: Vec<OptionId> = Vec::new();
    let mut best_v: u64 = 0;
    let mut best_s: u32 = 0;
    let mut have_best = false;

    for opt in options {
        if let Some(&v) = eligible_scores.get(&opt.option_id) {
            let s = *seats_so_far.get(&opt.option_id).unwrap_or(&0);
            if !have_best {
                have_best = true;
                best_v = v;
                best_s = s;
                best_ids.clear();
                best_ids.push(opt.option_id.clone());
            } else {
                match cmp_quotients(v, s, best_v, best_s) {
                    core::cmp::Ordering::Greater => {
                        best_v = v;
                        best_s = s;
                        best_ids.clear();
                        best_ids.push(opt.option_id.clone());
                    }
                    core::cmp::Ordering::Equal => {
                        best_ids.push(opt.option_id.clone());
                    }
                    core::cmp::Ordering::Less => {} // keep current best
                }
            }
        }
    }

    if best_ids.len() <= 1 {
        return best_ids
            .into_iter()
            .next()
            // Defensive fallback: if no eligible options were seen (shouldn't happen), pick earliest by options.
            .unwrap_or_else(|| options.first().map(|o| o.option_id.clone()).unwrap_or_else(|| OptionId::from("UNKNOWN")));
    }

    // Resolve tie per policy.
    match tie_policy {
        TiePolicy::StatusQuo => status_quo_pick(&best_ids, options),
        TiePolicy::DeterministicOrder => deterministic_pick(&best_ids, options),
        TiePolicy::Random => {
            let n = best_ids.len() as u64;
            let idx = rng
                .expect("rng must be provided for Random policy")
                .gen_range(n)
                .unwrap_or(0) as usize;
            best_ids[idx].clone()
        }
    }
}

/// Compare quotients q_a = v_a / (2*s_a+1) vs q_b = v_b / (2*s_b+1) using u128 cross-multiplication.
fn cmp_quotients(v_a: u64, s_a: u32, v_b: u64, s_b: u32) -> core::cmp::Ordering {
    // Compare v_a * (2*s_b+1) ? v_b * (2*s_a+1) in u128 to avoid overflow.
    let da = (2u128 * (s_a as u128)) + 1;
    let db = (2u128 * (s_b as u128)) + 1;
    let lhs = (v_a as u128) * db;
    let rhs = (v_b as u128) * da;
    lhs.cmp(&rhs)
}

/// Deterministic fallback: pick smallest by (order_index, then OptionId).
fn deterministic_pick(tied: &[OptionId], options: &[OptionItem]) -> OptionId {
    let set: BTreeSet<&OptionId> = tied.iter().collect();
    for o in options {
        if set.contains(&o.option_id) {
            return o.option_id.clone();
        }
    }
    // Fallback: lexicographic min (should not be needed).
    tied.iter().min().cloned().unwrap_or_else(|| OptionId::from("UNKNOWN"))
}

/// Status-quo resolver: since `OptionItem` has no SQ flag in vm_core, fall back to deterministic.
fn status_quo_pick(tied: &[OptionId], options: &[OptionItem]) -> OptionId {
    deterministic_pick(tied, options)
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/allocation/largest_remainder.rs
--------------------------------------------------------------------------------
//! Largest Remainder (LR) allocation per unit with selectable quota
//! (Hare, Droop, Imperiali), after applying an entry threshold.
//!
//! Contract (Doc 1 / Annex A aligned):
//! - Threshold is applied to natural totals (plurality votes, approvals, score sums).
//! - Quota kinds:
//!     * Hare:      floor(V / m)
//!     * Droop:     floor(V / (m + 1)) + 1
//!     * Imperiali: floor(V / (m + 2))
//! - Floors are v_i / q (integer div); remainders are v_i % q.
//! - If q == 0 (tiny totals), floors are 0 and remainders are raw scores.
//! - If sum_floors < seats → distribute leftovers by largest remainder
//!   (tie keys: remainder ↓, raw score ↓, then canonical (order_index, id);
//!   StatusQuo policy falls back to deterministic due to no SQ flag here).
//! - If sum_floors > seats (Imperiali edge) → trim from smallest remainder
//!   (inverse ordering; same tie-policy rules).
//!
//! Determinism:
//! - All scans follow canonical option order provided by `options`.
//! - Random ties depend *only* on the injected `TieRng` stream.

use std::collections::{BTreeMap, BTreeSet};

use vm_core::{
    ids::OptionId,
    entities::OptionItem,
    rng::TieRng,
    variables::TiePolicy,
};

#[derive(Copy, Clone, Eq, PartialEq, Debug)]
pub enum QuotaKind {
    Hare,
    Droop,
    Imperiali,
}

#[derive(Debug)]
pub enum AllocError {
    /// After threshold filtering, no options remain eligible while seats > 0.
    NoEligibleOptions,
    /// Policy was Random but no RNG was supplied (and seats > 0).
    MissingRngForRandomPolicy,
}

/// Allocate seats using Largest Remainder with a selected quota.
///
/// Notes:
/// - If `seats == 0`, returns an empty map.
/// - Keys missing from `scores` are treated as 0 (they rarely pass a positive threshold).
pub fn allocate_largest_remainder(
    seats: u32,
    scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem], // canonical (order_index, id)
    threshold_pct: u8,
    quota: QuotaKind,
    tie_policy: TiePolicy,
    mut rng: Option<&mut TieRng>,
) -> Result<BTreeMap<OptionId, u32>, AllocError> {
    if seats == 0 {
        return Ok(BTreeMap::new());
    }
    if matches!(tie_policy, TiePolicy::Random) && rng.is_none() {
        return Err(AllocError::MissingRngForRandomPolicy);
    }

    let eligible = filter_by_threshold(scores, threshold_pct);
    if eligible.is_empty() {
        return Err(AllocError::NoEligibleOptions);
    }

    let total: u128 = eligible.values().map(|&v| v as u128).sum();
    let q = compute_quota(total, seats as u128, quota);

    let (mut alloc, remainders) = floors_and_remainders(&eligible, q);

    // Sum floors (u128 to avoid intermediate growth) and compare with seats.
    let sum_floors: u128 = alloc.values().map(|&s| s as u128).sum();

    if sum_floors < seats as u128 {
        let needed = (seats as u128 - sum_floors) as u32;
        distribute_leftovers(
            needed,
            &mut alloc,
            &remainders,
            &eligible,
            options,
            tie_policy,
            rng.as_deref_mut(),
        );
    } else if sum_floors > seats as u128 {
        // Imperiali (or degenerate q) may over-allocate in floors.
        trim_over_allocation_if_needed(
            seats,
            &mut alloc,
            &remainders,
            &eligible,
            options,
            tie_policy,
            rng.as_deref_mut(),
        );
    }

    debug_assert_eq!(
        alloc.values().map(|&s| s as u128).sum::<u128>(),
        seats as u128
    );
    Ok(alloc)
}

/// Keep options whose natural share meets threshold: 100*v >= threshold_pct*total (u128 math).
fn filter_by_threshold(
    scores: &BTreeMap<OptionId, u64>,
    threshold_pct: u8,
) -> BTreeMap<OptionId, u64> {
    let total: u128 = scores.values().map(|&v| v as u128).sum();
    if threshold_pct == 0 {
        return scores.clone();
    }
    let t = threshold_pct as u128;
    scores
        .iter()
        .filter_map(|(k, &v)| {
            let v128 = v as u128;
            if v128.saturating_mul(100) >= t.saturating_mul(total) {
                Some((k.clone(), v))
            } else {
                None
            }
        })
        .collect()
}

/// Integer-only quota.
/// Hare: floor(V / m)
/// Droop: floor(V / (m + 1)) + 1
/// Imperiali: floor(V / (m + 2))
fn compute_quota(total: u128, seats: u128, quota: QuotaKind) -> u128 {
    match quota {
        QuotaKind::Hare => {
            if seats == 0 { 0 } else { total / seats }
        }
        QuotaKind::Droop => {
            // floor(V/(m+1)) + 1 ; seats > 0 in caller
            (total / (seats + 1)) + 1
        }
        QuotaKind::Imperiali => {
            // floor(V/(m+2))
            total / (seats + 2)
        }
    }
}

/// Compute floors and remainders given quota q (u128 math; q==0 handled).
fn floors_and_remainders(
    eligible: &BTreeMap<OptionId, u64>,
    q: u128,
) -> (BTreeMap<OptionId, u32>, BTreeMap<OptionId, u128>) {
    let mut floors: BTreeMap<OptionId, u32> = BTreeMap::new();
    let mut rems: BTreeMap<OptionId, u128> = BTreeMap::new();

    for (id, &v) in eligible {
        let v128 = v as u128;
        if q == 0 {
            floors.insert(id.clone(), 0);
            rems.insert(id.clone(), v128);
        } else {
            let f128 = v128 / q;
            // Saturate to u32::MAX; in practice seats bound this far below.
            let f = if f128 > (u32::MAX as u128) {
                u32::MAX
            } else {
                f128 as u32
            };
            let r = v128 % q;
            floors.insert(id.clone(), f);
            rems.insert(id.clone(), r);
        }
    }

    (floors, rems)
}

/// Assign remaining seats by largest remainder; ties per policy
/// (remainder ↓, raw score ↓, canonical (order_index, id); StatusQuo→deterministic; Random uses rng).
fn distribute_leftovers(
    target_extra: u32,
    alloc: &mut BTreeMap<OptionId, u32>,
    remainders: &BTreeMap<OptionId, u128>,
    scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
    tie_policy: TiePolicy,
    mut rng: Option<&mut TieRng>,
) {
    for _ in 0..target_extra {
        // Find max remainder among eligible keys.
        let mut max_r: Option<u128> = None;
        let mut max_ids: Vec<OptionId> = Vec::new();

        for opt in options {
            if let Some(&r) = remainders.get(&opt.option_id) {
                match max_r {
                    None => {
                        max_r = Some(r);
                        max_ids.clear();
                        max_ids.push(opt.option_id.clone());
                    }
                    Some(mr) => {
                        if r > mr {
                            max_r = Some(r);
                            max_ids.clear();
                            max_ids.push(opt.option_id.clone());
                        } else if r == mr {
                            max_ids.push(opt.option_id.clone());
                        }
                    }
                }
            }
        }

        let winner = if max_ids.len() <= 1 {
            max_ids[0].clone()
        } else {
            // Narrow by raw score desc
            let mut best_score: Option<u64> = None;
            let mut narrowed: Vec<OptionId> = Vec::new();
            for id in &max_ids {
                let sc = *scores.get(id).unwrap_or(&0);
                match best_score {
                    None => {
                        best_score = Some(sc);
                        narrowed.clear();
                        narrowed.push(id.clone());
                    }
                    Some(bs) => {
                        if sc > bs {
                            best_score = Some(sc);
                            narrowed.clear();
                            narrowed.push(id.clone());
                        } else if sc == bs {
                            narrowed.push(id.clone());
                        }
                    }
                }
            }
            if narrowed.len() <= 1 {
                narrowed[0].clone()
            } else {
                match tie_policy {
                    TiePolicy::StatusQuo => status_quo_pick(&narrowed, options),
                    TiePolicy::DeterministicOrder => deterministic_pick(&narrowed, options),
                    TiePolicy::Random => {
                        let n = narrowed.len() as u64;
                        let idx = rng
                            .as_deref_mut()
                            .expect("rng must be provided for Random policy")
                            .gen_range(n)
                            .unwrap_or(0) as usize;
                        narrowed[idx].clone()
                    }
                }
            }
        };

        *alloc.entry(winner).or_insert(0) += 1;
    }
}

/// Imperiali edge: if floors sum > target, trim from smallest remainder until sum == target.
/// Ties resolved using inverse of distribute ranking (remainder ↑, raw score ↑, then canonical),
/// with StatusQuo→deterministic; Random uses rng.
fn trim_over_allocation_if_needed(
    target_seats: u32,
    alloc: &mut BTreeMap<OptionId, u32>,
    remainders: &BTreeMap<OptionId, u128>,
    scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
    tie_policy: TiePolicy,
    mut rng: Option<&mut TieRng>,
) -> bool {
    let mut changed = false;

    let mut total: u128 = alloc.values().map(|&s| s as u128).sum();
    while total > target_seats as u128 {
        // Consider only options with at least one seat to trim.
        let mut min_r: Option<u128> = None;
        let mut cand_ids: Vec<OptionId> = Vec::new();

        for opt in options {
            if let Some(&s) = alloc.get(&opt.option_id) {
                if s == 0 {
                    continue;
                }
                let r = *remainders.get(&opt.option_id).unwrap_or(&0);
                match min_r {
                    None => {
                        min_r = Some(r);
                        cand_ids.clear();
                        cand_ids.push(opt.option_id.clone());
                    }
                    Some(mr) => {
                        if r < mr {
                            min_r = Some(r);
                            cand_ids.clear();
                            cand_ids.push(opt.option_id.clone());
                        } else if r == mr {
                            cand_ids.push(opt.option_id.clone());
                        }
                    }
                }
            }
        }

        // On tie, prefer smaller raw score (inverse of leftovers), then canonical order.
        let loser = if cand_ids.len() <= 1 {
            cand_ids[0].clone()
        } else {
            let mut best_score: Option<u64> = None; // but now "best" means *smallest*
            let mut narrowed: Vec<OptionId> = Vec::new();
            for id in &cand_ids {
                let sc = *scores.get(id).unwrap_or(&0);
                match best_score {
                    None => {
                        best_score = Some(sc);
                        narrowed.clear();
                        narrowed.push(id.clone());
                    }
                    Some(bs) => {
                        if sc < bs {
                            best_score = Some(sc);
                            narrowed.clear();
                            narrowed.push(id.clone());
                        } else if sc == bs {
                            narrowed.push(id.clone());
                        }
                    }
                }
            }
            if narrowed.len() <= 1 {
                narrowed[0].clone()
            } else {
                match tie_policy {
                    TiePolicy::StatusQuo => status_quo_pick(&narrowed, options),
                    TiePolicy::DeterministicOrder => deterministic_pick(&narrowed, options),
                    TiePolicy::Random => {
                        let n = narrowed.len() as u64;
                        let idx = rng
                            .as_deref_mut()
                            .expect("rng must be provided for Random policy")
                            .gen_range(n)
                            .unwrap_or(0) as usize;
                        narrowed[idx].clone()
                    }
                }
            }
        };

        if let Some(s) = alloc.get_mut(&loser) {
            *s -= 1;
            changed = true;
            total -= 1;
        } else {
            // Should not happen; defensive break to avoid infinite loop.
            break;
        }
    }

    changed
}

// ----------------- tie helpers -----------------

/// Deterministic pick: first in canonical `(order_index, option_id)` among `tied`.
fn deterministic_pick(tied: &[OptionId], options: &[OptionItem]) -> OptionId {
    let set: BTreeSet<&OptionId> = tied.iter().collect();
    for o in options {
        if set.contains(&o.option_id) {
            return o.option_id.clone();
        }
    }
    // Defensive fallback (should not occur given inputs).
    tied.iter().min().cloned().expect("non-empty tied")
}

/// Status-quo resolver: core `OptionItem` has no SQ flag, so fall back to deterministic.
fn status_quo_pick(tied: &[OptionId], options: &[OptionItem]) -> OptionId {
    deterministic_pick(tied, options)
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/mmp.rs
--------------------------------------------------------------------------------
//! Mixed-Member Proportional (MMP) helpers:
//! - compute total seats from a top-up share (VM-VAR-013) with half-even rounding,
//! - apportion targets using highest-averages (D’Hondt or Sainte-Laguë),
//! - compute top-ups against local seats and apply overhang policy/model,
//! - one-shot orchestration for a correction scope.
//!
//! Determinism: stable OptionId order is used for all deterministic tie breaks;
//! no RNG is used anywhere in MMP.

use std::collections::BTreeMap;

use vm_core::{
    ids::OptionId,
    variables::{AllocationMethod, OverhangPolicy, Params, TotalSeatsModel},
    rounding::round_nearest_even_int,
};

/// Result bundle for an MMP correction step.
#[derive(Debug, Clone)]
pub struct MmpOutcome {
    pub targets: BTreeMap<OptionId, u32>,
    pub topups: BTreeMap<OptionId, u32>,
    pub finals: BTreeMap<OptionId, u32>,
    pub effective_total_seats: u32,
    pub overhang_by_option: BTreeMap<OptionId, u32>,
}

/// Compute intended total seats `T` from local seats `L` and top-up share `p%`
/// using banker's (half-even) rounding on `T = (L*100) / (100 - p)`.
///
/// Domain: upstream enforces `p <= 60` (and `< 100` in general).
pub fn compute_total_from_share(local_total: u32, topup_share_pct: u8) -> u32 {
    // Guard against pathological input; upstream should prevent p >= 100.
    if topup_share_pct >= 100 {
        return 0;
    }
    let num = (local_total as i128) * 100;
    let den = (100u8.saturating_sub(topup_share_pct) as i128).max(1);
    // round_nearest_even_int never panics for den > 0.
    match round_nearest_even_int(num, den) {
        Ok(v) if v <= u32::MAX as i128 => v as u32,
        Ok(_) => u32::MAX,
        Err(_) => 0,
    }
}

/// Apportion `total_seats` to options from `vote_totals` via a highest-averages method.
/// Deterministic, integer-only; ties broken by lexicographic `OptionId`.
pub fn apportion_targets(
    total_seats: u32,
    vote_totals: &BTreeMap<OptionId, u64>,
    method: AllocationMethod,
) -> BTreeMap<OptionId, u32> {
    let mut alloc: BTreeMap<OptionId, u32> =
        vote_totals.keys().cloned().map(|k| (k, 0u32)).collect();

    if total_seats == 0 || vote_totals.is_empty() {
        return alloc;
    }

    for _ in 0..total_seats {
        // Choose arg-max of quotient v / d(s); ties by OptionId ascending.
        let mut best_id: OptionId = OptionId::from(String::new()); // temp init; will overwrite
        let mut have_best = false;
        let mut best_v: u64 = 0;
        let mut best_d: u128 = 1;

        for (id, &v) in vote_totals.iter() {
            let s = *alloc.get(id).unwrap_or(&0);
            let d = divisor(method, s);
            // Compare v/d vs best_v/best_d via cross-multiplication: v*best_d ? best_v*d
            let left = (v as u128).saturating_mul(best_d);
            let right = (best_v as u128).saturating_mul(d);
            let better = if !have_best {
                true
            } else if left > right {
                true
            } else if left < right {
                false
            } else {
                // exact tie on quotient → smallest OptionId
                id < &best_id
            };

            if better {
                best_id = id.clone();
                best_v = v;
                best_d = d;
                have_best = true;
            }
        }

        if have_best {
            *alloc.get_mut(&best_id).unwrap() += 1;
        } else {
            // No votes at all: nothing to apportion.
            break;
        }
    }

    alloc
}

/// Given intended `targets` and `local_seats`, compute top-ups and apply the
/// chosen overhang policy/model. When policy requires re-apportionment or
/// expansion, uses `method_for_targets` on `vote_totals`.
pub fn compute_topups_and_apply_overhang(
    targets: &BTreeMap<OptionId, u32>,
    local_seats: &BTreeMap<OptionId, u32>,
    overhang_policy: OverhangPolicy,
    _total_seats_model: TotalSeatsModel,
    method_for_targets: AllocationMethod,
    vote_totals: &BTreeMap<OptionId, u64>,
) -> MmpOutcome {
    // Union of all option IDs present.
    let mut all_ids: BTreeMap<OptionId, ()> = BTreeMap::new();
    for k in targets.keys() {
        all_ids.insert(k.clone(), ());
    }
    for k in local_seats.keys() {
        all_ids.insert(k.clone(), ());
    }
    for k in vote_totals.keys() {
        all_ids.insert(k.clone(), ());
    }

    // Helpers
    let mut target_sum: u128 = 0;
    let mut local_sum: u128 = 0;

    for k in all_ids.keys() {
        target_sum += (*targets.get(k).unwrap_or(&0)) as u128;
        local_sum += (*local_seats.get(k).unwrap_or(&0)) as u128;
    }

    // Compute per-option deficits and overhangs on the current targets.
    let mut deficits: BTreeMap<OptionId, u32> = BTreeMap::new();
    let mut overhangs: BTreeMap<OptionId, u32> = BTreeMap::new();
    for k in all_ids.keys() {
        let t = *targets.get(k).unwrap_or(&0);
        let l = *local_seats.get(k).unwrap_or(&0);
        if t >= l {
            deficits.insert(k.clone(), t - l);
            overhangs.insert(k.clone(), 0);
        } else {
            deficits.insert(k.clone(), 0);
            overhangs.insert(k.clone(), l - t);
        }
    }

    match overhang_policy {
        OverhangPolicy::AllowOverhang => {
            // Top-ups exactly cover deficits; final total = T + Σ overhang.
            let mut topups = BTreeMap::new();
            let mut finals = BTreeMap::new();
            let mut eff_total: u128 = target_sum;

            for k in all_ids.keys() {
                let up = *deficits.get(k).unwrap_or(&0);
                let l = *local_seats.get(k).unwrap_or(&0);
                let oh = *overhangs.get(k).unwrap_or(&0);
                topups.insert(k.clone(), up);
                finals.insert(k.clone(), l.saturating_add(up));
                eff_total = eff_total.saturating_add(oh as u128);
            }

            MmpOutcome {
                targets: targets.clone(),
                topups,
                finals,
                effective_total_seats: (eff_total.min(u32::MAX as u128)) as u32,
                overhang_by_option: overhangs,
            }
        }

        OverhangPolicy::CompensateOthers => {
            // Fixed house size = T. Pool seats = T - Σ local.
            let pool = if target_sum > local_sum {
                (target_sum - local_sum) as u32
            } else {
                0
            };

            // Eligible for top-ups: options without overhang (deficit > 0).
            // We iteratively award up to `deficit_i` seats using highest-averages on vote_totals.
            let mut assigned: BTreeMap<OptionId, u32> =
                all_ids.keys().cloned().map(|k| (k, 0u32)).collect();

            if pool > 0 {
                // Work on a filtered vote vector (only deficit > 0 contribute);
                // if all zeros, the loop will just assign nothing (finals = locals).
                let eligible: BTreeMap<OptionId, u64> = all_ids
                    .keys()
                    .filter_map(|k| {
                        let cap = *deficits.get(k).unwrap_or(&0);
                        if cap > 0 {
                            Some((
                                k.clone(),
                                *vote_totals.get(k).unwrap_or(&0), // may be 0
                            ))
                        } else {
                            None
                        }
                    })
                    .collect();

                if !eligible.is_empty() {
                    // Seat-by-seat highest-averages (deterministic), capped by remaining deficit.
                    for _ in 0..pool {
                        let mut pick: OptionId = OptionId::from(String::new());
                        let mut have_pick = false;
                        let mut best_v: u64 = 0;
                        let mut best_d: u128 = 1;

                        for (id, &v) in eligible.iter() {
                            let already = *assigned.get(id).unwrap_or(&0);
                            let cap = *deficits.get(id).unwrap_or(&0);
                            if already >= cap {
                                continue; // capacity reached
                            }
                            let d = divisor(method_for_targets, already);
                            let left = (v as u128).saturating_mul(best_d);
                            let right = (best_v as u128).saturating_mul(d);
                            let better = if !have_pick {
                                true
                            } else if left > right {
                                true
                            } else if left < right {
                                false
                            } else {
                                id < &pick
                            };
                            if better {
                                pick = id.clone();
                                best_v = v;
                                best_d = d;
                                have_pick = true;
                            }
                        }

                        if have_pick {
                            *assigned.get_mut(&pick).unwrap() += 1;
                        } else {
                            // No eligible seat can be assigned (all caps reached or no votes).
                            break;
                        }
                    }
                }
            }

            let mut topups = BTreeMap::new();
            let mut finals = BTreeMap::new();
            for k in all_ids.keys() {
                let add = *assigned.get(k).unwrap_or(&0);
                let l = *local_seats.get(k).unwrap_or(&0);
                // Overhang options get 0 top-ups in this policy.
                topups.insert(k.clone(), add);
                finals.insert(k.clone(), l.saturating_add(add));
            }

            MmpOutcome {
                targets: targets.clone(),
                topups,
                finals,
                effective_total_seats: (target_sum.min(u32::MAX as u128)) as u32,
                overhang_by_option: overhangs,
            }
        }

        OverhangPolicy::AddTotalSeats => {
            // Expand total seats minimally until targets >= locals component-wise.
            let mut tk = (target_sum.min(u32::MAX as u128)) as u32;
            // Safety: ensure at least current locals.
            let local_total_u32 = (local_sum.min(u32::MAX as u128)) as u32;
            if tk < local_total_u32 {
                tk = local_total_u32;
            }

            // Minimal iterative growth (deterministic).
            loop {
                let t_k = apportion_targets(tk, vote_totals, method_for_targets);
                if all_ids.iter().all(|(k, _)| {
                    let l = *local_seats.get(k).unwrap_or(&0);
                    let t = *t_k.get(k).unwrap_or(&0);
                    t >= l
                }) {
                    // Compute topups/finals using t_k.
                    let mut topups = BTreeMap::new();
                    let mut finals = BTreeMap::

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/gates_frontier.rs
--------------------------------------------------------------------------------
//! crates/vm_algo/src/gates_frontier.rs
//! Decision gates (quorum → national majority → optional double-majority → symmetry)
//! and, when passed, frontier mapping (bands, contiguity & flags). Pure integer math,
//! deterministic ordering, no RNG (ties live elsewhere).

use alloc::collections::{BTreeMap, BTreeSet, VecDeque};

use vm_core::{
    ids::UnitId,
    rounding::ge_percent, // integer test: a/b >= p%
    variables::Params,
};

/// Inputs required by the gate checks (aggregates + per-unit basics).
#[derive(Clone, Debug, Default)]
pub struct GateInputs {
    pub nat_ballots_cast: u64,
    pub nat_invalid_ballots: u64,
    pub nat_valid_ballots: u64,
    pub nat_eligible_roll: u64,

    /// Per-region valid ballots and support for change (aggregated upstream).
    pub region_valid_ballots: BTreeMap<String, u64>,
    pub region_support_for_change: BTreeMap<String, u64>,

    /// Per-unit basics for quorum and support.
    pub unit_valid_ballots: BTreeMap<UnitId, u64>,
    pub unit_ballots_cast: BTreeMap<UnitId, u64>,
    pub unit_eligible_roll: BTreeMap<UnitId, u64>,
    /// Numerator for approval/support rate per unit (denominator is valid_ballots, per spec).
    pub unit_support_for_change: BTreeMap<UnitId, u64>,
}

/// Outcome of decision gates (used by pipeline to decide whether to run frontier).
#[derive(Clone, Debug, Default)]
pub struct GateResult {
    pub quorum_national: bool,
    /// Units meeting per-unit quorum (021). A policy outside this module decides how to use it.
    pub quorum_per_unit_passset: BTreeSet<UnitId>,
    pub majority_national: bool,
    pub majority_regional: bool, // meaningful iff double_majority enabled
    pub double_majority: bool,
    pub symmetry: bool,
    pub pass: bool,
}

/// Inputs for the frontier mapping step (execute only if gates.pass == true).
#[derive(Clone, Debug, Default)]
pub struct FrontierInputs {
    /// Observed per-unit support ratios: (numerator, denominator).
    pub unit_support_for_change: BTreeMap<UnitId, (u64, u64)>,
    /// Universe of units considered (post-scope).
    pub units_all: BTreeSet<UnitId>,
    /// Undirected adjacency edges with typed kind.
    pub adjacency: Vec<(UnitId, UnitId, FrontierEdge)>,
    /// Units that are protected; if their assigned status would imply change, apply override.
    pub protected_units: BTreeSet<UnitId>,
}

/// Edge kinds allowed when checking contiguity (subset chosen by VM-VAR-047/048).
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]
pub enum FrontierEdge {
    Land,
    Bridge,
    Water,
}

/// Per-unit flags emitted with the assigned frontier status.
#[derive(Clone, Debug, Default)]
pub struct FrontierFlags {
    pub contiguity_ok: bool,
    pub mediation_flagged: bool,
    pub protected_override_used: bool,
    pub enclave: bool,
}

/// Per-unit frontier result (status string drawn from configured bands).
#[derive(Clone, Debug, Default)]
pub struct FrontierUnit {
    pub status: alloc::string::String,
    pub flags: FrontierFlags,
}

/// Frontier summary for quick reporting/labelling hooks.
#[derive(Clone, Debug, Default)]
pub struct FrontierSummary {
    pub band_counts: BTreeMap<alloc::string::String, u32>,
    pub mediation_units: u32,
    pub enclave_units: u32,
    pub any_protected_override: bool,
}

/// Full frontier mapping output.
#[derive(Clone, Debug, Default)]
pub struct FrontierOut {
    /// Stable map keyed by UnitId (ordered).
    pub units: BTreeMap<UnitId, FrontierUnit>,
    pub summary: FrontierSummary,
}

// ---------------- Gates (020–029; majority uses valid_ballots as denominator) -------------------

/// Apply quorum + majority (+ optional double-majority & symmetry) deterministically.
pub fn apply_decision_gates(inp: &GateInputs, p: &Params) -> GateResult {
    // Quorum (national): Σ ballots_cast / Σ eligible_roll ≥ 020
    let quorum_nat = compute_quorum_national(inp.nat_ballots_cast, inp.nat_eligible_roll, p.quorum_global_pct_020());

    // Per-unit quorum (021): collect pass set
    let quorum_set = compute_quorum_per_unit(
        &inp.unit_ballots_cast,
        &inp.unit_eligible_roll,
        p.quorum_per_unit_pct_021(),
    );

    // National approval majority (022): approvals_for_change / valid_ballots ≥ cutoff
    // Denominator is *valid_ballots* (explicitly ignores blank toggle for approval majority).
    let nat_support_sum: u64 = inp.unit_support_for_change.values().copied().sum();
    let maj_nat = national_approval_majority(inp.nat_valid_ballots, nat_support_sum, p.national_majority_pct_022());

    // Double-majority (024/023) over affected family:
    // Aggregate region totals using region_* maps. If no regions, treat as not applicable=false.
    let mut maj_regional = false;
    if p.double_majority_enabled_024() {
        let v_sum: u64 = inp.region_valid_ballots.values().copied().sum();
        let s_sum: u64 = inp.region_support_for_change.values().copied().sum();
        // Same share definition as national: support / valid_ballots.
        maj_regional = v_sum > 0 && ge_percent(s_sum, v_sum, p.regional_majority_pct_023());
    }

    let dbl = if p.double_majority_enabled_024() { maj_nat && maj_regional } else { maj_nat };

    // Symmetry (025/029). Without deeper policy here, enforce the toggle: when enabled,
    // we currently synthesize `true` unless explicit exceptions require failing symmetry.
    // Exception matching belongs to params policy; treat “no exceptions” == symmetric.
    let symmetry = if p.symmetry_enabled_025() {
        // If there are explicit symmetry exceptions and policy marks them as breaking symmetry,
        // params should reflect that via a boolean. Use permissive default: true.
        !p.symmetry_breaks_due_to_exceptions_029()
    } else {
        true
    };

    let pass = quorum_nat && dbl && symmetry;

    GateResult {
        quorum_national: quorum_nat,
        quorum_per_unit_passset: quorum_set,
        majority_national: maj_nat,
        majority_regional: maj_regional,
        double_majority: dbl,
        symmetry,
        pass,
    }
}

/// turnout ≥ cutoff? (a/b ≥ p%)
#[inline]
fn compute_quorum_national(ballots_cast: u64, eligible_roll: u64, cutoff_pct: u8) -> bool {
    eligible_roll > 0 && ge_percent(ballots_cast, eligible_roll, cutoff_pct)
}

/// For each unit, test turnout ≥ cutoff and return the pass set.
fn compute_quorum_per_unit(
    unit_ballots_cast: &BTreeMap<UnitId, u64>,
    unit_eligible_roll: &BTreeMap<UnitId, u64>,
    cutoff_pct: u8,
) -> BTreeSet<UnitId> {
    let mut out = BTreeSet::new();
    for (u, cast) in unit_ballots_cast {
        if let Some(roll) = unit_eligible_roll.get(u) {
            if *roll > 0 && ge_percent(*cast, *roll, cutoff_pct) {
                out.insert(u.clone());
            }
        }
    }
    out
}

/// approval majority is approvals_for_change / valid_ballots ≥ cutoff (fixed denominator).
#[inline]
fn national_approval_majority(valid_ballots: u64, approvals_for_change: u64, cutoff_pct: u8) -> bool {
    valid_ballots > 0 && ge_percent(approvals_for_change, valid_ballots, cutoff_pct)
}

// ---------------- Frontier (040–042, 047–049) --------------------------------------------------

/// Map per-unit support to band statuses, then flag contiguity/mediation/protection/enclaves.
/// Call this only if `gates.pass == true`.
pub fn map_frontier(inp: &FrontierInputs, p: &Params) -> FrontierOut {
    use alloc::string::String;

    let mut out = FrontierOut::default();

    // Fast escape: mode = none ⇒ everyone “none”, no flags.
    if p.frontier_mode_is_none_040() {
        for u in &inp.units_all {
            out.units.insert(
                u.clone(),
                FrontierUnit {
                    status: String::from("none"),
                    flags: FrontierFlags::default(),
                },
            );
        }
        return summarize_frontier(out);
    }

    // Bands come ordered, non-overlapping; compare using integer tenths (no floats).
    let bands = p.frontier_bands_042(); // Vec<(min_pct: u8, max_pct: u8, status: String)>
    let bands_tenths: alloc::vec::Vec<(u16, u16, String)> = bands
        .into_iter()
        .map(|(lo, hi, s)| ((lo as u16) * 10, (hi as u16) * 10, s))
        .collect();

    // Allowed edge kinds for contiguity.
    let mut allowed: BTreeSet<FrontierEdge> = BTreeSet::new();
    if p.frontier_allow_land_047() {
        allowed.insert(FrontierEdge::Land);
    }
    if p.frontier_allow_bridge_047() {
        allowed.insert(FrontierEdge::Bridge);
    }
    if p.frontier_allow_water_047() {
        allowed.insert(FrontierEdge::Water);
    }

    // Assign statuses.
    for u in &inp.units_all {
        let (num, den) = inp.unit_support_for_change.get(u).copied().unwrap_or((0, 0));
        let pct_tenths: u16 = if den == 0 {
            0
        } else {
            // floor((num * 1000) / den) — integer tenths
            ((num.saturating_mul(1000)) / den).min(u16::MAX as u64) as u16
        };
        let status = assign_band_status(pct_tenths, &bands_tenths);
        out.units.insert(
            u.clone(),
            FrontierUnit {
                status,
                flags: FrontierFlags::default(),
            },
        );
    }

    // Contiguity & mediation flags:
    // Build induced subgraphs per status and check if they form >1 connected components.
    let adjacency = &inp.adjacency;
    let by_status: BTreeMap<_, BTreeSet<_>> = {
        let mut map = BTreeMap::<String, BTreeSet<UnitId>>::new();
        for (u, fu) in &out.units {
            map.entry(fu.status.clone()).or_default().insert(u.clone());
        }
        map
    };

    for (status, members) in &by_status {
        if status == "none" {
            continue;
        }
        // Connected components among members using allowed edges only.
        let comps = contiguous_components(&allowed, adjacency, members);

        // Mark contiguity_ok for members in any component; mediation if more than one component.
        let many = comps.len() > 1;
        for comp in &comps {
            for u in comp {
                if let Some(unit) = out.units.get_mut(u) {
                    unit.flags.contiguity_ok = true;
                    unit.flags.mediation_flagged |= many;
                }
            }
        }
    }

    // Island/corridor refinement (048): if ferry_allowed, treat bridge+water as admissible.
    // We already honored allowed set above, so when ferry_allowed, ensure Bridge/Water were added.
    if p.frontier_island_rule_ferry_allowed_048() {
        // If earlier policy excluded Bridge/Water, we cannot recompute here
        // without re-running contiguity; conservative: if not allowed, we do a best-effort pass:
        // no extra action (policy should configure 047 accordingly).
    }

    // Protected overrides: downgrade status to "none" when protected.
    for u in &inp.protected_units {
        if let Some(unit) = out.units.get_mut(u) {
            if unit.status != "none" {
                unit.flags.protected_override_used = true;
                unit.status = String::from("none");
            }
        }
    }

    // Enclave flag: a unit whose neighbors (admissible edges) all have a different status.
    for (u, fu) in &out.units {
        if fu.status == "none" {
            continue;
        }
        let mut has_neighbor = false;
        let mut any_same = false;
        for (a, b, kind) in adjacency {
            if !allowed.contains(kind) {
                continue;
            }
            let (x, y) = (a, b);
            if x == u || y == u {
                let v = if x == u { y } else { x };
                if let Some(g) = out.units.get(v) {
                    has_neighbor = true;
                    if g.status == fu.status {
                        any_same = true;
                        break;
                    }
                }
            }
        }
        if let Some(me) = out.units.get_mut(u) {
            me.flags.enclave = has_neighbor && !any_same;
        }
    }

    summarize_frontier(out)
}

// ---------------- Internals ---------------------------------------------------------------------

fn assign_band_status(pct_tenths: u16, bands: &[(u16, u16, alloc::string::String)]) -> alloc::string::String {
    for (lo, hi, s) in bands {
        if *lo <= pct_tenths && pct_tenths <= *hi {
            return s.clone();
        }
    }
    // If no band matches, return the lowest-priority "none".
    alloc::string::String::from("none")
}

/// Return connected components among `members`, using only `allowed` edge kinds.
fn contiguous_components(
    allowed: &BTreeSet<FrontierEdge>,
    adjacency: &[(UnitId, UnitId, FrontierEdge)],
    members: &BTreeSet<UnitId>,
) -> alloc::vec::Vec<BTreeSet<UnitId>> {
    // Build adjacency list restricted to members + allowed edges
    let mut graph: BTreeMap<UnitId, alloc::vec::Vec<UnitId>> = BTreeMap::new();
    for u in members {
        graph.entry(u.clone()).or_default();
    }
    for (a, b, k) in adjacency {
        if !allowed.contains(k) {
            continue;
        }
        if members.contains(a) && members.contains(b) {
            graph.entry(a.clone()).or_default().push(b.clone());
            graph.entry(b.clone()).or_default().push(a.clone());
        }
    }

    // BFS over graph
    let mut seen: BTreeSet<UnitId> = BTreeSet::new();
    let mut comps: alloc::vec::Vec<BTreeSet<UnitId>> = alloc::vec::Vec::new();
    for u in members {
        if seen.contains(u) {
            continue;
        }
        let mut comp: BTreeSet<UnitId> = BTreeSet::new();
        let mut q = VecDeque::new();
        q.push_back(u.clone());
        seen.insert(u.clone());
        comp.insert(u.clone());

        while let Some(x) = q.pop_front() {
            if let Some(nei) = graph.get(&x) {
                for v in nei {
                    if seen.insert(v.clone()) {
                        q.push_back(v.clone());
                        comp.insert(v.clone());
                    }
                }
            }
        }
        comps.push(comp);
    }
    comps
}

fn summarize_frontier(mut out: FrontierOut) -> FrontierOut {
    // Fill summary counts and booleans.
    for (_, u) in &out.units {
        *out.summary.band_counts.entry(u.status.clone()).or_insert(0) += 1;
        if u.flags.mediation_flagged {
            out.summary.mediation_units += 1;
        }
        if u.flags.enclave {
            out.summary.enclave_units += 1;
        }
        if u.flags.protected_override_used {
            out.summary.any_protected_override = true;
        }
    }
    out
}

// ---------------- Param access helpers (thin; resolved by vm_core::variables::Params) -----------
//
// NOTE: These helpers assume `Params` exposes deterministic getters for the needed VM-VARs.
// Exact domains/defaults live in Annex A and Doc 2; this module reads them only at the
// documented touchpoints (4B gates, 4C frontier). See docs cited in the file header.

trait GatesFrontierParamView {
    // 020–029 (gates)
    fn quorum_global_pct_020(&self) -> u8;
    fn quorum_per_unit_pct_021(&self) -> u8;
    fn national_majority_pct_022(&self) -> u8;
    fn regional_majority_pct_023(&self) -> u8;
    fn double_majority_enabled_024(&self) -> bool;
    fn symmetry_enabled_025(&self) -> bool;
    fn symmetry_breaks_due_to_exceptions_029(&self) -> bool;

    // 040–042, 047–049 (frontier)
    fn frontier_mode_is_none_040(&self) -> bool;
    /// Ordered, non-overlapping bands: (min_pct, max_pct, status)
    fn frontier_bands_042(&self) -> alloc::vec::Vec<(u8, u8, alloc::string::String)>;
    fn frontier_allow_land_047(&self) -> bool;
    fn frontier_allow_bridge_047(&self) -> bool;
    fn frontier_allow_water_047(&self) -> bool;
    fn frontier_island_rule_ferry_allowed_048(&self) -> bool;
}

// This blanket impl simply forwards to assumed `Params` getters.
// Implement these methods in `vm_core::variables::Params` to satisfy the trait.
impl GatesFrontierParamView for Params {
    // --- gates ---
    #[inline] fn quorum_global_pct_020(&self) -> u8 { self.quorum_global_pct_020() }
    #[inline] fn quorum_per_unit_pct_021(&self) -> u8 { self.quorum_per_unit_pct_021() }
    #[inline] fn national_majority_pct_022(&self) -> u8 { self.national_majority_pct_022() }
    #[inline] fn regional_majority_pct_023(&self) -> u8 { self.regional_majority_pct_023() }
    #[inline] fn double_majority_enabled_024(&self) -> bool { self.double_majority_enabled_024() }
    #[inline] fn symmetry_enabled_025(&self) -> bool { self.symmetry_enabled_025() }
    #[inline] fn symmetry_breaks_due_to_exceptions_029(&self) -> bool { self.symmetry_breaks_due_to_exceptions_029() }

    // --- frontier ---
    #[inline] fn frontier_mode_is_none_040(&self) -> bool { self.frontier_mode_is_none_040() }
    #[inline] fn frontier_bands_042(&self) -> alloc::vec::Vec<(u8, u8, alloc::string::String)> { self.frontier_bands_042() }
    #[inline] fn frontier_allow_land_047(&self) -> bool { self.frontier_allow_land_047() }
    #[inline] fn frontier_allow_bridge_047(&self) -> bool { self.frontier_allow_bridge_047() }
    #[inline] fn frontier_allow_water_047(&self) -> bool { self.frontier_allow_water_047() }
    #[inline] fn frontier_island_rule_ferry_allowed_048(&self) -> bool { self.frontier_island_rule_ferry_allowed_048() }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Tiny stand-in Params to drive the helpers in tests.
    struct P;
    impl GatesFrontierParamView for P {
        fn quorum_global_pct_020(&self) -> u8 { 50 }
        fn quorum_per_unit_pct_021(&self) -> u8 { 40 }
        fn national_majority_pct_022(&self) -> u8 { 55 }
        fn regional_majority_pct_023(&self) -> u8 { 55 }
        fn double_majority_enabled_024(&self) -> bool { true }
        fn symmetry_enabled_025(&self) -> bool { false }
        fn symmetry_breaks_due_to_exceptions_029(&self) -> bool { false }

        fn frontier_mode_is_none_040(&self) -> bool { false }
        fn frontier_bands_042(&self) -> alloc::vec::Vec<(u8, u8, alloc::string::String)> {
            use alloc::string::String;
            vec![(0, 49, String::from("hold")), (50, 100, String::from("change"))]
        }
        fn frontier_allow_land_047(&self) -> bool { true }
        fn frontier_allow_bridge_047(&self) -> bool { false }
        fn frontier_allow_water_047(&self) -> bool { false }
        fn frontier_island_rule_ferry_allowed_048(&self) -> bool { false }
    }

    #[test]
    fn quorum_and_majority_basics() {
        let mut gi = GateInputs::default();
        gi.nat_ballots_cast = 600;
        gi.nat_eligible_roll = 1000;
        gi.nat_valid_ballots = 500;
        gi.unit_support_for_change.insert("U".parse().unwrap(), 300);
        gi.region_valid_ballots.insert("R".into(), 500);
        gi.region_support_for_change.insert("R".into(), 300);

        let p = P;
        let gr = apply_decision_gates(&gi, unsafe { core::mem::transmute::<&P, &Params>(&p) });
        assert!(gr.quorum_national);
        assert!(gr.majority_national);
        assert!(gr.double_majority);
        assert!(gr.pass);
    }

    #[test]
    fn frontier_bands_and_components() {
        use alloc::string::ToString;

        let u1: UnitId = "A".parse().unwrap();
        let u2: UnitId = "B".parse().unwrap();

        let mut fi = FrontierInputs::default();
        fi.units_all.extend([u1.clone(), u2.clone()]);
        fi.unit_support_for_change.insert(u1.clone(), (60, 100)); // 60%
        fi.unit_support_for_change.insert(u2.clone(), (40, 100)); // 40%
        fi.adjacency.push((u1.clone(), u2.clone(), FrontierEdge::Land));

        let p = P;
        let out = map_frontier(&fi, unsafe { core::mem::transmute::<&P, &Params>(&p) });
        assert_eq!(out.units.get(&u1).unwrap().status, "change".to_string());
        assert_eq!(out.units.get(&u2).unwrap().status, "hold".to_string());
        assert!(out.units.get(&u1).unwrap().flags.contiguity_ok);
        assert!(out.units.get(&u2).unwrap().flags.contiguity_ok);
    }
}

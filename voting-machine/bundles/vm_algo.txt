# bundle: vm_algo

--------------------------------------------------------------------------------
FILE: crates/vm_algo/Cargo.toml
--------------------------------------------------------------------------------
[package]
name = "vm_algo"
version = "0.1.0"
edition = "2021"
rust-version = "1.77"
license = "Apache-2.0 OR MIT"
description = "Algorithm layer: tabulation, seat allocation, gates/frontier; depends only on vm_core."
# repository = "..."; readme = "README.md"

[lib]
name = "vm_algo"
path = "src/lib.rs"
crate-type = ["rlib"]

[features]
# Keep this crate algorithmic-only; features gate families without changing public types.
default     = ["std", "tab_ranked", "tab_score", "pr_methods", "mmp", "gates", "frontier"]
std         = []
tab_ranked  = []
tab_score   = []
pr_methods  = []
mmp         = []
gates       = []
frontier    = []

[dependencies]
vm_core = { path = "../vm_core" }  # RNG and rounding come from vm_core

[dev-dependencies]
proptest    = "1"      # property tests
rand_chacha = "0.3"    # tests only; runtime RNG is vm_core::rng

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/lib.rs
--------------------------------------------------------------------------------
// crates/vm_algo/src/lib.rs
#![forbid(unsafe_code)]
#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

use alloc::collections::BTreeMap;

// Core IDs and basic tallies
pub use vm_core::{
    entities::TallyTotals as Turnout,
    ids::{OptionId, UnitId},
};

// ----------------------------- Canonical per-unit scores -----------------------------

/// Raw scores per unit (plurality votes, approvals, score sums, or ranked outputs).
/// Downstream emission must follow registry order; keep scores keyed by OptionId.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct UnitScores {
    pub unit_id: UnitId,
    pub turnout: Turnout,
    pub scores: BTreeMap<OptionId, u64>,
}

/// Allocation bundle (used by WTA or when a per-unit seat vector is needed).
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Allocation {
    pub unit_id: UnitId,
    /// Seats (PR) or 1 for the winner in WTA.
    pub seats_or_power: BTreeMap<OptionId, u32>,
    /// True iff a last seat/winner involved a tie break.
    pub last_seat_tie: bool,
}

// ----------------------------- Tabulation (public surface) ---------------------------

pub mod tabulation {
    // File modules (actual implementations)
    pub mod plurality;
    pub mod approval;
    pub mod score;
    pub mod ranked_irv;
    pub mod ranked_condorcet;

    // Re-export entry points and errors (simple tabulators are fallible).
    pub use approval::{tabulate_approval, TabError as ApprovalError};
    pub use plurality::{tabulate_plurality, TabError as PluralityError};
    pub use score::{tabulate_score, TabError as ScoreError};

    // Ranked tabulators + their audit types are exposed from their modules.
    pub use ranked_irv::{tabulate_ranked_irv, IrvLog, IrvRound};
    pub use ranked_condorcet::{
        tabulate_ranked_condorcet, CompletionRule, CondorcetLog, Pairwise,
    };
}

// Convenience re-exports (pipeline imports these from crate root)
pub use tabulation::{IrvLog, IrvRound, Pairwise};

// ----------------------------- Allocation (public surface) ---------------------------

pub mod allocation {
    // File modules (actual implementations)
    pub mod dhondt;
    pub mod sainte_lague;
    pub mod largest_remainder;
    pub mod wta;

    // Name aliases to match caller expectations:
    //  - keep the module definitions (allocate_*) as-is,
    //  - export pipeline-friendly names (dhondt_allocate, …) as plain aliases.
    pub use dhondt::allocate_dhondt as dhondt_allocate;
    pub use sainte_lague::allocate_sainte_lague as sainte_lague_allocate;
    pub use largest_remainder::allocate_largest_remainder as largest_remainder_allocate;
    pub use wta::allocate_wta;

    // Error type aliases for ergonomic matching in callers.
    pub type DhondtError = dhondt::AllocError;
    pub type SainteLagueError = sainte_lague::AllocError;
    pub type LrError = largest_remainder::AllocError;
    pub type WtaError = wta::AllocError;

    // Quota kind is needed by callers; re-export here and via `enums` shim below.
    pub use largest_remainder::QuotaKind;
}

// ----------------------------- Enums shim (caller ergonomics) ------------------------

/// Shims to keep external imports stable, e.g. `use vm_algo::enums::{LrQuotaKind, TiePolicy}`.
pub mod enums {
    pub use vm_core::variables::TiePolicy;
    pub use crate::allocation::QuotaKind as LrQuotaKind;
}

// ----------------------------- MMP & Gates/Frontier ---------------------------------

// File modules
pub mod mmp;
pub mod gates_frontier;

// Tight, explicit re-exports (avoid wildcard export drift).
pub use gates_frontier::{
    apply_decision_gates, map_frontier, FrontierEdge, FrontierFlags, FrontierIn,
    FrontierInputs, FrontierOut, FrontierSummary, FrontierUnit, GateInputs, GateOutcome,
    GateResult,
};

// Re-export MMP outcome type and helpers
pub use mmp::{compute_topups_and_apply_overhang, compute_total_from_share, apportion_targets, MmpOutcome};

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/tabulation/plurality.rs
--------------------------------------------------------------------------------
// crates/vm_algo/src/tabulation/plurality.rs
//
// Fixed implementation (deterministic, no_std-ready, registry-order aware).
//
// Key fixes vs previous version:
// - Preserves the Registry / `options` slice order via a Vec-returning API.
// - Keeps the BTreeMap-returning API for back-compat, but clarifies it is
//   sorted by OptionId (not registry order) and adds a helper that returns
//   registry order when needed.
// - Detects duplicate entries in `options` (dedicated error).
// - Adds per-option sanity check: count ≤ turnout.valid_ballots.
// - Keeps integer-first math: u128 accumulation for total to avoid overflow.
//
// Contract (aligned to Docs 1–7 + Annexes A–C):
// - Inputs are expected to be validated upstream; this function enforces the
//   invariants defensively and returns structured errors (no silent fixes).
// - No RNG, no I/O; stable ordering and pure integer arithmetic.
//
// NOTE: Adjust import paths (UnitId, OptionId, Turnout, TabError) to your tree.

#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

use alloc::collections::{BTreeMap, BTreeSet};
use alloc::vec::Vec;

// ---- Adjust these imports to your actual crate layout -----------------------
use crate::errors::TabError; // e.g., crate::errors::TabError or crate::error::TabError

// Example paths (rename to your real modules):
use vm_core::ids::{OptionId, UnitId}; // e.g., vm_core::ids::{OptionId, UnitId}
use vm_core::models::Turnout;         // e.g., vm_core::models::Turnout { valid_ballots: u64 }
// -----------------------------------------------------------------------------

/// Plurality tabulation that **preserves Registry order** (the order of `options`).
///
/// Returns a Vec of `(OptionId, votes)` in the exact order provided by `options`.
/// Use this when canonical, registry-driven ordering is required downstream.
pub fn tabulate_plurality_in_registry_order_vec(
    unit_id: UnitId,
    votes: &BTreeMap<OptionId, u64>,
    turnout: &Turnout,
    options: &[OptionId],
) -> Result<Vec<(OptionId, u64)>, TabError> {
    // Build a set of `options` and detect duplicates deterministically.
    let mut seen: BTreeSet<OptionId> = BTreeSet::new();
    for &opt in options.iter() {
        if !seen.insert(opt) {
            // Duplicate discovered in registry slice.
            return Err(TabError::DuplicateOptionInRegistry {
                unit_id,
                option_id: opt,
            });
        }
    }

    // Defensive: unknown options present in `votes`?
    // (Should be unreachable after upstream validation.)
    for (&opt, _) in votes.iter() {
        if !seen.contains(&opt) {
            return Err(TabError::UnknownOption {
                unit_id,
                option_id: opt,
            });
        }
    }

    // Defensive: missing options relative to registry order?
    // Spec prefers strict presence rather than "missing => 0".
    for &opt in options.iter() {
        if !votes.contains_key(&opt) {
            return Err(TabError::MissingOption {
                unit_id,
                option_id: opt,
            });
        }
    }

    // Per-option sanity: no single option may exceed valid ballots.
    for (&opt, &count) in votes.iter() {
        if count > turnout.valid_ballots {
            return Err(TabError::OptionVotesExceedValid {
                unit_id,
                option_id: opt,
                count,
                valid_ballots: turnout.valid_ballots,
            });
        }
    }

    // Integer-first total accumulation to avoid overflow.
    let mut sum_u128: u128 = 0;
    for &count in votes.values() {
        sum_u128 = sum_u128
            .checked_add(count as u128)
            .ok_or_else(|| TabError::ArithmeticOverflow {
                unit_id,
                context: "plurality: sum(votes) overflowed u128",
            })?;
    }

    if sum_u128 > (turnout.valid_ballots as u128) {
        return Err(TabError::TallyExceedsValid {
            unit_id,
            sum_votes: (if sum_u128 <= u128::from(u64::MAX) {
                sum_u128 as u64
            } else {
                u64::MAX
            }),
            valid_ballots: turnout.valid_ballots,
        });
    }

    // Build the result in **registry order**.
    let mut out: Vec<(OptionId, u64)> = Vec::with_capacity(options.len());
    for &opt in options.iter() {
        // safe due to missing-option check above
        let count = *votes.get(&opt).expect("checked: option exists");
        out.push((opt, count));
    }

    Ok(out)
}

/// Plurality tabulation that returns a map keyed by OptionId (sorted by key).
///
/// This preserves determinism but **not** the original registry order of `options`.
/// If you need registry order downstream, call
/// [`tabulate_plurality_in_registry_order_vec`] instead.
pub fn tabulate_plurality(
    unit_id: UnitId,
    votes: &BTreeMap<OptionId, u64>,
    turnout: &Turnout,
    options: &[OptionId],
) -> Result<BTreeMap<OptionId, u64>, TabError> {
    let vec_in_order =
        tabulate_plurality_in_registry_order_vec(unit_id, votes, turnout, options)?;

    // Collect into BTreeMap (sorted by OptionId). This is OK for callers that
    // do not rely on registry order from this function. Canonical ordering needs
    // the Vec API above or a dedicated reorder at the call site.
    let mut out: BTreeMap<OptionId, u64> = BTreeMap::new();
    for (opt, count) in vec_in_order {
        out.insert(opt, count);
    }
    Ok(out)
}

// ---- Error type expectation --------------------------------------------------
//
// This implementation expects `TabError` to provide the following variants.
// If your actual error enum differs, adjust the return sites accordingly.
//
// - UnknownOption { unit_id: UnitId, option_id: OptionId }
// - MissingOption { unit_id: UnitId, option_id: OptionId }
// - DuplicateOptionInRegistry { unit_id: UnitId, option_id: OptionId }
// - OptionVotesExceedValid { unit_id: UnitId, option_id: OptionId, count: u64, valid_ballots: u64 }
// - TallyExceedsValid { unit_id: UnitId, sum_votes: u64, valid_ballots: u64 }
// - ArithmeticOverflow { unit_id: UnitId, context: &'static str }
//
// -----------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/tabulation/approval.rs
--------------------------------------------------------------------------------
//! Approval tabulation (deterministic, integers-only).
//!
//! Inputs:
//! - `unit_id`: the unit identifier
//! - `approvals`: per-option approval counts (may omit options → treated as 0)
//! - `turnout`: per-unit totals { valid_ballots, invalid_ballots } (Doc 1B names)
//! - `options`: canonical option list ordered by (order_index, OptionId)
//!
//! Output:
//! - `UnitScores { unit_id, turnout, scores }` where `scores` is a `BTreeMap<OptionId, u64>`.
//!
//! Notes:
//! - Unknown option keys present in `approvals` are rejected.
//! - Per-option cap: approvals_for_option ≤ valid_ballots.
//! - Σ approvals may exceed valid_ballots (multiple approvals per ballot are allowed).
//! - No RNG, no floats. Downstream should iterate results using the provided
//!   canonical `options` slice to preserve on-wire order.

use alloc::collections::{BTreeMap, BTreeSet};

use vm_core::{
    entities::{OptionItem, TallyTotals},
    ids::{OptionId, UnitId},
};

use crate::UnitScores;

/// Tabulation errors for approval counting.
#[derive(Debug)]
pub enum TabError {
    /// `approvals` contained an option ID not present in the canonical `options` list.
    UnknownOption(OptionId),
    /// A single option's approvals exceeded the unit's `valid_ballots`.
    OptionExceedsValid {
        option: OptionId,
        approvals: u64,
        valid_ballots: u64,
    },
}

/// Deterministic approval tabulation (integers only; no RNG).
pub fn tabulate_approval(
    unit_id: UnitId,
    approvals: &BTreeMap<OptionId, u64>,
    turnout: TallyTotals,
    options: &[OptionItem],
) -> Result<UnitScores, TabError> {
    let scores = canonicalize_scores(approvals, options)?;
    check_per_option_caps(&scores, &turnout)?;
    Ok(UnitScores {
        unit_id,
        turnout,
        scores,
    })
}

/// Build a canonical score map from provided `approvals` and canonical `options`.
/// Iterates `options` in (order_index, OptionId) order; missing keys → 0;
/// rejects unknown keys present in `approvals`.
fn canonicalize_scores(
    approvals: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
) -> Result<BTreeMap<OptionId, u64>, TabError> {
    // Fast membership set for unknown-key detection (OWNED ids for robustness).
    let allowed: BTreeSet<OptionId> = options.iter().map(|o| o.option_id.clone()).collect();

    // Reject any approval keyed by an unknown option.
    if let Some((bad_id, _)) = approvals.iter().find(|(k, _)| !allowed.contains(*k)) {
        return Err(TabError::UnknownOption((*bad_id).clone()));
    }

    // Build scores by traversing options in canonical order.
    let mut scores: BTreeMap<OptionId, u64> = BTreeMap::new();
    for opt in options {
        let count = approvals.get(&opt.option_id).copied().unwrap_or(0);
        scores.insert(opt.option_id.clone(), count);
    }

    // Defensive: if upstream validation ever skipped ensuring the full option list,
    // this function would "heal" sparse inputs with zeros. Keep an assert to surface it in debug.
    debug_assert_eq!(
        scores.len(),
        options.len(),
        "canonicalize_scores: options length mismatch"
    );

    Ok(scores)
}

/// Sanity: per-option approvals must not exceed `valid_ballots`.
fn check_per_option_caps(
    scores: &BTreeMap<OptionId, u64>,
    turnout: &TallyTotals,
) -> Result<(), TabError> {
    let valid = turnout.valid_ballots;
    for (opt, &count) in scores {
        if count > valid {
            return Err(TabError::OptionExceedsValid {
                option: opt.clone(),
                approvals: count,
                valid_ballots: valid,
            });
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use alloc::vec;
    use vm_core::entities::OptionItem;

    fn opt(id: &str, idx: u16) -> OptionItem {
        OptionItem::new(
            id.parse().expect("opt id"),
            "name".to_string(),
            idx,
        )
        .expect("option")
    }

    #[test]
    fn happy_path_builds_scores_in_canonical_order() {
        let options = vec![opt("O-A", 0), opt("O-B", 1), opt("O-C", 2)];

        // Insertion order of approvals map is irrelevant.
        let mut approvals = BTreeMap::<OptionId, u64>::new();
        approvals.insert("O-B".parse().unwrap(), 20);
        approvals.insert("O-A".parse().unwrap(), 10);
        approvals.insert("O-C".parse().unwrap(), 40);

        let scores = canonicalize_scores(&approvals, &options).expect("ok");
        assert_eq!(scores.get(&"O-A".parse().unwrap()).copied(), Some(10));
        assert_eq!(scores.get(&"O-B".parse().unwrap()).copied(), Some(20));
        assert_eq!(scores.get(&"O-C".parse().unwrap()).copied(), Some(40));
    }

    #[test]
    fn missing_keys_are_zero_unknown_are_error() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut approvals = BTreeMap::<OptionId, u64>::new();
        approvals.insert("O-A".parse().unwrap(), 5);
        approvals.insert("O-X".parse().unwrap(), 1); // unknown

        let err = canonicalize_scores(&approvals, &options).unwrap_err();
        match err {
            TabError::UnknownOption(id) => assert_eq!(id.to_string(), "O-X"),
            _ => panic!("expected UnknownOption"),
        }
    }

    #[test]
    fn per_option_caps_block_when_valid_zero() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut approvals = BTreeMap::<OptionId, u64>::new();
        approvals.insert("O-A".parse().unwrap(), 1);
        approvals.insert("O-B".parse().unwrap(), 0);

        let scores = canonicalize_scores(&approvals, &options).expect("ok");
        let turnout = TallyTotals::new(0, 0);
        let err = check_per_option_caps(&scores, &turnout).unwrap_err();

        match err {
            TabError::OptionExceedsValid { option, approvals, valid_ballots } => {
                assert_eq!(option.to_string(), "O-A");
                assert_eq!(approvals, 1);
                assert_eq!(valid_ballots, 0);
            }
            _ => panic!("expected OptionExceedsValid"),
        }
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/tabulation/score.rs
--------------------------------------------------------------------------------
// --------------------------------------------------------------------------------
// FILE: crates/vm_algo/src/tabulation/score.rs
// --------------------------------------------------------------------------------
//! Score tabulation (deterministic, integers-only).
//!
//! Inputs:
//! - `unit_id`: the unit identifier
//! - `score_sums`: per-option **summed scores** (already aggregated upstream)
//! - `turnout`: per-unit totals { valid_ballots, invalid_ballots }
//! - `params`: typed parameter set (used for scale/normalization if defined per release)
//! - `options`: canonical option list ordered by (order_index, OptionId)
//!
//! Output:
//! - `UnitScores { unit_id, turnout, scores }` where `scores` is a `BTreeMap<OptionId, u64>`.
//!
//! Rules in this layer:
//! - Reject unknown option IDs in `score_sums` (must match `options` exactly).
//! - If `valid_ballots == 0`, all option sums must be 0.
//! - If a per-ballot max score exists in Params, enforce
//!   `sum_for_option <= valid_ballots * max_scale` (widened arithmetic).
//!
//! No RNG, no floats. Downstream should iterate results using the provided
//! canonical `options` slice to preserve on-wire order.

#![forbid(unsafe_code)]

extern crate alloc;

use alloc::collections::{BTreeMap, BTreeSet};

use vm_core::{
    entities::{OptionItem, TallyTotals},
    ids::{OptionId, UnitId},
    variables::Params,
};

use crate::UnitScores;

/// Tabulation errors for score counting.
#[derive(Debug)]
pub enum TabError {
    /// `score_sums` contained an option ID not present in `options`.
    UnknownOption(OptionId),
    /// Turnout says there are zero valid ballots but some option has a non-zero sum.
    InconsistentTurnout { non_zero_total: u64 },
    /// A single option's summed score exceeded the plausible cap: `valid_ballots * max_scale`.
    OptionExceedsCap {
        option: OptionId,
        sum: u64,
        cap: u128,
    },
    /// (Reserved) Invalid scale bounds in parameters, if enforced per release.
    InvalidScaleBounds,
}

/// Deterministic score tabulation (integers only; no RNG).
pub fn tabulate_score(
    unit_id: UnitId,
    score_sums: &BTreeMap<OptionId, u64>,
    turnout: TallyTotals,
    params: &Params,
    options: &[OptionItem],
) -> Result<UnitScores, TabError> {
    let scores = canonicalize_scores(score_sums, options)?;
    check_scale_and_caps(&scores, &turnout, params)?;
    Ok(UnitScores {
        unit_id,
        turnout,
        scores,
    })
}

/// Build a canonical score map from provided `score_sums` and canonical `options`.
/// Iterates `options` in (order_index, OptionId) order; missing keys → 0;
/// rejects unknown keys present in `score_sums`.
fn canonicalize_scores(
    score_sums: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
) -> Result<BTreeMap<OptionId, u64>, TabError> {
    // Membership set for unknown-key detection (own the keys to avoid lifetime pitfalls).
    let allowed: BTreeSet<OptionId> = options.iter().map(|o| o.option_id.clone()).collect();

    // Reject any score keyed by an unknown option.
    for (k, _) in score_sums.iter() {
        if !allowed.contains(k) {
            return Err(TabError::UnknownOption(k.clone()));
        }
    }

    // Build scores by traversing options in canonical order.
    let mut scores: BTreeMap<OptionId, u64> = BTreeMap::new();
    for opt in options {
        let sum = score_sums.get(&opt.option_id).copied().unwrap_or(0);
        scores.insert(opt.option_id.clone(), sum);
    }
    Ok(scores)
}

/// Domain checks:
/// * If valid_ballots == 0 ⇒ all sums must be 0.
/// * If a max per-ballot score is available in Params (per release), enforce
///   sum_for_option <= valid_ballots * max_scale using widened arithmetic.
fn check_scale_and_caps(
    scores: &BTreeMap<OptionId, u64>,
    turnout: &TallyTotals,
    params: &Params,
) -> Result<(), TabError> {
    let v = turnout.valid_ballots;

    if v == 0 {
        // All sums must be zero in a unit with no valid ballots.
        // Use a saturating accumulation to avoid overflow traps while
        // still conveying a witness total in the error payload.
        let non_zero_total = scores
            .values()
            .fold(0u64, |acc, &x| acc.saturating_add(x));
        if non_zero_total != 0 {
            return Err(TabError::InconsistentTurnout { non_zero_total });
        }
        return Ok(());
    }

    // Try to extract a per-ballot max scale from Params (per release).
    if let Some(max_scale) = extract_max_scale(params) {
        let cap_per_option: u128 = (v as u128) * (max_scale as u128);
        for (opt, &sum) in scores {
            if (sum as u128) > cap_per_option {
                return Err(TabError::OptionExceedsCap {
                    option: opt.clone(),
                    sum,
                    cap: cap_per_option,
                });
            }
        }
    }

    Ok(())
}

/// Attempt to extract a per-ballot max score from Params.
/// Returns `None` if the current release does not expose such a variable.
fn extract_max_scale(_params: &Params) -> Option<u64> {
    // Wire this to a real field/VM-VAR if/when defined by your release.
    None
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/tabulation/ranked_irv.rs
--------------------------------------------------------------------------------
// crates/vm_algo/src/tabulation/ranked_irv.rs
//
// Part 1/2 — module header, imports, core helpers (no_std-ready, deterministic)
//
// Fixes applied relative to prior issues:
// - no_std compatibility: use `alloc` + BTreeMap/BTreeSet (no HashMap).
// - Deterministic tie-break: lowest tally, then registry order_index, then OptionId.
// - Robust order index map with duplicate detection (owned keys, not &refs).
// - No invalid `OptionId::from("...")` construction anywhere.
//
// Part 2 will provide the main IRV tabulation function and elimination loop.
//
// NOTE: Adjust these import paths (UnitId, OptionId, Turnout, TabError) to your tree.

#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

use alloc::collections::{BTreeMap, BTreeSet};
use alloc::vec::Vec;

use core::cmp::Ordering;

// ---- Adjust these imports to your actual crate layout -----------------------
use crate::errors::TabError; // e.g., crate::errors::TabError or crate::error::TabError
use vm_core::ids::{OptionId, UnitId}; // e.g., vm_core::ids::{OptionId, UnitId}
use vm_core::models::Turnout;         // e.g., vm_core::models::Turnout { valid_ballots: u64 }
// -----------------------------------------------------------------------------

/// Borrowed ranked ballot: ordered preferences, most-preferred first.
/// Upstream validation guarantees all `OptionId`s are members of `options`.
#[derive(Clone, Copy)]
pub struct RankedBallot<'a> {
    pub prefs: &'a [OptionId],
}

/// Build registry order index: `OptionId -> order_index`.
/// Detects duplicates deterministically.
pub fn build_order_index(
    unit_id: UnitId,
    options: &[OptionId],
) -> Result<BTreeMap<OptionId, usize>, TabError> {
    let mut seen = BTreeSet::new();
    let mut idx = BTreeMap::new();
    for (i, &opt) in options.iter().enumerate() {
        if !seen.insert(opt) {
            return Err(TabError::DuplicateOptionInRegistry {
                unit_id,
                option_id: opt,
            });
        }
        idx.insert(opt, i);
    }
    Ok(idx)
}

/// Return the first still-active preference for a ballot, or None if exhausted.
#[inline]
pub fn next_active_pref(
    ballot: &RankedBallot<'_>,
    eliminated: &BTreeSet<OptionId>,
) -> Option<OptionId> {
    for &opt in ballot.prefs.iter() {
        if !eliminated.contains(&opt) {
            return Some(opt);
        }
    }
    None
}

/// Tally first-choice (current) preferences across ballots, skipping exhausted ones.
/// Only counts options that are **not** eliminated.
/// Returns `(counts, continuing_ballots)` where `continuing_ballots` excludes exhausted ballots.
pub fn tally_current_first_choices(
    ballots: &[RankedBallot<'_>],
    eliminated: &BTreeSet<OptionId>,
) -> (BTreeMap<OptionId, u64>, u64) {
    let mut counts: BTreeMap<OptionId, u64> = BTreeMap::new();
    let mut continuing: u64 = 0;

    for b in ballots {
        if let Some(opt) = next_active_pref(b, eliminated) {
            continuing = continuing.saturating_add(1);
            // deterministic map key order via BTreeMap
            let entry = counts.entry(opt).or_insert(0);
            *entry = entry.saturating_add(1);
        }
    }
    (counts, continuing)
}

/// Majority winner among `continuing_options` given counts and continuing ballot total.
/// Returns `Some(winner)` if any option has strict majority; otherwise `None`.
pub fn check_majority(
    counts: &BTreeMap<OptionId, u64>,
    continuing_options: &BTreeSet<OptionId>,
    continuing_ballots: u64,
) -> Option<OptionId> {
    if continuing_ballots == 0 {
        return None;
    }
    let threshold = (continuing_ballots / 2) + 1;
    let mut best: Option<(u64, OptionId)> = None;

    for &opt in continuing_options.iter() {
        let c = *counts.get(&opt).unwrap_or(&0);
        if c >= threshold {
            // majority found; if multiple meet, pick deterministically by OptionId
            match best {
                None => best = Some((c, opt)),
                Some((prev_c, prev_opt)) => {
                    if c > prev_c || (c == prev_c && opt < prev_opt) {
                        best = Some((c, opt));
                    }
                }
            }
        }
    }
    best.map(|(_, opt)| opt)
}

/// Deterministically pick the **lowest** option to eliminate:
/// 1) smallest tally
/// 2) then smallest registry `order_index`
/// 3) then smallest `OptionId`
///
/// `eligible` are the not-eliminated options; others are ignored.
pub fn pick_lowest_to_eliminate(
    counts: &BTreeMap<OptionId, u64>,
    order_index: &BTreeMap<OptionId, usize>,
    eligible: &BTreeSet<OptionId>,
) -> Option<OptionId> {
    let mut best: Option<(u64, usize, OptionId)> = None;

    for &opt in eligible.iter() {
        let tally = *counts.get(&opt).unwrap_or(&0);
        let ord = *order_index
            .get(&opt)
            .expect("order_index must contain every eligible option");

        match best {
            None => best = Some((tally, ord, opt)),
            Some((bt, bo, boi)) => {
                // Lower tally is worse (preferred for elimination)
                // Then lower order index (earlier in registry)
                // Then lower OptionId
                let candidate = (tally, ord, opt);
                let cmp = match tally.cmp(&bt) {
                    Ordering::Less => Ordering::Less,
                    Ordering::Greater => Ordering::Greater,
                    Ordering::Equal => match ord.cmp(&bo) {
                        Ordering::Less => Ordering::Less,
                        Ordering::Greater => Ordering::Greater,
                        Ordering::Equal => opt.cmp(&boi),
                    },
                };
                if cmp == Ordering::Less {
                    best = Some(candidate);
                }
            }
        }
    }

    best.map(|t| t.2) // NOTE: correct tuple index (.2), not .3
}
// crates/vm_algo/src/tabulation/ranked_irv.rs
//
// Part 2/2 — main IRV tabulation loop (deterministic, no_std-ready)
//
// Requires Part 1 (helpers & types) to be present in this module.

/// Run IRV tabulation and return:
/// - final round tallies in **registry order** (Vec of `(OptionId, u64)`), and
/// - the selected winner `OptionId`.
///
/// Notes:
/// - Deterministic elimination order: lowest tally → lowest registry order_index → lowest OptionId.
/// - Majority is computed on **continuing ballots** (non-exhausted in the current round).
/// - Eliminated options appear with `0` in the final tallies vector (final-round view).
pub fn tabulate_ranked_irv_in_registry_order_vec(
    unit_id: UnitId,
    ballots: &[RankedBallot<'_>],
    options: &[OptionId],
    _turnout: &Turnout, // kept for API parity; IRV uses ballots directly
) -> Result<(Vec<(OptionId, u64)>, OptionId), TabError> {
    // Build canonical order index, detecting duplicates.
    let order_index = build_order_index(unit_id, options)?;

    // Eligible options = all registry options at start.
    let mut eliminated: BTreeSet<OptionId> = BTreeSet::new();
    let mut eligible: BTreeSet<OptionId> = BTreeSet::new();
    for &opt in options.iter() {
        eligible.insert(opt);
    }

    // Guard: must have at least one option.
    if eligible.is_empty() {
        return Err(TabError::NoOptions { unit_id });
    }

    // Main IRV loop.
    loop {
        // Build continuing set (eligible \ eliminated) each round.
        let mut continuing: BTreeSet<OptionId> = BTreeSet::new();
        for &opt in options.iter() {
            if !eliminated.contains(&opt) {
                continuing.insert(opt);
            }
        }

        // If only one option remains, declare it as winner (exhaustive elimination).
        if continuing.len() == 1 {
            let winner = *continuing.iter().next().expect("len==1");
            let final_counts = finalize_counts_in_registry_order(&continuing, &BTreeMap::new(), options);
            return Ok((final_counts, winner));
        }

        // Tally first-choice preferences among continuing ballots.
        let (counts, continuing_ballots) = tally_current_first_choices(ballots, &eliminated);

        // Majority check (strict > 50% of continuing ballots).
        if let Some(winner) = check_majority(&counts, &continuing, continuing_ballots) {
            let final_counts = finalize_counts_in_registry_order(&continuing, &counts, options);
            return Ok((final_counts, winner));
        }

        // No majority yet — eliminate one option deterministically.
        match pick_lowest_to_eliminate(&counts, &order_index, &continuing) {
            Some(to_eliminate) => {
                // Insert and continue to next round.
                let inserted = eliminated.insert(to_eliminate);
                debug_assert!(inserted, "candidate must not already be eliminated");
                // Loop continues.
            }
            None => {
                // Should not happen: if `continuing` is non-empty, we must be able to pick one.
                // Return a structured error to surface invariant violation.
                return Err(TabError::NoEliminationCandidate { unit_id });
            }
        }
    }
}

/// Convenience variant returning a map keyed by OptionId (sorted by key)
/// plus the winner. If you need **registry order**, use the Vec variant.
pub fn tabulate_ranked_irv(
    unit_id: UnitId,
    ballots: &[RankedBallot<'_>],
    options: &[OptionId],
    turnout: &Turnout,
) -> Result<(BTreeMap<OptionId, u64>, OptionId), TabError> {
    let (vec_final, winner) =
        tabulate_ranked_irv_in_registry_order_vec(unit_id, ballots, options, turnout)?;
    let mut out: BTreeMap<OptionId, u64> = BTreeMap::new();
    for (opt, c) in vec_final {
        out.insert(opt, c);
    }
    Ok((out, winner))
}

/// Build final-round counts in **registry order** for reporting/consumers.
/// - continuing options keep their round counts;
/// - eliminated options are reported as 0 in the final view.
fn finalize_counts_in_registry_order(
    continuing: &BTreeSet<OptionId>,
    round_counts: &BTreeMap<OptionId, u64>,
    options: &[OptionId],
) -> Vec<(OptionId, u64)> {
    let mut out: Vec<(OptionId, u64)> = Vec::with_capacity(options.len());
    for &opt in options.iter() {
        let c = if continuing.contains(&opt) {
            *round_counts.get(&opt).unwrap_or(&0)
        } else {
            0
        };
        out.push((opt, c));
    }
    out
}

// ---- Error type expectation --------------------------------------------------
//
// This part assumes the following additional `TabError` variants exist:
// - NoOptions { unit_id: UnitId }
// - NoEliminationCandidate { unit_id: UnitId }
//
// If names/fields differ in your repo, adjust the error returns above.
// -----------------------------------------------------------------------------

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/tabulation/ranked_condorcet.rs
--------------------------------------------------------------------------------
//! Ranked Condorcet — Schulze method (deterministic, integers-only).
//!
//! Scope (per specs):
//! - Build pairwise win counts between options for a unit (no RNG, no floats).
//! - Compute strongest paths using Schulze (Floyd–Warshall style).
//! - Do not depend on map iteration order; always use canonical option order:
//!   (order_index, then OptionId) as provided by the `options` slice.
//!
//! Out of scope (wired by callers/pipeline):
//! - Reading ballots / constructing pairwise from ballots.
//! - Frontier, labels, presentation.
//!
//! Determinism:
//! - No network, no time; all loops iterate by index over the canonical
//!   `options` order; lookups are explicit by (OptionId, OptionId).

#![allow(clippy::needless_pass_by_value)]

use alloc::collections::BTreeMap;
use alloc::vec::Vec;

use vm_core::{
    entities::OptionItem,
    ids::OptionId,
};

/// Errors specific to Condorcet/Schulze handling.
#[derive(Debug)]
pub enum CondorcetError {
    /// Attempted to reference an option that is not present in the canonical list.
    UnknownOption(OptionId),
    /// Internal invariant was violated (e.g., self comparison).
    Invariant(&'static str),
}

/// Pairwise win matrix: wins[(A,B)] = number of ballots preferring A over B.
///
/// Notes:
/// - Keys are **owned** `(OptionId, OptionId)` to avoid lifetime pitfalls and
///   enable deterministic canonicalization downstream.
/// - Self pairs (A,A) are present and fixed at 0; callers should treat them as 0.
#[derive(Clone, Default, Debug)]
pub struct Pairwise {
    wins: BTreeMap<(OptionId, OptionId), u64>,
}

impl Pairwise {
    /// Initialize all pairs to 0 for the given canonical option list.
    pub fn new(options: &[OptionItem]) -> Self {
        let mut wins = BTreeMap::new();
        // Canonical order comes from `options`; we materialize owned ids.
        let seq: Vec<OptionId> = seq_ids(options);
        for i in 0..seq.len() {
            for j in 0..seq.len() {
                let a = seq[i].clone();
                let b = seq[j].clone();
                wins.insert((a, b), if i == j { 0 } else { 0 });
            }
        }
        Self { wins }
    }

    /// Increment wins for A over B by `delta` (A != B).
    pub fn increment(&mut self, a: &OptionId, b: &OptionId, delta: u64) -> Result<(), CondorcetError> {
        if a == b {
            return Err(CondorcetError::Invariant("increment on (A,A) is forbidden"));
        }
        let key = (a.clone(), b.clone());
        // Absent keys mean unknown options relative to initialization.
        match self.wins.get_mut(&key) {
            Some(slot) => {
                *slot = slot.saturating_add(delta);
                Ok(())
            }
            None => Err(CondorcetError::UnknownOption(a.clone())),
        }
    }

    /// Read wins for A over B (returns 0 if the pair is absent).
    #[inline]
    pub fn get(&self, a: &OptionId, b: &OptionId) -> u64 {
        self.wins.get(&(a.clone(), b.clone())).copied().unwrap_or(0)
    }

    /// Expose immutable map (e.g., to feed Schulze).
    pub fn as_map(&self) -> &BTreeMap<(OptionId, OptionId), u64> {
        &self.wins
    }
}

/// Produce an owned, canonical sequence of OptionIds from `options`.
/// Order is the on-wire canonical `(order_index, OptionId)` provided upstream.
#[inline]
pub fn seq_ids(options: &[OptionItem]) -> Vec<OptionId> {
    options.iter().map(|o| o.option_id.clone()).collect()
}

/// Compute the Schulze strongest paths matrix `P` from pairwise wins.
///
/// Definitions (standard Schulze):
/// - Let `d[A,B] = wins(A,B)` be pairwise preferences.
/// - Initialize:
///     P[A,B] = d[A,B] if d[A,B] > d[B,A], else 0 (for A != B); P[A,A] = 0.
/// - For each intermediate `K`, update:
///     P[A,B] = max(P[A,B], min(P[A,K], P[K,B])) for all A != B and A != K and B != K.
///
/// Determinism:
/// - Loops are strictly `for k in 0..n { for i in 0..n { for j in 0..n { ... }}}`,
///   which is the canonical order for Floyd–Warshall style updates.
/// - Indices are **not** transposed; we always update P[i][j] from (i,k) & (k,j).
pub fn schulze_strongest_paths(
    options: &[OptionItem],
    wins: &BTreeMap<(OptionId, OptionId), u64>,
) -> BTreeMap<(OptionId, OptionId), u64> {
    let seq: Vec<OptionId> = seq_ids(options);
    let n = seq.len();

    // Helper closures to access d(A,B) and P(A,B).
    let d = |a: &OptionId, b: &OptionId| -> u64 {
        wins.get(&(a.clone(), b.clone())).copied().unwrap_or(0)
    };

    // Initialize P.
    let mut p: BTreeMap<(OptionId, OptionId), u64> = BTreeMap::new();
    for i in 0..n {
        for j in 0..n {
            let a = &seq[i];
            let b = &seq[j];
            let val = if i == j {
                0
            } else {
                let dab = d(a, b);
                let dba = d(b, a);
                if dab > dba { dab } else { 0 }
            };
            p.insert((a.clone(), b.clone()), val);
        }
    }

    // Floyd–Warshall style update: k → i → j
    for k in 0..n {
        for i in 0..n {
            if i == k { continue; }
            for j in 0..n {
                if j == i || j == k { continue; }

                let a = &seq[i];
                let b = &seq[j];
                let c = &seq[k];

                // p[a,b] = max(p[a,b], min(p[a,c], p[c,b]))
                let pab = *p.get(&(a.clone(), b.clone())).unwrap_or(&0);
                let pac = *p.get(&(a.clone(), c.clone())).unwrap_or(&0);
                let pcb = *p.get(&(c.clone(), b.clone())).unwrap_or(&0);
                let candidate = core::cmp::min(pac, pcb);
                if candidate > pab {
                    p.insert((a.clone(), b.clone()), candidate);
                }
            }
        }
    }

    p
}
/// Result of Condorcet/Schulze tabulation for a single unit.
#[derive(Clone, Debug)]
pub struct CondorcetResult {
    /// Schulze strongest paths P[(A,B)].
    pub strongest_paths: BTreeMap<(OptionId, OptionId), u64>,
    /// Deterministic total order of options (best → worst).
    /// Ties (P[A,B] == P[B,A]) are resolved by canonical option order.
    pub order: Vec<OptionId>,
    /// All Condorcet winners (may be 0, 1, or >1 in case of cycles).
    /// Preserves canonical option order among winners.
    pub winners: Vec<OptionId>,
}

/// Compute deterministic Schulze ranking from `strongest_paths`.
/// Sort key: for A vs B, prefer larger P[A,B]; ties fall back to canonical order.
pub fn schulze_order(
    options: &[OptionItem],
    strongest_paths: &BTreeMap<(OptionId, OptionId), u64>,
) -> Vec<OptionId> {
    let seq = seq_ids(options);

    // Precompute canonical index for stable, deterministic tiebreaks.
    let mut idx = BTreeMap::<OptionId, usize>::new();
    for (i, id) in seq.iter().cloned().enumerate() {
        idx.insert(id, i);
    }

    let mut out = seq.clone();
    out.sort_by(|a, b| {
        use core::cmp::Ordering;

        let ab = *strongest_paths
            .get(&(a.clone(), b.clone()))
            .unwrap_or(&0);
        let ba = *strongest_paths
            .get(&(b.clone(), a.clone()))
            .unwrap_or(&0);

        match ab.cmp(&ba).reverse() {
            // Reverse so that larger ab ranks "earlier" (descending).
            Ordering::Equal => {
                // Canonical order fallback (by original options order).
                let ia = *idx.get(a).expect("idx");
                let ib = *idx.get(b).expect("idx");
                ia.cmp(&ib)
            }
            non_eq => non_eq,
        }
    });

    out
}

/// Return the (possibly multiple) Condorcet winners under Schulze:
/// A is a winner if for every B != A, P[A,B] >= P[B,A].
pub fn condorcet_winners(
    options: &[OptionItem],
    strongest_paths: &BTreeMap<(OptionId, OptionId), u64>,
) -> Vec<OptionId> {
    let seq = seq_ids(options);
    let n = seq.len();
    let mut winners = alloc::vec::Vec::new();

    'outer: for i in 0..n {
        let a = &seq[i];
        for j in 0..n {
            if i == j {
                continue;
            }
            let b = &seq[j];
            let pab = *strongest_paths
                .get(&(a.clone(), b.clone()))
                .unwrap_or(&0);
            let pba = *strongest_paths
                .get(&(b.clone(), a.clone()))
                .unwrap_or(&0);
            if pab < pba {
                // A does not beat/tie B.
                continue 'outer;
            }
        }
        winners.push(a.clone());
    }

    winners
}

/// End-to-end Condorcet/Schulze tabulation from a prepared pairwise matrix.
/// Deterministic; no RNG; ties resolved by canonical option order.
///
/// Callers are responsible for constructing `pairwise` from ballots in a way
/// that respects canonical option order and validation rules upstream.
pub fn tabulate_ranked_condorcet(
    options: &[OptionItem],
    pairwise: &Pairwise,
) -> CondorcetResult {
    let p = schulze_strongest_paths(options, pairwise.as_map());
    let order = schulze_order(options, &p);
    let winners = condorcet_winners(options, &p);

    CondorcetResult {
        strongest_paths: p,
        order,
        winners,
    }
}

#[cfg(test)]
mod tests_schulze {
    use super::*;
    use alloc::vec;

    fn opt(id: &str, idx: u16) -> OptionItem {
        OptionItem::new(
            id.parse().expect("opt id"),
            "name".to_string(),
            idx,
        )
        .expect("option")
    }

    #[test]
    fn schulze_trivial_singleton() {
        let options = vec![opt("O-A", 0)];
        let p = BTreeMap::new();
        let order = schulze_order(&options, &p);
        assert_eq!(order.len(), 1);
        assert_eq!(order[0].to_string(), "O-A");

        let winners = condorcet_winners(&options, &p);
        assert_eq!(winners.len(), 1);
        assert_eq!(winners[0].to_string(), "O-A");
    }

    #[test]
    fn schulze_deterministic_tie_uses_canonical_order() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut p: BTreeMap<(OptionId, OptionId), u64> = BTreeMap::new();
        // Tie: P[A,B] == P[B,A]
        p.insert(("O-A".parse().unwrap(), "O-B".parse().unwrap()), 3);
        p.insert(("O-B".parse().unwrap(), "O-A".parse().unwrap()), 3);

        let order = schulze_order(&options, &p);
        assert_eq!(
            order.iter().map(ToString::to_string).collect::<Vec<_>>(),
            alloc::vec!["O-A".to_string(), "O-B".to_string()]
        );

        let winners = condorcet_winners(&options, &p);
        // Both are winners under ≥ rule.
        assert_eq!(winners.len(), 2);
        assert_eq!(
            winners.iter().map(ToString::to_string).collect::<Vec<_>>(),
            alloc::vec!["O-A".to_string(), "O-B".to_string()]
        );
    }

    #[test]
    fn end_to_end_tabulate_ranked_condorcet() {
        let options = vec![opt("O-A", 0), opt("O-B", 1), opt("O-C", 2)];
        let mut pw = Pairwise::new(&options);
        // Simple majority cycle A>B, B>C, C>A (classic rock-paper-scissors).
        pw.increment(&"O-A".parse().unwrap(), &"O-B".parse().unwrap(), 6).unwrap();
        pw.increment(&"O-B".parse().unwrap(), &"O-A".parse().unwrap(), 4).unwrap();

        pw.increment(&"O-B".parse().unwrap(), &"O-C".parse().unwrap(), 6).unwrap();
        pw.increment(&"O-C".parse().unwrap(), &"O-B".parse().unwrap(), 4).unwrap();

        pw.increment(&"O-C".parse().unwrap(), &"O-A".parse().unwrap(), 6).unwrap();
        pw.increment(&"O-A".parse().unwrap(), &"O-C".parse().unwrap(), 4).unwrap();

        let result = tabulate_ranked_condorcet(&options, &pw);

        // There is a cycle, so winners will be all three (each ties/beats the others via P).
        assert_eq!(result.winners.len(), 3);
        // Order is deterministic by canonical order when pairwise strengths are symmetric.
        assert_eq!(
            result.order.iter().map(ToString::to_string).collect::<Vec<_>>(),
            alloc::vec!["O-A".to_string(), "O-B".to_string(), "O-C".to_string()]
        );

        // Strongest paths matrix is populated.
        assert!(!result.strongest_paths.is_empty());
    }
}
/// Validate that a `Pairwise` matrix is complete for the given `options`.
/// Requirements:
/// - Every (A,B) pair exists (owned OptionIds), including the diagonal.
/// - Diagonal entries (A,A) are exactly 0.
/// - No extraneous keys exist (i.e., all keys reference only `options`).
pub fn validate_pairwise_complete(
    options: &[OptionItem],
    pairwise: &Pairwise,
) -> Result<(), CondorcetError> {
    let seq = seq_ids(options);
    let set: alloc::collections::BTreeSet<OptionId> = seq.iter().cloned().collect();

    // Check presence and diagonal zeros.
    for a in &seq {
        for b in &seq {
            let key = (a.clone(), b.clone());
            let v = pairwise.as_map().get(&key).copied().unwrap_or(u64::MAX);
            if a == b {
                if v != 0 {
                    return Err(CondorcetError::Invariant("pairwise diagonal must be 0"));
                }
            } else if v == u64::MAX {
                return Err(CondorcetError::Invariant("pairwise missing (A,B) entry"));
            }
        }
    }

    // Check there are no extraneous keys.
    for (k, _) in pairwise.as_map().iter() {
        if !set.contains(&k.0) || !set.contains(&k.1) {
            return Err(CondorcetError::UnknownOption(
                if !set.contains(&k.0) { k.0.clone() } else { k.1.clone() },
            ));
        }
    }

    Ok(())
}

/// Enumerate all ordered pairs (A,B) in **canonical** option order,
/// including the diagonal (A,A). Useful for deterministic iteration.
pub fn canonical_pairs(options: &[OptionItem]) -> alloc::vec::Vec<(OptionId, OptionId)> {
    let seq = seq_ids(options);
    let mut out = alloc::vec::Vec::with_capacity(seq.len() * seq.len());
    for a in &seq {
        for b in &seq {
            out.push((a.clone(), b.clone()));
        }
    }
    out
}

#[cfg(test)]
mod tests_pairwise {
    use super::*;
    use alloc::vec;

    fn opt(id: &str, idx: u16) -> OptionItem {
        OptionItem::new(
            id.parse().expect("opt id"),
            "name".to_string(),
            idx,
        )
        .expect("option")
    }

    #[test]
    fn pairwise_new_is_complete_and_zero_diag() {
        let options = vec![opt("O-A", 0), opt("O-B", 1), opt("O-C", 2)];
        let pw = Pairwise::new(&options);
        validate_pairwise_complete(&options, &pw).expect("complete");
    }

    #[test]
    fn increment_rejects_diagonal_and_unknown() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut pw = Pairwise::new(&options);

        // Diagonal increment forbidden.
        let err = pw.increment(&"O-A".parse().unwrap(), &"O-A".parse().unwrap(), 1).unwrap_err();
        match err {
            CondorcetError::Invariant(msg) => assert!(msg.contains("forbidden")),
            _ => panic!("expected Invariant error"),
        }

        // Unknown option rejected.
        let err = pw.increment(&"O-X".parse().unwrap(), &"O-B".parse().unwrap(), 1).unwrap_err();
        match err {
            CondorcetError::UnknownOption(id) => assert_eq!(id.to_string(), "O-X"),
            _ => panic!("expected UnknownOption"),
        }
    }

    #[test]
    fn canonical_pairs_enumerates_in_canonical_order() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let pairs = canonical_pairs(&options);
        let as_strings: alloc::vec::Vec<(String, String)> = pairs
            .into_iter()
            .map(|(a,b)| (a.to_string(), b.to_string()))
            .collect();
        assert_eq!(
            as_strings,
            alloc::vec![
                ("O-A".to_string(), "O-A".to_string()),
                ("O-A".to_string(), "O-B".to_string()),
                ("O-B".to_string(), "O-A".to_string()),
                ("O-B".to_string(), "O-B".to_string()),
            ]
        );
    }

    #[test]
    fn validate_detects_missing_and_extraneous_keys() {
        let options = vec![opt("O-A", 0), opt("O-B", 1)];
        let mut pw = Pairwise::new(&options);

        // Corrupt: remove one key.
        let key = ("O-A".parse().unwrap(), "O-B".parse().unwrap());
        assert!(pw.as_map().contains_key(&key));
        // Unsafe: we need a mutable access; reconstruct a broken map for the test.
        let mut broken = Pairwise { wins: pw.as_map().clone() };
        broken.wins.remove(&key);

        let err = validate_pairwise_complete(&options, &broken).unwrap_err();
        match err {
            CondorcetError::Invariant(msg) => assert!(msg.contains("missing")),
            _ => panic!("expected Invariant(missing)"),
        }

        // Corrupt: introduce extraneous key.
        let mut broken2 = Pairwise::new(&options);
        broken2.wins.insert(
            ("O-X".parse().unwrap(), "O-A".parse().unwrap()),
            1,
        );
        let err = validate_pairwise_complete(&options, &broken2).unwrap_err();
        match err {
            CondorcetError::UnknownOption(id) => assert_eq!(id.to_string(), "O-X"),
            _ => panic!("expected UnknownOption"),
        }
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/allocation/wta.rs
--------------------------------------------------------------------------------
//! Winner-take-all allocation (deterministic; integers only; RNG used only when TiePolicy::Random).
//!
//! Contract (Doc 1 / Annex A aligned):
//! - Magnitude must be exactly 1.
//! - Pick the highest score; if multiple options tie for top, break the tie by the selected policy:
//!     * StatusQuo  → attempt SQ pick (if flagged upstream), otherwise fall back to DeterministicOrder.
//!     * DeterministicOrder → smallest by canonical option order (order_index, then option_id).
//!     * Random → uniform choice using provided `TieRng`; if no RNG is provided, fall back to DeterministicOrder.
//!       (Consumes k draws for a k-way tie; winner is min by (draw, option_id).)
//! - Output encodes WTA as 100 “power” for the winner.
//!
//! Notes:
//! - `OptionItem` in vm_core intentionally has no `is_status_quo` flag; if none is known,
//!   StatusQuo policy deterministically falls back to canonical order.

#![forbid(unsafe_code)]

extern crate alloc;

use alloc::collections::{BTreeMap, BTreeSet};
use alloc::vec::Vec;

use vm_core::{
    entities::OptionItem,
    ids::OptionId,
    rng::TieRng,
    variables::TiePolicy,
};

use crate::{Allocation, UnitScores};

/// Errors for WTA allocation.
#[derive(Debug)]
pub enum AllocError {
    /// WTA requires magnitude == 1.
    InvalidMagnitude { got: u32 },
    /// Defensive: a score key did not exist in the provided options list.
    UnknownOption(OptionId),
}

/// Winner-take-all. Expects `magnitude == 1`.
///
/// *Determinism:* when `tie_policy != Random` (or RNG not supplied), ties are broken by canonical
/// option order `(order_index, option_id)`.
pub fn allocate_wta(
    scores: &UnitScores,
    magnitude: u32,
    options: &[OptionItem],
    tie_policy: TiePolicy,
    mut rng: Option<&mut TieRng>,
) -> Result<Allocation, AllocError> {
    if magnitude != 1 {
        return Err(AllocError::InvalidMagnitude { got: magnitude });
    }

    // Defensive: ensure no unknown option IDs appear in the score map.
    // (Upstream cross-ref in vm_io.loader should already guarantee this.)
    let allowed: BTreeSet<OptionId> = options.iter().map(|o| o.option_id.clone()).collect();
    for k in scores.scores.keys() {
        if !allowed.contains(k) {
            return Err(AllocError::UnknownOption(k.clone()));
        }
    }

    // Find max score and collect all tied-at-max, using canonical option order.
    let (max_score, tied) = top_by_score(scores, options);

    // Select winner (resolve ties per policy).
    let winner = if tied.len() == 1 {
        tied[0].clone()
    } else {
        break_tie_wta(&tied, options, tie_policy, rng.as_deref_mut())
    };

    // Encode WTA: winner gets 100 "power" (always pick a winner, even if all scores are zero).
    let mut seats_or_power: BTreeMap<OptionId, u32> = BTreeMap::new();
    if !tied.is_empty() || max_score == 0 {
        seats_or_power.insert(winner.clone(), 100);
    } else {
        seats_or_power.insert(winner.clone(), 100);
    }

    Ok(Allocation {
        unit_id: scores.unit_id.clone(),
        seats_or_power,
        last_seat_tie: tied.len() > 1,
    })
}

/// Scan scores in canonical option order and return (max_score, tied_ids_at_max).
fn top_by_score(scores: &UnitScores, options: &[OptionItem]) -> (u64, Vec<OptionId>) {
    let mut max_val: u64 = 0;
    let mut tied: Vec<OptionId> = Vec::new();

    for opt in options {
        let v = *scores.scores.get(&opt.option_id).unwrap_or(&0);
        if v > max_val {
            max_val = v;
            tied.clear();
            tied.push(opt.option_id.clone());
        } else if v == max_val {
            tied.push(opt.option_id.clone());
        }
    }
    (max_val, tied)
}

/// Resolve a tie among `tied` option IDs per policy.
/// If StatusQuo cannot be determined from `options`, falls back to DeterministicOrder.
/// If Random is requested but `rng` is None, falls back to DeterministicOrder.
fn break_tie_wta(
    tied: &[OptionId],
    options: &[OptionItem],
    tie_policy: TiePolicy,
    rng: Option<&mut TieRng>,
) -> OptionId {
    match tie_policy {
        TiePolicy::StatusQuo => {
            // No `is_status_quo` flag in OptionItem in vm_core; fall back to deterministic order.
            pick_deterministic(tied, options)
        }
        TiePolicy::DeterministicOrder => pick_deterministic(tied, options),
        TiePolicy::Random => {
            if let Some(rng) = rng {
                // Consume exactly k draws for k-way tie; choose min by (draw, option_id)
                // to ensure stable deterministic behavior on equal tickets.
                let mut best: Option<(u64, &OptionId)> = None;
                for oid in tied {
                    // Draw from a wide range to minimize equal-ticket collisions.
                    let ticket = rng.gen_range(u64::MAX);
                    match best {
                        None => best = Some((ticket, oid)),
                        Some((b_ticket, b_oid)) => {
                            if (ticket, oid) < (b_ticket, b_oid) {
                                best = Some((ticket, oid));
                            }
                        }
                    }
                }
                best.map(|(_, oid)| oid.clone()).unwrap_or_else(|| pick_deterministic(tied, options))
            } else {
                // No RNG supplied → deterministic fallback.
                pick_deterministic(tied, options)
            }
        }
    }
}

/// Deterministic tie-break: choose the earliest by canonical option order `(order_index, option_id)`.
fn pick_deterministic(tied: &[OptionId], options: &[OptionItem]) -> OptionId {
    // Walk options in canonical order; return the first that is in `tied`.
    let tied_set: BTreeSet<OptionId> = tied.iter().cloned().collect();
    for opt in options {
        if tied_set.contains(&opt.option_id) {
            return opt.option_id.clone();
        }
    }
    // Should never happen (tied must be subset of options). Fall back to lexicographic min.
    tied.iter()
        .min()
        .cloned()
        .unwrap_or_else(|| OptionId::from("UNKNOWN"))
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/allocation/dhondt.rs
--------------------------------------------------------------------------------
//! D’Hondt (highest averages) allocation per unit.
//!
//! Contract (Doc 1 / Annex A aligned):
//! - Apply entry threshold on the *natural* totals (plurality votes, approvals, score sums).
//! - Allocate `seats` sequentially by picking max of v/(s+1).
//! - Ties resolved by policy: StatusQuo → fallback deterministic (no SQ flag in core),
//!   DeterministicOrder → canonical `(order_index, option_id)`, Random → seeded `TieRng`.
//! - Pure integers; no division in comparisons (cross-multiply in u128).
//!
//! Determinism:
//! - Iteration/scans run in canonical option order (the `options` slice).
//! - Random ties depend *only* on the provided `TieRng` stream.

#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

use alloc::collections::BTreeMap;
use alloc::vec::Vec;

use vm_core::{
    entities::OptionItem,
    ids::OptionId,
    rng::TieRng,
    variables::TiePolicy,
};

#[derive(Debug)]
pub enum AllocError {
    /// After threshold filtering, no options remain eligible while seats > 0.
    NoEligibleOptions,
    /// Policy was Random but no RNG was supplied (and seats > 0).
    MissingRngForRandomPolicy,
}

/// Allocate seats using D’Hondt (highest averages) method.
///
/// *Notes*:
/// - If `seats == 0`, returns an empty map.
/// - Threshold is applied against the sum of provided `scores`.
/// - Keys not present in `scores` are treated as 0 (they rarely pass a positive threshold).
pub fn allocate_dhondt(
    seats: u32,
    scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem], // canonical (order_index, id)
    threshold_pct: u8,
    tie_policy: TiePolicy,
    mut rng: Option<&mut TieRng>,
) -> Result<BTreeMap<OptionId, u32>, AllocError> {
    if seats == 0 {
        return Ok(BTreeMap::new());
    }
    if matches!(tie_policy, TiePolicy::Random) && rng.is_none() {
        return Err(AllocError::MissingRngForRandomPolicy);
    }

    // 1) Threshold on natural totals.
    let eligible_scores = filter_by_threshold(scores, threshold_pct);

    // 2) Establish eligible IDs in *canonical option order*.
    let mut eligible_order: Vec<OptionId> = Vec::new();
    for o in options {
        if eligible_scores.contains_key(&o.option_id) {
            eligible_order.push(o.option_id.clone());
        }
    }

    if eligible_order.is_empty() {
        // No eligible options appear in canonical list → cannot allocate.
        return Err(AllocError::NoEligibleOptions);
    }

    // 3) Initialize seat vector for eligible options only (preserve determinism).
    let mut alloc: BTreeMap<OptionId, u32> =
        eligible_order.iter().cloned().map(|id| (id, 0)).collect();

    // 4) Sequentially award seats using D’Hondt quotients.
    for _round in 0..seats {
        let winner =
            next_award(&alloc, &eligible_scores, &eligible_order, tie_policy, rng.as_deref_mut());
        *alloc.get_mut(&winner).expect("winner must be in alloc") += 1;
    }

    Ok(alloc)
}

/// Filter by PR threshold using natural totals.
/// Keeps (opt, v) where 100 * v >= threshold_pct * total.
fn filter_by_threshold(
    scores: &BTreeMap<OptionId, u64>,
    threshold_pct: u8,
) -> BTreeMap<OptionId, u64> {
    let total: u128 = scores.values().map(|&v| v as u128).sum();
    // Fast path: threshold 0 keeps all known keys (missing keys treated as 0 and excluded).
    if threshold_pct == 0 {
        return scores.clone();
    }
    let t = threshold_pct as u128;
    scores
        .iter()
        .filter_map(|(k, &v)| {
            let v128 = v as u128;
            // Keep if share >= threshold (cross-multiplied; integer math only).
            if v128.saturating_mul(100) >= t.saturating_mul(total) {
                Some((k.clone(), v))
            } else {
                None
            }
        })
        .collect()
}

/// Choose argmax of v/(s+1) across eligible; ties resolved per policy.
/// `eligible_order` MUST be in canonical option order.
fn next_award(
    seats_so_far: &BTreeMap<OptionId, u32>,
    eligible_scores: &BTreeMap<OptionId, u64>,
    eligible_order: &[OptionId],
    tie_policy: TiePolicy,
    rng: Option<&mut TieRng>,
) -> OptionId {
    // Track the current best quotient and IDs (encounter order == canonical order).
    let mut best_ids: Vec<OptionId> = Vec::new();
    let mut best_v: u64 = 0;
    let mut best_s: u32 = 0;
    let mut have_best = false;

    for id in eligible_order {
        let v = *eligible_scores
            .get(id)
            .expect("eligible_order implies presence in eligible_scores");
        let s = *seats_so_far.get(id).unwrap_or(&0);

        if !have_best {
            have_best = true;
            best_v = v;
            best_s = s;
            best_ids.clear();
            best_ids.push(id.clone());
        } else {
            match cmp_quotients(v, s, best_v, best_s) {
                core::cmp::Ordering::Greater => {
                    best_v = v;
                    best_s = s;
                    best_ids.clear();
                    best_ids.push(id.clone());
                }
                core::cmp::Ordering::Equal => {
                    best_ids.push(id.clone());
                }
                core::cmp::Ordering::Less => {
                    // keep current best
                }
            }
        }
    }

    debug_assert!(
        !best_ids.is_empty(),
        "eligible_order must contain at least one candidate"
    );

    if best_ids.len() == 1 {
        return best_ids[0].clone();
    }

    // Resolve tie per policy.
    match tie_policy {
        TiePolicy::StatusQuo | TiePolicy::DeterministicOrder => {
            // First in canonical order (best_ids is built in canonical order).
            best_ids[0].clone()
        }
        TiePolicy::Random => {
            let n = best_ids.len() as u64; // n >= 2 here
            let idx = rng
                .expect("rng must be provided for Random policy")
                .gen_range(n) as usize; // uniform in [0, n)
            best_ids[idx].clone()
        }
    }
}

/// Compare D’Hondt quotients v_a/(s_a+1) vs v_b/(s_b+1) without floats.
/// Returns Ordering::Greater if a's quotient is larger.
fn cmp_quotients(v_a: u64, s_a: u32, v_b: u64, s_b: u32) -> core::cmp::Ordering {
    // Compare v_a * (s_b+1) ? v_b * (s_a+1) in u128 to avoid overflow.
    let da = (s_a as u128) + 1;
    let db = (s_b as u128) + 1;
    let lhs = (v_a as u128) * db;
    let rhs = (v_b as u128) * da;
    lhs.cmp(&rhs)
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/allocation/sainte_lague.rs
--------------------------------------------------------------------------------
//! Sainte-Laguë (highest averages with odd divisors) allocation per unit.
//!
//! Contract (Doc 1 / Annex A aligned):
//! - Apply entry threshold on the natural totals (plurality votes, approvals, score sums).
//! - Allocate `seats` sequentially by picking max of v / (2*s + 1).
//! - Ties resolved by policy: StatusQuo → fallback deterministic (no SQ flag in core),
//!   DeterministicOrder → canonical `(order_index, option_id)`,
//!   Random → seeded `TieRng` (consume exactly k draws for a k-way tie; pick min by (draw, option_id)).
//! - Pure integers; no division in comparisons (cross-multiply in u128).
//!
//! Determinism:
//! - Scans iterate in canonical option order (the `options` slice).
//! - Random ties depend *only* on the provided `TieRng` stream; no draws if no tie.

#![forbid(unsafe_code)]

extern crate alloc;

use alloc::collections::{BTreeMap, BTreeSet};
use alloc::vec::Vec;

use vm_core::{
    entities::OptionItem,
    ids::OptionId,
    rng::TieRng,
    variables::TiePolicy,
};

#[derive(Debug)]
pub enum AllocError {
    /// After threshold filtering, no options remain eligible while seats > 0.
    NoEligibleOptions,
}

/// Allocate seats using Sainte-Laguë (odd divisors 1,3,5,…).
///
/// Notes:
/// - If `seats == 0`, returns an empty map.
/// - Threshold is applied against the sum of provided `scores`.
/// - Keys not present in `scores` are treated as 0; unknown IDs (not in `options`) are ignored.
pub fn allocate_sainte_lague(
    seats: u32,
    scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem], // canonical (order_index, id)
    threshold_pct: u8,
    tie_policy: TiePolicy,
    mut rng: Option<&mut TieRng>,
) -> Result<BTreeMap<OptionId, u32>, AllocError> {
    if seats == 0 {
        return Ok(BTreeMap::new());
    }

    // Apply threshold and intersect with registry options.
    let eligible_scores = filter_by_threshold(scores, options, threshold_pct);

    if eligible_scores.is_empty() {
        return Err(AllocError::NoEligibleOptions);
    }

    // Initialize seat vector for eligible options only.
    let mut alloc: BTreeMap<OptionId, u32> =
        eligible_scores.keys().cloned().map(|id| (id, 0)).collect();

    // Award seats sequentially.
    for _round in 0..seats {
        let winner = next_award(
            &alloc,
            &eligible_scores,
            options,
            tie_policy,
            rng.as_deref_mut(),
        );
        *alloc.get_mut(&winner).expect("winner must be in alloc") += 1;
    }

    Ok(alloc)
}

/// Keep options whose natural share meets the threshold: 100*v >= threshold_pct*total (u128 math),
/// and that are present in the registry `options`.
/// If `total == 0`, no one qualifies (prevents allocating seats by tie-break alone).
fn filter_by_threshold(
    scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
    threshold_pct: u8,
) -> BTreeMap<OptionId, u64> {
    // Build membership set of valid (registry) options.
    let allowed: BTreeSet<OptionId> = options.iter().map(|o| o.option_id.clone()).collect();

    let total: u128 = scores
        .iter()
        .filter(|(k, _)| allowed.contains(*k))
        .map(|(_, &v)| v as u128)
        .sum();

    if total == 0 {
        return BTreeMap::new();
    }

    if threshold_pct == 0 {
        // Intersect with registry; unknown IDs are ignored.
        return allowed
            .into_iter()
            .map(|k| {
                let v = *scores.get(&k).unwrap_or(&0);
                (k, v)
            })
            .collect();
    }

    let t = threshold_pct as u128;
    allowed
        .into_iter()
        .filter_map(|k| {
            let v = *scores.get(&k).unwrap_or(&0);
            let v128 = v as u128;
            // 100*v >= t*total  (all u128 to avoid overflow)
            if v128.saturating_mul(100) >= t.saturating_mul(total) {
                Some((k, v))
            } else {
                None
            }
        })
        .collect()
}

/// Argmax of Sainte-Laguë quotients v / (2*s + 1); ties per policy.
fn next_award(
    seats_so_far: &BTreeMap<OptionId, u32>,
    eligible_scores: &BTreeMap<OptionId, u64>,
    options: &[OptionItem],
    tie_policy: TiePolicy,
    rng: Option<&mut TieRng>,
) -> OptionId {
    // Track the current best quotient and tied IDs in canonical order.
    let mut best_ids: Vec<OptionId> = Vec::new();
    let mut best_v: u64 = 0;
    let mut best_s: u32 = 0;
    let mut have_best = false;

    for opt in options {
        if let Some(&v) = eligible_scores.get(&opt.option_id) {
            let s = *seats_so_far.get(&opt.option_id).unwrap_or(&0);
            if !have_best {
                have_best = true;
                best_v = v;
                best_s = s;
                best_ids.clear();
                best_ids.push(opt.option_id.clone());
            } else {
                match cmp_quotients(v, s, best_v, best_s) {
                    core::cmp::Ordering::Greater => {
                        best_v = v;
                        best_s = s;
                        best_ids.clear();
                        best_ids.push(opt.option_id.clone());
                    }
                    core::cmp::Ordering::Equal => {
                        best_ids.push(opt.option_id.clone());
                    }
                    core::cmp::Ordering::Less => {} // keep current best
                }
            }
        }
    }

    if best_ids.len() <= 1 {
        return best_ids
            .into_iter()
            .next()
            // Practically unreachable if caller checked eligibility; still pick first canonical option deterministically.
            .unwrap_or_else(|| options.first().expect("options cannot be empty").option_id.clone());
    }

    // Resolve tie per policy.
    match tie_policy {
        TiePolicy::StatusQuo => deterministic_pick(&best_ids, options), // no SQ flag → deterministic
        TiePolicy::DeterministicOrder => deterministic_pick(&best_ids, options),
        TiePolicy::Random => {
            if let Some(mut rng) = rng {
                // Consume exactly k draws for a k-way tie; winner is min by (draw, option_id).
                let mut best: Option<(u64, &OptionId)> = None;
                for oid in &best_ids {
                    let ticket = rng.gen_range(u64::MAX).unwrap_or(0);
                    match best {
                        None => best = Some((ticket, oid)),
                        Some((b_ticket, b_oid)) => {
                            if (ticket, oid) < (b_ticket, b_oid) {
                                best = Some((ticket, oid));
                            }
                        }
                    }
                }
                best.map(|(_, oid)| oid.clone())
                    .unwrap_or_else(|| deterministic_pick(&best_ids, options))
            } else {
                // No RNG supplied → deterministic fallback, but no error.
                deterministic_pick(&best_ids, options)
            }
        }
    }
}

/// Compare quotients q_a = v_a / (2*s_a+1) vs q_b = v_b / (2*s_b+1) using u128 cross-multiplication.
fn cmp_quotients(v_a: u64, s_a: u32, v_b: u64, s_b: u32) -> core::cmp::Ordering {
    // Compare v_a * (2*s_b+1) ? v_b * (2*s_a+1) in u128 to avoid overflow.
    let da = (2u128 * (s_a as u128)) + 1;
    let db = (2u128 * (s_b as u128)) + 1;
    let lhs = (v_a as u128) * db;
    let rhs = (v_b as u128) * da;
    lhs.cmp(&rhs)
}

/// Deterministic fallback: choose the earliest by canonical option order `(order_index, option_id)`.
fn deterministic_pick(tied: &[OptionId], options: &[OptionItem]) -> OptionId {
    let set: BTreeSet<OptionId> = tied.iter().cloned().collect();
    for o in options {
        if set.contains(&o.option_id) {
            return o.option_id.clone();
        }
    }
    // Fallback: pick first canonical option (should not be needed).
    options.first().expect("options cannot be empty").option_id.clone()
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/allocation/largest_remainder.rs
--------------------------------------------------------------------------------
//! Largest Remainder (LR) allocation per unit with selectable quota
//! (Hare, Droop, Imperiali).
//!
//! Contract (Doc 4 / Doc 5 aligned):
//! - Thresholding happens upstream; this function assumes `scores` already filtered.
//! - Quota kinds:
//!     * Hare:      floor(V / m)
//!     * Droop:     floor(V / (m + 1)) + 1
//!     * Imperiali: floor(V / (m + 2))
//! - Floors are v_i / q (integer div); remainders are v_i % q.
//! - If q == 0 (tiny totals), floors are 0 and remainders are raw scores.
//! - If sum_floors < seats → distribute leftovers by largest remainder
//!   (tie keys: remainder ↓, raw score ↓, then canonical order).
//! - If sum_floors > seats (Imperiali edge) → trim from smallest remainder
//!   (remainder ↑, raw score ↑, then canonical order).
//!
//! Determinism:
//! - No RNG or policy here (S4); deterministic tie-breaking only.

#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

use alloc::collections::BTreeMap;
use alloc::vec::Vec;

use vm_core::ids::OptionId;

#[derive(Copy, Clone, Eq, PartialEq, Debug)]
pub enum QuotaKind {
    Hare,
    Droop,
    Imperiali,
}

#[derive(Debug)]
pub enum AllocError {
    /// No eligible options (empty `scores`) while seats > 0.
    NoEligibleOptions,
}

/// Public API expected by the pipeline (kept stable).
/// Breaks LR ties by: remainder ↓, raw score ↓, then `OptionId` ascending.
/// If canonical order differs from `OptionId`, prefer the `*_with_order` variant below.
pub fn allocate_largest_remainder(
    seats: u32,
    scores: &BTreeMap<OptionId, u64>,
    quota: QuotaKind,
) -> Result<BTreeMap<OptionId, u32>, AllocError> {
    allocate_largest_remainder_with_order(seats, scores, quota, None)
}

/// Variant that accepts a canonical order (slice of OptionIds). When provided,
/// ties use that order as the final key (ascending index in the slice).
pub fn allocate_largest_remainder_with_order(
    seats: u32,
    scores: &BTreeMap<OptionId, u64>,
    quota: QuotaKind,
    canonical_order: Option<&[OptionId]>,
) -> Result<BTreeMap<OptionId, u32>, AllocError> {
    // Trivial cases
    if seats == 0 {
        return Ok(BTreeMap::new());
    }
    if scores.is_empty() {
        return Err(AllocError::NoEligibleOptions);
    }

    let total: u128 = scores.values().map(|&v| v as u128).sum();
    let q = compute_quota(total, seats as u128, quota);

    let (mut alloc, remainders) = floors_and_remainders(scores, q);

    // Sum floors and compare to target seats.
    let sum_floors: u128 = alloc.values().map(|&s| s as u128).sum();

    if sum_floors < seats as u128 {
        // Assign remaining seats by static LR ranking (deterministic).
        let needed = (seats as u128 - sum_floors) as u32;
        distribute_leftovers(needed, &mut alloc, &remainders, scores, canonical_order);
    } else if sum_floors > seats as u128 {
        // Imperiali edge (or degenerate quota): remove seats based on inverse LR ranking.
        trim_over_allocation(seats, &mut alloc, &remainders, scores, canonical_order);
    }

    // Always recompute final sum to avoid stale assertions.
    let sum: u128 = alloc.values().map(|&s| s as u128).sum();
    debug_assert_eq!(sum, seats as u128);
    Ok(alloc)
}

/// Integer-only quota.
/// Hare: floor(V / m)
/// Droop: floor(V / (m + 1)) + 1
/// Imperiali: floor(V / (m + 2))
fn compute_quota(total: u128, seats: u128, quota: QuotaKind) -> u128 {
    match quota {
        QuotaKind::Hare => {
            if seats == 0 { 0 } else { total / seats }
        }
        QuotaKind::Droop => {
            // floor(V/(m+1)) + 1 ; m>0 guaranteed by caller
            (total / (seats + 1)) + 1
        }
        QuotaKind::Imperiali => {
            // floor(V/(m+2))
            total / (seats + 2)
        }
    }
}

/// Compute floors and remainders given quota q (u128 math; q==0 handled).
fn floors_and_remainders(
    scores: &BTreeMap<OptionId, u64>,
    q: u128,
) -> (BTreeMap<OptionId, u32>, BTreeMap<OptionId, u128>) {
    let mut floors: BTreeMap<OptionId, u32> = BTreeMap::new();
    let mut rems: BTreeMap<OptionId, u128> = BTreeMap::new();

    for (id, &v) in scores.iter() {
        let v128 = v as u128;
        if q == 0 {
            floors.insert(id.clone(), 0);
            rems.insert(id.clone(), v128);
        } else {
            let f128 = v128 / q;
            // Saturate to u32::MAX; in practice seats bound this far below.
            let f = if f128 > (u32::MAX as u128) { u32::MAX } else { f128 as u32 };
            let r = v128 % q;
            floors.insert(id.clone(), f);
            rems.insert(id.clone(), r);
        }
    }

    (floors, rems)
}

/// Assign `target_extra` seats by largest remainder (deterministic ranking):
/// remainder ↓, raw score ↓, then canonical order (if provided) else `OptionId` ↑.
fn distribute_leftovers(
    target_extra: u32,
    alloc: &mut BTreeMap<OptionId, u32>,
    remainders: &BTreeMap<OptionId, u128>,
    scores: &BTreeMap<OptionId, u64>,
    canonical_order: Option<&[OptionId]>,
) {
    if target_extra == 0 || remainders.is_empty() {
        return;
    }

    // Build canonical index lookup if provided.
    let order_ix: BTreeMap<OptionId, usize> = match canonical_order {
        Some(slice) => slice
            .iter()
            .enumerate()
            .map(|(i, id)| (id.clone(), i))
            .collect(),
        None => BTreeMap::new(),
    };

    // Build a stable ranking once; reuse cyclically if target_extra > candidates.
    let mut ranking: Vec<(OptionId, u128, u64, usize)> = remainders
        .iter()
        .map(|(id, &r)| {
            let sc = *scores.get(id).unwrap_or(&0);
            let ix = order_ix.get(id).cloned().unwrap_or(usize::MAX);
            (id.clone(), r, sc, ix)
        })
        .collect();

    ranking.sort_by(|a, b| {
        // r desc, score desc, canonical asc (or OptionId asc if no canonical index)
        b.1.cmp(&a.1)
            .then_with(|| b.2.cmp(&a.2))
            .then_with(|| {
                match (a.3, b.3) {
                    (usize::MAX, usize::MAX) => a.0.cmp(&b.0), // fall back to OptionId
                    (ia, ib) => ia.cmp(&ib),
                }
            })
    });

    if ranking.is_empty() {
        return;
    }

    let n = ranking.len();
    let mut given = 0u32;
    let mut idx = 0usize;

    while given < target_extra {
        let (ref id, _, _, _) = ranking[idx];
        *alloc.entry(id.clone()).or_insert(0) += 1;
        given += 1;
        idx += 1;
        if idx == n {
            idx = 0; // cycle if more seats than candidates (degenerate quotas)
        }
    }
}

/// Trim seats when floors over-allocate (Imperiali edge) using inverse LR ranking:
/// remainder ↑, raw score ↑, then canonical order (if provided) else `OptionId` ↑.
fn trim_over_allocation(
    target_seats: u32,
    alloc: &mut BTreeMap<OptionId, u32>,
    remainders: &BTreeMap<OptionId, u128>,
    scores: &BTreeMap<OptionId, u64>,
    canonical_order: Option<&[OptionId]>,
) {
    let mut total: u128 = alloc.values().map(|&s| s as u128).sum();
    if total <= target_seats as u128 {
        return;
    }

    let order_ix: BTreeMap<OptionId, usize> = match canonical_order {
        Some(slice) => slice
            .iter()
            .enumerate()
            .map(|(i, id)| (id.clone(), i))
            .collect(),
        None => BTreeMap::new(),
    };

    // Consider only options with at least one seat.
    let mut ranking: Vec<(OptionId, u128, u64, usize)> = alloc
        .iter()
        .filter_map(|(id, &s)| (s > 0).then(|| {
            let r = *remainders.get(id).unwrap_or(&0);
            let sc = *scores.get(id).unwrap_or(&0);
            let ix = order_ix.get(id).cloned().unwrap_or(usize::MAX);
            (id.clone(), r, sc, ix)
        }))
        .collect();

    ranking.sort_by(|a, b| {
        // r asc, score asc, canonical asc (or OptionId asc if no canonical index)
        a.1.cmp(&b.1)
            .then_with(|| a.2.cmp(&b.2))
            .then_with(|| {
                match (a.3, b.3) {
                    (usize::MAX, usize::MAX) => a.0.cmp(&b.0), // fall back to OptionId
                    (ia, ib) => ia.cmp(&ib),
                }
            })
    });

    if ranking.is_empty() {
        return;
    }

    let mut idx = 0usize;
    while total > target_seats as u128 {
        let (ref id, _, _, _) = ranking[idx];
        if let Some(s) = alloc.get_mut(id) {
            if *s > 0 {
                *s -= 1;
                total -= 1;
            }
        }
        idx += 1;
        if idx == ranking.len() {
            idx = 0; // cycle defensively; should rarely happen
        }
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/mmp.rs
--------------------------------------------------------------------------------
// crates/vm_algo/src/allocation/mmp.rs
//
// Part 1/3 — module header, imports, types, core helpers (no_std-ready, deterministic)
//
// Mixed-Member Proportional (MMP) helpers:
// - compute total seats from a top-up share (VM-VAR-013) with half-even rounding,
// - (in Part 2) apportion intended targets using highest-averages (D’Hondt / Sainte-Laguë),
// - (in Part 3) compute top-ups vs local seats and apply overhang policy/model.
//
// Determinism & policy:
// - No RNG anywhere in MMP.
// - All tie-breaks are fully deterministic; later parts will use either registry order
//   (order_index) or OptionId ordering as a stable, documented fallback.
// - Integer-first arithmetic; no float division. Cross-multiply for quotient comparisons.
//
// NOTE: Adjust crate paths if your tree differs.

#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

use alloc::collections::{BTreeMap, BTreeSet};
use alloc::vec::Vec;

use vm_core::{
    ids::OptionId,
    rounding::round_nearest_even_int,
    variables::{AllocationMethod, OverhangPolicy, TotalSeatsModel},
};

/// Result bundle for an MMP correction step.
/// (Produced in Part 3.)
#[derive(Debug, Clone)]
pub struct MmpOutcome {
    pub targets: BTreeMap<OptionId, u32>,
    pub topups: BTreeMap<OptionId, u32>,
    pub finals: BTreeMap<OptionId, u32>,
    pub effective_total_seats: u32,
    pub overhang_by_option: BTreeMap<OptionId, u32>,
}

/// Errors specific to the MMP helpers.
/// (Used by helpers in this module; public so callers can inspect failures.)
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MmpError {
    /// `topup_share_pct` must be < 100 (and typically ≤ 60 by upstream policy).
    InvalidTopupSharePct { pct: u8 },
    /// Half-even rounding failed (should not happen with positive denominator).
    RoundingError { num: i128, den: i128 },
    /// Growth model cannot satisfy locals given vote_totals (see Part 3).
    NoViableApportionment { option_id: OptionId },
}

/// Compute intended total seats `T` from local seats `L` and top-up share `p%`
/// using banker's (half-even) rounding on `T = (L*100) / (100 - p)`.
///
/// Domain: upstream typically enforces `p ≤ 60` and strictly `< 100`.
/// Returns a **Result** to avoid lossy sentinels.
pub fn compute_total_from_share_result(local_total: u32, topup_share_pct: u8) -> Result<u32, MmpError> {
    if topup_share_pct >= 100 {
        return Err(MmpError::InvalidTopupSharePct { pct: topup_share_pct });
    }
    let num: i128 = (local_total as i128) * 100;
    let den: i128 = i128::from(100u8.saturating_sub(topup_share_pct)).max(1);
    match round_nearest_even_int(num, den) {
        Ok(v) if v >= 0 && v <= (u32::MAX as i128) => Ok(v as u32),
        Ok(_) => Ok(u32::MAX), // saturate up: extremely large houses clamp to u32::MAX
        Err(_) => Err(MmpError::RoundingError { num, den }),
    }
}

/// Back-compat wrapper that returns `0` on error (deprecated).
/// Prefer `compute_total_from_share_result`.
#[inline]
pub fn compute_total_from_share(local_total: u32, topup_share_pct: u8) -> u32 {
    match compute_total_from_share_result(local_total, topup_share_pct) {
        Ok(v) => v,
        Err(_e) => 0,
    }
}

/// Highest-averages divisor for the chosen method given `s` seats already assigned.
///
/// - D’Hondt: d(s) = s + 1
/// - Sainte-Laguë (plain): d(s) = 2*s + 1
/// (If you support "modified Sainte-Laguë", adapt the s==0 divisor externally.)
#[inline]
pub fn divisor(method: AllocationMethod, s_assigned: u32) -> u128 {
    match method {
        AllocationMethod::DHondt => u128::from(s_assigned) + 1,
        AllocationMethod::SainteLague => (u128::from(s_assigned) << 1) + 1,
        // Add other methods here if vm_core defines them; keep ≥ 1 always.
    }
}

/// Compare two highest-averages quotients v1/d1 vs v2/d2 via cross multiplication.
/// Returns `core::cmp::Ordering`.
#[inline]
pub fn cmp_quotients(v1: u64, d1: u128, v2: u64, d2: u128) -> core::cmp::Ordering {
    use core::cmp::Ordering;
    // d1, d2 must be ≥ 1 by construction.
    let left = (v1 as u128).saturating_mul(d2);
    let right = (v2 as u128).saturating_mul(d1);
    if left < right {
        Ordering::Less
    } else if left > right {
        Ordering::Greater
    } else {
        Ordering::Equal
    }
}

/// Build the union set of option IDs present across inputs (stable set).
#[inline]
pub fn union_option_ids(
    a: &BTreeMap<OptionId, impl Copy>,
    b: &BTreeMap<OptionId, impl Copy>,
    c: &BTreeMap<OptionId, impl Copy>,
) -> BTreeSet<OptionId> {
    let mut set = BTreeSet::new();
    for k in a.keys() {
        set.insert(*k);
    }
    for k in b.keys() {
        set.insert(*k);
    }
    for k in c.keys() {
        set.insert(*k);
    }
    set
}

/// Seed a map for all options in `ids` with an initial value.
#[inline]
pub fn seed_map_u32(ids: &BTreeSet<OptionId>, init: u32) -> BTreeMap<OptionId, u32> {
    ids.iter().copied().map(|k| (k, init)).collect()
}

/// Sum values in a map (u32 → u128 accumulator).
#[inline]
pub fn sum_map_u32(map: &BTreeMap<OptionId, u32>) => u128 {
    map.values().fold(0u128, |acc, &v| acc + (v as u128))
}
// crates/vm_algo/src/allocation/mmp.rs
//
// Part 2/3 — apportionment (highest-averages), registry-order aware, no_std-ready.
//
// Implements:
// - build_order_index for deterministic tie-breaks (registry order, then OptionId)
// - apportion_targets: seats → parties from votes using D’Hondt / Sainte-Laguë
//   * seeds all registry options (zero-vote parties kept in map)
//   * seat-by-seat assignment with cross-multiply comparison (integer-only)
//   * exact ties: lower registry order_index first, then lower OptionId
//   * zero-vote corner case: even round-robin by registry order (deterministic)
//
// NOTE: Adjust types/paths in Part 1 if your repo differs.

use core::cmp::Ordering;
use alloc::collections::{BTreeMap, BTreeSet};
use alloc::vec::Vec;

use crate::allocation::mmp::{
    divisor, cmp_quotients, MmpError
};
use vm_core::ids::OptionId;
use vm_core::variables::AllocationMethod;

/// Build registry order index: `OptionId -> order_index`.
/// Duplicate options are treated as a logic error (debug-asserted); the first
/// occurrence wins deterministically in release builds.
#[inline]
pub fn build_order_index(options: &[OptionId]) -> BTreeMap<OptionId, usize> {
    let mut seen = BTreeSet::new();
    let mut idx = BTreeMap::new();
    for (i, &opt) in options.iter().enumerate() {
        let first = seen.insert(opt);
        debug_assert!(first, "Duplicate OptionId in registry slice: {:?}", opt);
        // First occurrence wins deterministically; repeated inserts overwrite with same i anyway.
        idx.insert(opt, i);
    }
    idx
}

/// Evenly distribute `total_seats` in a deterministic round-robin by registry order.
/// Used only when the entire vote vector sums to zero.
fn round_robin_even_distribution(
    total_seats: u32,
    options: &[OptionId],
) -> BTreeMap<OptionId, u32> {
    let n = options.len() as u32;
    let mut out: BTreeMap<OptionId, u32> = options.iter().copied().map(|k| (k, 0)).collect();
    if n == 0 || total_seats == 0 {
        return out;
    }
    // Base quota and remainder
    let base = total_seats / n;
    let rem  = total_seats % n;

    // Everyone gets the base
    for &opt in options.iter() {
        *out.get_mut(&opt).unwrap() = base;
    }
    // First `rem` options in registry order get one extra, deterministically
    for opt in options.iter().take(rem as usize) {
        if let Some(v) = out.get_mut(opt) {
            *v = v.saturating_add(1);
        }
    }
    out
}

/// Apportion `total_seats` to `options` from `vote_totals` via highest-averages.
/// Deterministic, integer-only; tie-breaks: higher quotient → lower registry order → lower OptionId.
///
/// - All `options` are seeded in the output (zero-vote parties are retained).
/// - If the sum of votes is zero, seats are distributed evenly by registry order.
/// - For method divisors, see `divisor` (Part 1).
pub fn apportion_targets(
    total_seats: u32,
    options: &[OptionId],
    vote_totals: &BTreeMap<OptionId, u64>,
    method: AllocationMethod,
) -> BTreeMap<OptionId, u32> {
    // Seed output with all registry options
    let mut alloc: BTreeMap<OptionId, u32> = options.iter().copied().map(|k| (k, 0u32)).collect();
    if total_seats == 0 || options.is_empty() {
        return alloc;
    }

    // Sum votes (u128 accumulator) to detect all-zero corner case
    let mut sum_votes: u128 = 0;
    for &opt in options.iter() {
        sum_votes = sum_votes.saturating_add(u128::from(*vote_totals.get(&opt).unwrap_or(&0)));
    }
    if sum_votes == 0 {
        return round_robin_even_distribution(total_seats, options);
    }

    // Build order index for tie-breaks
    let order_index = build_order_index(options);

    // Seat-by-seat assignment
    for _seat in 0..total_seats {
        let mut best: Option<(OptionId, u64, u128, usize)> = None;
        for &opt in options.iter() {
            let v = *vote_totals.get(&opt).unwrap_or(&0);
            let s = *alloc.get(&opt).unwrap_or(&0);
            let d = divisor(method, s);

            match best {
                None => best = Some((opt, v, d, *order_index.get(&opt).unwrap())),
                Some((b_opt, b_v, b_d, b_ord)) => {
                    // Compare quotients v/d vs b_v/b_d
                    match cmp_quotients(v, d, b_v, b_d) {
                        Ordering::Greater => best = Some((opt, v, d, *order_index.get(&opt).unwrap())),
                        Ordering::Less => { /* keep best */ }
                        Ordering::Equal => {
                            // Tie: lower registry order wins; then lower OptionId
                            let ord = *order_index.get(&opt).unwrap();
                            if ord < b_ord || (ord == b_ord && opt < b_opt) {
                                best = Some((opt, v, d, ord));
                            }
                        }
                    }
                }
            }
        }

        if let Some((winner, _, _, _)) = best {
            if let Some(x) = alloc.get_mut(&winner) {
                *x = x.saturating_add(1);
            }
        } else {
            // No candidate (should be unreachable since options is non-empty)
            break;
        }
    }

    alloc
}
// crates/vm_algo/src/allocation/mmp.rs
//
// Part 3/3 — top-ups & overhang policies (deterministic, no_std-ready)
//
// Implements:
// - compute_topups_and_apply_overhang (three policies):
//   * AllowOverhang: accept overhang; finals = locals + deficits; T_eff = T + Σ overhang
//   * CompensateOthers: fixed house (T); distribute pool = T - Σ locals to non-overhang parties
//   * AddTotalSeats: expand house size minimally so that apportionment satisfies seats ≥ locals
//
// Notes:
// - Uses registry `options` slice for tie-breaks and for seeding zero-vote parties.
// - Integer-first logic; deterministic tie-breaks via registry order then OptionId.
// - Returns Result to surface impossible growth cases (e.g., locals with zero votes).

use alloc::collections::{BTreeMap, BTreeSet};
use alloc::vec::Vec;
use core::cmp::max;

use crate::allocation::mmp::{
    apportion_targets, build_order_index, cmp_quotients, divisor, union_option_ids, MmpError,
    MmpOutcome,
};
use vm_core::ids::OptionId;
use vm_core::variables::{AllocationMethod, OverhangPolicy, TotalSeatsModel};

/// Given intended `targets` and `local_seats`, compute top-ups and apply the
/// chosen overhang policy/model. When policy requires re-apportionment or
/// house-size expansion, uses `method_for_targets` on `vote_totals`.
///
/// Returns an `MmpOutcome` describing per-option targets/topups/finals and the
/// effective total seat count.
pub fn compute_topups_and_apply_overhang(
    options: &[OptionId],
    targets: &BTreeMap<OptionId, u32>,
    local_seats: &BTreeMap<OptionId, u32>,
    overhang_policy: OverhangPolicy,
    _total_seats_model: TotalSeatsModel, // placeholder for future variants (e.g., modified Sainte-Laguë first divisor)
    method_for_targets: AllocationMethod,
    vote_totals: &BTreeMap<OptionId, u64>,
) -> Result<MmpOutcome, MmpError> {
    // Build a stable set of all option IDs present across inputs + registry.
    let opt_map: BTreeMap<OptionId, u8> = options.iter().copied().map(|k| (k, 0)).collect();
    let mut all_ids: BTreeSet<OptionId> = union_option_ids(targets, local_seats, &opt_map);
    for k in vote_totals.keys() {
        all_ids.insert(*k);
    }

    // Sums (128-bit to avoid overflow)
    let mut target_sum: u128 = 0;
    let mut local_sum: u128 = 0;
    for k in all_ids.iter() {
        target_sum = target_sum.saturating_add(u128::from(*targets.get(k).unwrap_or(&0)));
        local_sum = local_sum.saturating_add(u128::from(*local_seats.get(k).unwrap_or(&0)));
    }

    // Compute per-option deficits and overhangs on the given targets.
    let mut deficits: BTreeMap<OptionId, u32> = BTreeMap::new();
    let mut overhangs: BTreeMap<OptionId, u32> = BTreeMap::new();
    for k in all_ids.iter() {
        let t = *targets.get(k).unwrap_or(&0);
        let l = *local_seats.get(k).unwrap_or(&0);
        if t >= l {
            deficits.insert(*k, t - l);
            overhangs.insert(*k, 0);
        } else {
            deficits.insert(*k, 0);
            overhangs.insert(*k, l - t);
        }
    }

    // Registry order index for deterministic tie-breaks in capped distributions.
    let order_index = build_order_index(options);

    match overhang_policy {
        OverhangPolicy::AllowOverhang => {
            // Top-ups exactly cover deficits; finals = locals + deficits;
            // effective total seats increases by Σ overhang.
            let mut topups: BTreeMap<OptionId, u32> = BTreeMap::new();
            let mut finals: BTreeMap<OptionId, u32> = BTreeMap::new();
            let mut t_eff: u128 = target_sum;

            for k in all_ids.iter() {
                let up = *deficits.get(k).unwrap_or(&0);
                let l = *local_seats.get(k).unwrap_or(&0);
                let oh = *overhangs.get(k).unwrap_or(&0);
                topups.insert(*k, up);
                finals.insert(*k, l.saturating_add(up));
                t_eff = t_eff.saturating_add(u128::from(oh));
            }

            let outcome = MmpOutcome {
                targets: targets.clone(),
                topups,
                finals,
                effective_total_seats: (t_eff.min(u32::MAX as u128)) as u32,
                overhang_by_option: overhangs,
            };
            debug_assert!(sum_map_equals(&outcome.finals) == outcome.effective_total_seats as u128);
            Ok(outcome)
        }

        OverhangPolicy::CompensateOthers => {
            // Fixed house size = T (the given targets' total). Pool = max(T - Σ locals, 0).
            let T: u32 = (target_sum.min(u32::MAX as u128)) as u32;
            let local_total_u32: u32 = (local_sum.min(u32::MAX as u128)) as u32;
            let pool: u32 = T.saturating_sub(local_total_u32);

            // Assign pool seats to **non-overhang** options (deficit > 0) via highest-averages,
            // capped to each option's deficit.
            let mut assigned: BTreeMap<OptionId, u32> =
                all_ids.iter().copied().map(|k| (k, 0u32)).collect();

            if pool > 0 {
                for _ in 0..pool {
                    // Pick best eligible option deterministically.
                    let mut best: Option<(OptionId, u64, u128, usize)> = None;
                    for id in all_ids.iter() {
                        let cap = *deficits.get(id).unwrap_or(&0);
                        let already = *assigned.get(id).unwrap_or(&0);
                        if cap == 0 || already >= cap {
                            continue; // overhang or cap reached
                        }
                        let v = *vote_totals.get(id).unwrap_or(&0);
                        let d = divisor(method_for_targets, already);

                        match best {
                            None => {
                                let ord = *order_index.get(id).unwrap_or(&usize::MAX);
                                best = Some((*id, v, d, ord));
                            }
                            Some((b_id, b_v, b_d, b_ord)) => {
                                use core::cmp::Ordering::*;
                                match cmp_quotients(v, d, b_v, b_d) {
                                    Greater => {
                                        let ord = *order_index.get(id).unwrap_or(&usize::MAX);
                                        best = Some((*id, v, d, ord));
                                    }
                                    Less => {}
                                    Equal => {
                                        let ord = *order_index.get(id).unwrap_or(&usize::MAX);
                                        if ord < b_ord || (ord == b_ord && *id < b_id) {
                                            best = Some((*id, v, d, ord));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if let Some((pick, _, _, _)) = best {
                        if let Some(x) = assigned.get_mut(&pick) {
                            *x = x.saturating_add(1);
                        }
                    } else {
                        // No assignable seat (all caps reached) — stop early.
                        break;
                    }
                }
            }

            // Build topups/finals; overhangs are kept (no compensation to overhang options themselves).
            let mut topups: BTreeMap<OptionId, u32> = BTreeMap::new();
            let mut finals: BTreeMap<OptionId, u32> = BTreeMap::new();
            for k in all_ids.iter() {
                let add = *assigned.get(k).unwrap_or(&0);
                let l = *local_seats.get(k).unwrap_or(&0);
                topups.insert(*k, add);
                finals.insert(*k, l.saturating_add(add));
            }

            let outcome = MmpOutcome {
                targets: targets.clone(),
                topups,
                finals,
                effective_total_seats: T,
                overhang_by_option: overhangs,
            };
            // In a perfect fill, Σ finals == T + Σ overhang? Here finals excludes explicit overhang bump;
            // with fixed house, Σ finals should equal max(T, Σ locals) but we set pool = T - Σ locals,
            // so Σ finals == T (or less if deficits < pool and we broke early).
            debug_assert!(sum_map_equals(&outcome.finals) as u32 <= outcome.effective_total_seats);
            Ok(outcome)
        }

        OverhangPolicy::AddTotalSeats => {
            // Expand house size minimally until an **unconstrained apportionment**
            // assigns seats ≥ locals for every option. This may be impossible if
            // some option has locals > 0 but zero votes; detect that early.
            for id in all_ids.iter() {
                let l = *local_seats.get(id).unwrap_or(&0);
                let v = *vote_totals.get(id).unwrap_or(&0);
                if l > 0 && v == 0 {
                    return Err(MmpError::NoViableApportionment { option_id: *id });
                }
            }

            let mut T: u32 = max(
                (target_sum.min(u32::MAX as u128)) as u32,
                (local_sum.min(u32::MAX as u128)) as u32,
            );

            // Monotone search upwards; guaranteed to terminate if every party with locals has votes.
            // Add a conservative iteration cap to avoid pathological loops.
            let mut iters: u32 = 0;
            let cap: u32 = u32::MAX; // natural hard cap

            loop {
                let t_k = apportion_targets(T, options, vote_totals, method_for_targets);

                // Check feasibility: apportionment meets or exceeds locals component-wise.
                let mut ok = true;
                for id in all_ids.iter() {
                    let l = *local_seats.get(id).unwrap_or(&0);
                    let t = *t_k.get(id).unwrap_or(&0);
                    if t < l {
                        ok = false;
                        break;
                    }
                }

                if ok {
                    // No overhang remains under this expanded house.
                    let mut topups: BTreeMap<OptionId, u32> = BTreeMap::new();
                    let mut finals: BTreeMap<OptionId, u32> = BTreeMap::new();
                    let mut new_targets: BTreeMap<OptionId, u32> = BTreeMap::new();
                    let mut zeros: BTreeMap<OptionId, u32> = BTreeMap::new();

                    for id in all_ids.iter() {
                        let l = *local_seats.get(id).unwrap_or(&0);
                        let t = *t_k.get(id).unwrap_or(&0);
                        let up = t.saturating_sub(l);
                        topups.insert(*id, up);
                        finals.insert(*id, t);
                        new_targets.insert(*id, t);
                        zeros.insert(*id, 0);
                    }

                    let outcome = MmpOutcome {
                        targets: new_targets,
                        topups,
                        finals,
                        effective_total_seats: T,
                        overhang_by_option: zeros, // by construction, zero overhang
                    };
                    debug_assert!(sum_map_equals(&outcome.finals) as u32 == outcome.effective_total_seats);
                    return Ok(outcome);
                }

                // Grow T and continue.
                if T == cap {
                    // Should be unreachable given the early zero-vote guard.
                    return Err(MmpError::NoViableApportionment {
                        option_id: *all_ids.iter().next().unwrap(), // placeholder
                    });
                }
                T = T.saturating_add(1);
                iters = iters.saturating_add(1);
                // Optional: break after very large search to avoid CPU blowups in adversarial inputs.
                // if iters > 10_000_000 { return Err(MmpError::NoViableApportionment { option_id: *all_ids.iter().next().unwrap() }); }
            }
        }
    }
}

/// Sum helper (u32 values) → u128 total.
#[inline]
fn sum_map_equals(map: &BTreeMap<OptionId, u32>) -> u128 {
    map.values().fold(0u128, |acc, &v| acc + (v as u128))
}

--------------------------------------------------------------------------------
FILE: crates/vm_algo/src/gates_frontier.rs
--------------------------------------------------------------------------------
//! crates/vm_algo/src/gates_frontier.rs
//! Decision gates (quorum → national majority → optional double-majority → symmetry)
//! and, when passed, frontier mapping (bands, contiguity & flags). Pure integer math,
//! deterministic ordering, no RNG (ties live elsewhere).

use alloc::collections::{BTreeMap, BTreeSet};
use alloc::string::String;

use vm_core::{
    ids::UnitId,
    rounding::ge_percent, // integer test: a/b >= p%
    variables::Params,
};

// ---------------- Types -------------------------------------------------------------------------

/// Inputs required by the gate checks (aggregates + per-unit basics).
#[derive(Clone, Debug, Default)]
pub struct GateInputs {
    pub nat_ballots_cast: u64,
    pub nat_invalid_ballots: u64, // currently unused in gates; keep if policy evolves
    pub nat_valid_ballots: u64,
    pub nat_eligible_roll: u64,

    /// Per-region valid ballots and support for change (aggregated upstream).
    pub region_valid_ballots: BTreeMap<String, u64>,
    pub region_support_for_change: BTreeMap<String, u64>,

    /// Per-unit basics for quorum and support.
    pub unit_valid_ballots: BTreeMap<UnitId, u64>,
    pub unit_ballots_cast: BTreeMap<UnitId, u64>,
    pub unit_eligible_roll: BTreeMap<UnitId, u64>,
    /// Numerator for approval/support rate per unit (denominator is valid_ballots, per spec).
    pub unit_support_for_change: BTreeMap<UnitId, u64>,
}

/// Outcome of decision gates (used by pipeline to decide whether to run frontier).
#[derive(Clone, Debug, Default)]
pub struct GateResult {
    pub quorum_national: bool,
    /// Units meeting per-unit quorum (021). A policy outside this module decides how to use it.
    pub quorum_per_unit_passset: BTreeSet<UnitId>,
    pub majority_national: bool,
    pub majority_regional: bool, // meaningful iff double_majority enabled
    pub double_majority: bool,
    pub symmetry: bool,
    pub pass: bool,
}

// ---------------- Param access view -------------------------------------------------------------
//
// NOTE: These helpers assume `Params` exposes deterministic getters for the needed VM-VARs.
// Exact domains/defaults live in Annex A and Doc 2; this module reads them only at the
// documented touchpoints (4B gates, 4C frontier). See docs cited in the file header.

pub trait GatesFrontierParamView {
    // 020–029 (gates)
    fn quorum_global_pct_020(&self) -> u8;
    fn quorum_per_unit_pct_021(&self) -> u8;
    fn national_majority_pct_022(&self) -> u8;

    /// Regional majority cutoff (023). Applied per-region to compute a count of "passing" regions.
    fn regional_majority_pct_023(&self) -> u8;

    /// Whether regional double-majority is enabled (024).
    fn double_majority_enabled_024(&self) -> bool;

    /// Symmetry toggle (025). Policy for exceptions lives in params (029).
    fn symmetry_enabled_025(&self) -> bool;
    fn symmetry_breaks_due_to_exceptions_029(&self) -> bool;

    // 040–042, 047–049 (frontier) — used in part 2
    fn frontier_mode_is_none_040(&self) -> bool;
    /// Ordered, non-overlapping bands: (min_pct, max_pct, status)
    fn frontier_bands_042(&self) -> alloc::vec::Vec<(u8, u8, String)>;
    fn frontier_allow_land_047(&self) -> bool;
    fn frontier_allow_bridge_047(&self) -> bool;
    fn frontier_allow_water_047(&self) -> bool;
    fn frontier_island_rule_ferry_allowed_048(&self) -> bool;
}

// Blanket impl forwards to `Params`. Implement the getters in vm_core.
impl GatesFrontierParamView for Params {
    #[inline] fn quorum_global_pct_020(&self) -> u8 { self.quorum_global_pct_020() }
    #[inline] fn quorum_per_unit_pct_021(&self) -> u8 { self.quorum_per_unit_pct_021() }
    #[inline] fn national_majority_pct_022(&self) -> u8 { self.national_majority_pct_022() }
    #[inline] fn regional_majority_pct_023(&self) -> u8 { self.regional_majority_pct_023() }
    #[inline] fn double_majority_enabled_024(&self) -> bool { self.double_majority_enabled_024() }
    #[inline] fn symmetry_enabled_025(&self) -> bool { self.symmetry_enabled_025() }
    #[inline] fn symmetry_breaks_due_to_exceptions_029(&self) -> bool { self.symmetry_breaks_due_to_exceptions_029() }

    #[inline] fn frontier_mode_is_none_040(&self) -> bool { self.frontier_mode_is_none_040() }
    #[inline] fn frontier_bands_042(&self) -> alloc::vec::Vec<(u8, u8, String)> { self.frontier_bands_042() }
    #[inline] fn frontier_allow_land_047(&self) -> bool { self.frontier_allow_land_047() }
    #[inline] fn frontier_allow_bridge_047(&self) -> bool { self.frontier_allow_bridge_047() }
    #[inline] fn frontier_allow_water_047(&self) -> bool { self.frontier_allow_water_047() }
    #[inline] fn frontier_island_rule_ferry_allowed_048(&self) -> bool { self.frontier_island_rule_ferry_allowed_048() }
}

// ---------------- Gates (020–029; majority uses valid_ballots as denominator) -------------------

/// Apply quorum + majority (+ optional double-majority & symmetry) deterministically.
pub fn apply_decision_gates(inp: &GateInputs, p: &impl GatesFrontierParamView) -> GateResult {
    // Quorum (national): Σ ballots_cast / Σ eligible_roll ≥ 020
    let quorum_nat = compute_quorum_national(
        inp.nat_ballots_cast,
        inp.nat_eligible_roll,
        p.quorum_global_pct_020(),
    );

    // Per-unit quorum (021): collect pass set
    let quorum_set = compute_quorum_per_unit(
        &inp.unit_ballots_cast,
        &inp.unit_eligible_roll,
        p.quorum_per_unit_pct_021(),
    );

    // National approval majority (022): approvals_for_change / valid_ballots ≥ cutoff
    // Denominator is *valid_ballots* (explicitly ignores blank toggle for approval majority).
    let nat_support_sum: u64 = inp.unit_support_for_change.values().copied().sum();
    let maj_nat = national_approval_majority(
        inp.nat_valid_ballots,
        nat_support_sum,
        p.national_majority_pct_022(),
    );

    // Double-majority (024/023) over regions:
    // Policy here = "majority in a majority of regions" (common scheme):
    // - For each region with v_r > 0, mark pass_r = support_r / valid_r ≥ cutoff_023.
    // - maj_regional = passed_regions ≥ ceil(R/2). If no regions with v_r > 0, treat as N/A → pass.
    let maj_regional = if p.double_majority_enabled_024() {
        let mut regions = 0u64;
        let mut passed = 0u64;
        for (rid, v_r) in &inp.region_valid_ballots {
            if *v_r == 0 {
                continue;
            }
            regions += 1;
            let s_r = *inp.region_support_for_change.get(rid).unwrap_or(&0);
            if ge_percent(s_r, *v_r, p.regional_majority_pct_023()) {
                passed += 1;
            }
        }
        if regions == 0 {
            true // N/A ⇒ pass (do not accidentally fail the gate when regions are not configured)
        } else {
            // majority-of-regions test
            let half_up = (regions + 1) / 2;
            passed >= half_up
        }
    } else {
        // regional component disabled
        true
    };

    let dbl = maj_nat && maj_regional;

    // Symmetry (025/029). If enabled, rely on params to flag exceptions that break symmetry.
    // With no explicit exception policy here, we accept symmetry when there is no flagged break.
    let symmetry = if p.symmetry_enabled_025() {
        !p.symmetry_breaks_due_to_exceptions_029()
    } else {
        true
    };

    let pass = quorum_nat && dbl && symmetry;

    GateResult {
        quorum_national: quorum_nat,
        quorum_per_unit_passset: quorum_set,
        majority_national: maj_nat,
        majority_regional: maj_regional,
        double_majority: dbl,
        symmetry,
        pass,
    }
}

/// turnout ≥ cutoff? (a/b ≥ p%)
#[inline]
fn compute_quorum_national(ballots_cast: u64, eligible_roll: u64, cutoff_pct: u8) -> bool {
    eligible_roll > 0 && ge_percent(ballots_cast, eligible_roll, cutoff_pct)
}

/// For each unit, test turnout ≥ cutoff and return the pass set.
/// NOTE: iterate the **eligible roll** as ground truth; treat missing ballots_cast as 0.
fn compute_quorum_per_unit(
    unit_ballots_cast: &BTreeMap<UnitId, u64>,
    unit_eligible_roll: &BTreeMap<UnitId, u64>,
    cutoff_pct: u8,
) -> BTreeSet<UnitId> {
    let mut out = BTreeSet::new();
    for (u, roll) in unit_eligible_roll {
        let cast = *unit_ballots_cast.get(u).unwrap_or(&0);
        if *roll > 0 && ge_percent(cast, *roll, cutoff_pct) {
            out.insert(u.clone());
        }
    }
    out
}

/// approval majority is approvals_for_change / valid_ballots ≥ cutoff (fixed denominator).
#[inline]
fn national_approval_majority(valid_ballots: u64, approvals_for_change: u64, cutoff_pct: u8) -> bool {
    valid_ballots > 0 && ge_percent(approvals_for_change, valid_ballots, cutoff_pct)
}

// --------- Frontier types (used in part 2) -----------------------------------------------------

/// Edge kinds allowed when checking contiguity (subset chosen by VM-VAR-047/048).
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]
pub enum FrontierEdge {
    Land,
    Bridge,
    Water,
}

/// Per-unit flags emitted with the assigned frontier status.
#[derive(Clone, Debug, Default)]
pub struct FrontierFlags {
    pub contiguity_ok: bool,
    pub mediation_flagged: bool,
    pub protected_override_used: bool,
    pub enclave: bool,
}

/// Per-unit frontier result (status string drawn from configured bands).
#[derive(Clone, Debug, Default)]
pub struct FrontierUnit {
    pub status: String,
    pub flags: FrontierFlags,
}

/// Frontier summary for quick reporting/labelling hooks.
#[derive(Clone, Debug, Default)]
pub struct FrontierSummary {
    pub band_counts: BTreeMap<String, u64>,
    pub mediation_units: u64,
    pub enclave_units: u64,
    pub any_protected_override: bool,
}

/// Full frontier mapping output.
#[derive(Clone, Debug, Default)]
pub struct FrontierOut {
    /// Stable map keyed by UnitId (ordered).
    pub units: BTreeMap<UnitId, FrontierUnit>,
    pub summary: FrontierSummary,
}

/// Inputs for the frontier mapping step (execute only if gates.pass == true).
#[derive(Clone, Debug, Default)]
pub struct FrontierInputs {
    /// Observed per-unit support ratios: (numerator, denominator).
    pub unit_support_for_change: BTreeMap<UnitId, (u64, u64)>,
    /// Universe of units considered (post-scope).
    pub units_all: BTreeSet<UnitId>,
    /// Undirected adjacency edges with typed kind.
    pub adjacency: alloc::vec::Vec<(UnitId, UnitId, FrontierEdge)>,
    /// Units that are protected; if their assigned status would imply change, apply override.
    pub protected_units: BTreeSet<UnitId>,
}
// ---------------- Frontier mapping (040–042, 047–049) ------------------------------------------

/// Map per-unit support to band statuses, then flag contiguity/mediation/protection/enclaves.
/// Call this only if the pipeline decided to run frontier after gates.
pub fn map_frontier(inp: &FrontierInputs, p: &impl GatesFrontierParamView) -> FrontierOut {
    let mut out = FrontierOut::default();

    // Fast escape: mode = none ⇒ everyone “none”, no flags.
    if p.frontier_mode_is_none_040() {
        for u in &inp.units_all {
            out.units.insert(
                u.clone(),
                FrontierUnit {
                    status: alloc::string::String::from("none"),
                    flags: FrontierFlags::default(),
                },
            );
        }
        return summarize_frontier(out);
    }

    // Bands: ordered, non-overlapping; compare using integer tenths (floor; no floats).
    let bands = p.frontier_bands_042(); // Vec<(min_pct: u8, max_pct: u8, status: String)>
    let bands_tenths: alloc::vec::Vec<(u16, u16, alloc::string::String)> = bands
        .into_iter()
        .map(|(lo, hi, s)| ((lo as u16) * 10, (hi as u16) * 10, s))
        .collect();

    // Allowed edge kinds for contiguity.
    let mut allowed: BTreeSet<FrontierEdge> = BTreeSet::new();
    if p.frontier_allow_land_047() {
        allowed.insert(FrontierEdge::Land);
    }
    if p.frontier_allow_bridge_047() {
        allowed.insert(FrontierEdge::Bridge);
    }
    if p.frontier_allow_water_047() {
        allowed.insert(FrontierEdge::Water);
    }
    // Island/ferry rule (048): when enabled, ensure Bridge/Water are admissible.
    if p.frontier_island_rule_ferry_allowed_048() {
        allowed.insert(FrontierEdge::Bridge);
        allowed.insert(FrontierEdge::Water);
    }

    // Assign statuses from observed support.
    for u in &inp.units_all {
        let (num, den) = inp.unit_support_for_change.get(u).copied().unwrap_or((0, 0));
        let pct_tenths: u16 = if den == 0 {
            0
        } else {
            // floor((num * 1000) / den) — integer tenths; saturating to u16 range.
            ((num.saturating_mul(1000)) / den).min(u16::MAX as u64) as u16
        };
        let status = assign_band_status(pct_tenths, &bands_tenths);
        out.units.insert(
            u.clone(),
            FrontierUnit {
                status,
                flags: FrontierFlags::default(),
            },
        );
    }

    // Apply protected overrides BEFORE contiguity so components/flags reflect final statuses.
    for u in &inp.protected_units {
        if let Some(unit) = out.units.get_mut(u) {
            if unit.status != "none" {
                unit.flags.protected_override_used = true;
                unit.status = alloc::string::String::from("none");
            }
        }
    }

    // Group units by status for component analysis.
    let by_status: BTreeMap<_, BTreeSet<_>> = {
        let mut map = BTreeMap::<alloc::string::String, BTreeSet<UnitId>>::new();
        for (u, fu) in &out.units {
            map.entry(fu.status.clone()).or_default().insert(u.clone());
        }
        map
    };

    // For each non-"none" status, compute connected components and flag mediation if fragmented.
    let adjacency = &inp.adjacency;
    for (status, members) in &by_status {
        if status == "none" {
            continue;
        }
        let comps = contiguous_components(&allowed, adjacency, members);
        let fragmented = comps.len() > 1;
        if fragmented {
            for comp in &comps {
                for u in comp {
                    if let Some(unit) = out.units.get_mut(u) {
                        unit.flags.mediation_flagged = true;
                    }
                }
            }
        }
    }

    // Set contiguity_ok and enclave flags:
    // - contiguity_ok: unit has ≥1 admissible neighbor with the same status.
    // - enclave: unit has ≥2 admissible neighbors and none share its status.
    for (u, fu) in out.units.iter_mut() {
        if fu.status == "none" {
            continue;
        }
        let mut neighbors_total = 0usize;
        let mut neighbors_same = 0usize;

        for (a, b, kind) in adjacency {
            if !allowed.contains(kind) {
                continue;
            }
            // Undirected: consider both orientations.
            if a == u || b == u {
                let v = if a == u { b } else { a };
                if let Some(g) = out.units.get(v) {
                    neighbors_total += 1;
                    if g.status == fu.status {
                        neighbors_same += 1;
                    }
                }
            }
        }

        fu.flags.contiguity_ok = neighbors_same >= 1;
        fu.flags.enclave = neighbors_total >= 2 && neighbors_same == 0;
    }

    summarize_frontier(out)
}

// ---------------- Internals (helpers) -----------------------------------------------------------

fn assign_band_status(
    pct_tenths: u16,
    bands: &[(u16, u16, alloc::string::String)],
) -> alloc::string::String {
    for (lo, hi, s) in bands {
        if *lo <= pct_tenths && pct_tenths <= *hi {
            return s.clone();
        }
    }
    // If no band matches, return the lowest-priority "none".
    alloc::string::String::from("none")
}

use alloc::collections::VecDeque;

/// Return connected components among `members`, using only `allowed` edge kinds.
fn contiguous_components(
    allowed: &BTreeSet<FrontierEdge>,
    adjacency: &[(UnitId, UnitId, FrontierEdge)],
    members: &BTreeSet<UnitId>,
) -> alloc::vec::Vec<BTreeSet<UnitId>> {
    // Build adjacency list restricted to members + allowed edges
    let mut graph: BTreeMap<UnitId, alloc::vec::Vec<UnitId>> = BTreeMap::new();
    for u in members {
        graph.entry(u.clone()).or_default();
    }
    for (a, b, k) in adjacency {
        if !allowed.contains(k) {
            continue;
        }
        if members.contains(a) && members.contains(b) {
            graph.entry(a.clone()).or_default().push(b.clone());
            graph.entry(b.clone()).or_default().push(a.clone());
        }
    }

    // BFS over graph
    let mut seen: BTreeSet<UnitId> = BTreeSet::new();
    let mut comps: alloc::vec::Vec<BTreeSet<UnitId>> = alloc::vec::Vec::new();
    for u in members {
        if seen.contains(u) {
            continue;
        }
        let mut comp: BTreeSet<UnitId> = BTreeSet::new();
        let mut q = VecDeque::new();
        q.push_back(u.clone());
        seen.insert(u.clone());
        comp.insert(u.clone());

        while let Some(x) = q.pop_front() {
            if let Some(nei) = graph.get(&x) {
                for v in nei {
                    if seen.insert(v.clone()) {
                        q.push_back(v.clone());
                        comp.insert(v.clone());
                    }
                }
            }
        }
        comps.push(comp);
    }
    comps
}

fn summarize_frontier(mut out: FrontierOut) -> FrontierOut {
    // Fill summary counts and booleans.
    for (_, u) in &out.units {
        *out.summary.band_counts.entry(u.status.clone()).or_insert(0) += 1;
        if u.flags.mediation_flagged {
            out.summary.mediation_units += 1;
        }
        if u.flags.enclave {
            out.summary.enclave_units += 1;
        }
        if u.flags.protected_override_used {
            out.summary.any_protected_override = true;
        }
    }
    out
}
#[cfg(test)]
mod tests {
    use super::*;
    use alloc::string::ToString;
    use alloc::vec;

    // --- Helpers ------------------------------------------------------------------------------

    fn uid(s: &str) -> UnitId {
        s.parse().expect("unit id")
    }

    // Baseline policy: DM on; frontier bands [0..49]=hold, [50..100]=change; only Land allowed.
    struct PBase;
    impl GatesFrontierParamView for PBase {
        fn quorum_global_pct_020(&self) -> u8 { 50 }
        fn quorum_per_unit_pct_021(&self) -> u8 { 40 }
        fn national_majority_pct_022(&self) -> u8 { 55 }
        fn regional_majority_pct_023(&self) -> u8 { 55 }
        fn double_majority_enabled_024(&self) -> bool { true }
        fn symmetry_enabled_025(&self) -> bool { false }
        fn symmetry_breaks_due_to_exceptions_029(&self) -> bool { false }

        fn frontier_mode_is_none_040(&self) -> bool { false }
        fn frontier_bands_042(&self) -> alloc::vec::Vec<(u8, u8, alloc::string::String)> {
            vec![(0, 49, "hold".into()), (50, 100, "change".into())]
        }
        fn frontier_allow_land_047(&self) -> bool { true }
        fn frontier_allow_bridge_047(&self) -> bool { false }
        fn frontier_allow_water_047(&self) -> bool { false }
        fn frontier_island_rule_ferry_allowed_048(&self) -> bool { false }
    }

    // Frontier mode = none
    struct PNone;
    impl GatesFrontierParamView for PNone {
        fn quorum_global_pct_020(&self) -> u8 { 50 }
        fn quorum_per_unit_pct_021(&self) -> u8 { 40 }
        fn national_majority_pct_022(&self) -> u8 { 55 }
        fn regional_majority_pct_023(&self) -> u8 { 55 }
        fn double_majority_enabled_024(&self) -> bool { true }
        fn symmetry_enabled_025(&self) -> bool { false }
        fn symmetry_breaks_due_to_exceptions_029(&self) -> bool { false }

        fn frontier_mode_is_none_040(&self) -> bool { true }
        fn frontier_bands_042(&self) -> alloc::vec::Vec<(u8, u8, alloc::string::String)> {
            vec![(0, 49, "hold".into()), (50, 100, "change".into())]
        }
        fn frontier_allow_land_047(&self) -> bool { true }
        fn frontier_allow_bridge_047(&self) -> bool { false }
        fn frontier_allow_water_047(&self) -> bool { false }
        fn frontier_island_rule_ferry_allowed_048(&self) -> bool { false }
    }

    // Ferry allowed (adds Bridge/Water even if 047 denied them)
    struct PWaterFerry;
    impl GatesFrontierParamView for PWaterFerry {
        fn quorum_global_pct_020(&self) -> u8 { 50 }
        fn quorum_per_unit_pct_021(&self) -> u8 { 40 }
        fn national_majority_pct_022(&self) -> u8 { 55 }
        fn regional_majority_pct_023(&self) -> u8 { 55 }
        fn double_majority_enabled_024(&self) -> bool { true }
        fn symmetry_enabled_025(&self) -> bool { false }
        fn symmetry_breaks_due_to_exceptions_029(&self) -> bool { false }

        fn frontier_mode_is_none_040(&self) -> bool { false }
        fn frontier_bands_042(&self) -> alloc::vec::Vec<(u8, u8, alloc::string::String)> {
            vec![(0, 49, "hold".into()), (50, 100, "change".into())]
        }
        fn frontier_allow_land_047(&self) -> bool { true }
        fn frontier_allow_bridge_047(&self) -> bool { false }
        fn frontier_allow_water_047(&self) -> bool { false }
        fn frontier_island_rule_ferry_allowed_048(&self) -> bool { true }
    }

    // --- Gates ---------------------------------------------------------------------------------

    #[test]
    fn quorum_and_majority_and_double_majority() {
        let mut gi = GateInputs::default();
        gi.nat_ballots_cast = 600;
        gi.nat_eligible_roll = 1000; // 60% >= 50% → quorum_national true
        gi.nat_valid_ballots = 500;

        // per-unit quorum: U1 passes (40%), U2 fails (0%)
        gi.unit_eligible_roll.insert(uid("U1"), 100);
        gi.unit_eligible_roll.insert(uid("U2"), 100);
        gi.unit_ballots_cast.insert(uid("U1"), 40);

        // national majority: 300/500 = 60% >= 55%
        gi.unit_support_for_change.insert(uid("U1"), 200);
        gi.unit_support_for_change.insert(uid("U2"), 100);

        // regions: R1 passes (60%), R2 fails (40%); 1/2 regions → passes with our ceil(R/2) rule
        gi.region_valid_ballots.insert("R1".into(), 100);
        gi.region_support_for_change.insert("R1".into(), 60);
        gi.region_valid_ballots.insert("R2".into(), 100);
        gi.region_support_for_change.insert("R2".into(), 40);

        let p = PBase;
        let gr = apply_decision_gates(&gi, &p);

        assert!(gr.quorum_national);
        assert!(gr.majority_national);
        assert!(gr.majority_regional);
        assert!(gr.double_majority);
        assert!(gr.pass);

        // per-unit quorum set contains only U1
        assert!(gr.quorum_per_unit_passset.contains(&uid("U1")));
        assert!(!gr.quorum_per_unit_passset.contains(&uid("U2")));
    }

    #[test]
    fn double_majority_no_regions_treated_as_pass() {
        let mut gi = GateInputs::default();
        gi.nat_ballots_cast = 500;
        gi.nat_eligible_roll = 800;
        gi.nat_valid_ballots = 400;
        gi.unit_support_for_change.insert(uid("U1"), 240); // 60%

        let p = PBase;
        let gr = apply_decision_gates(&gi, &p);
        assert!(gr.majority_national);
        assert!(gr.majority_regional); // N/A ⇒ pass
        assert!(gr.double_majority);
        assert!(gr.pass);
    }

    // --- Frontier ------------------------------------------------------------------------------

    #[test]
    fn frontier_mode_none_assigns_none_everywhere() {
        let mut fi = FrontierInputs::default();
        fi.units_all.extend([uid("A"), uid("B"), uid("C")]);

        let out = map_frontier(&fi, &PNone);
        for u in [uid("A"), uid("B"), uid("C")] {
            assert_eq!(out.units.get(&u).unwrap().status, "none".to_string());
        }
        assert_eq!(*out.summary.band_counts.get("none").unwrap_or(&0), 3);
        assert!(!out.summary.any_protected_override);
    }

    #[test]
    fn frontier_mediation_and_contiguity_ok_semantics() {
        // A,B,C are "change" (60%); B—C connected; A isolated → two components → mediation=true.
        let (a, b, c) = (uid("A"), uid("B"), uid("C"));

        let mut fi = FrontierInputs::default();
        fi.units_all.extend([a.clone(), b.clone(), c.clone()]);
        fi.unit_support_for_change.insert(a.clone(), (60, 100));
        fi.unit_support_for_change.insert(b.clone(), (60, 100));
        fi.unit_support_for_change.insert(c.clone(), (60, 100));
        fi.adjacency.push((b.clone(), c.clone(), FrontierEdge::Land));

        let out = map_frontier(&fi, &PBase);

        // A is singleton "change": contiguity_ok=false
        assert_eq!(out.units.get(&a).unwrap().status, "change");
        assert!(!out.units.get(&a).unwrap().flags.contiguity_ok);

        // B and C have same-status neighbor: contiguity_ok=true
        assert!(out.units.get(&b).unwrap().flags.contiguity_ok);
        assert!(out.units.get(&c).unwrap().flags.contiguity_ok);

        // Mediation flagged for all members of fragmented status "change"
        assert!(out.units.get(&a).unwrap().flags.mediation_flagged);
        assert!(out.units.get(&b).unwrap().flags.mediation_flagged);
        assert!(out.units.get(&c).unwrap().flags.mediation_flagged);
        assert!(out.summary.mediation_units >= 3);
    }

    #[test]
    fn frontier_enclave_rule_requires_two_neighbors_and_none_same() {
        // D has two neighbors E,F of different status → enclave=true for D.
        let (d, e, f) = (uid("D"), uid("E"), uid("F"));

        let mut fi = FrontierInputs::default();
        fi.units_all.extend([d.clone(), e.clone(), f.clone()]);
        fi.unit_support_for_change.insert(d.clone(), (40, 100)); // hold
        fi.unit_support_for_change.insert(e.clone(), (60, 100)); // change
        fi.unit_support_for_change.insert(f.clone(), (60, 100)); // change
        fi.adjacency.push((d.clone(), e.clone(), FrontierEdge::Land));
        fi.adjacency.push((d.clone(), f.clone(), FrontierEdge::Land));

        let out = map_frontier(&fi, &PBase);

        let ud = out.units.get(&d).unwrap();
        assert_eq!(ud.status, "hold");
        assert!(ud.flags.enclave);
        assert!(!ud.flags.contiguity_ok); // no same-status neighbor
    }

    #[test]
    fn frontier_ferry_rule_allows_water_edges() {
        // G and H are change, connected only by water. With ferry rule, contiguity_ok=true.
        let (g, h) = (uid("G"), uid("H"));

        let mut fi = FrontierInputs::default();
        fi.units_all.extend([g.clone(), h.clone()]);
        fi.unit_support_for_change.insert(g.clone(), (60, 100));
        fi.unit_support_for_change.insert(h.clone(), (60, 100));
        fi.adjacency.push((g.clone(), h.clone(), FrontierEdge::Water));

        let out = map_frontier(&fi, &PWaterFerry);

        assert_eq!(out.units.get(&g).unwrap().status, "change");
        assert_eq!(out.units.get(&h).unwrap().status, "change");
        assert!(out.units.get(&g).unwrap().flags.contiguity_ok);
        assert!(out.units.get(&h).unwrap().flags.contiguity_ok);
    }

    #[test]
    fn protected_overrides_apply_before_contiguity() {
        // J—K connected change; protect K → K becomes none; J becomes singleton change.
        let (j, k) = (uid("J"), uid("K"));

        let mut fi = FrontierInputs::default();
        fi.units_all.extend([j.clone(), k.clone()]);
        fi.unit_support_for_change.insert(j.clone(), (60, 100));
        fi.unit_support_for_change.insert(k.clone(), (60, 100));
        fi.adjacency.push((j.clone(), k.clone(), FrontierEdge::Land));
        fi.protected_units.insert(k.clone());

        let out = map_frontier(&fi, &PBase);

        assert_eq!(out.units.get(&k).unwrap().status, "none");
        assert!(out.units.get(&k).unwrap().flags.protected_override_used);

        let uj = out.units.get(&j).unwrap();
        assert_eq!(uj.status, "change");
        assert!(!uj.flags.contiguity_ok); // now singleton after protection
        assert!(out.summary.any_protected_override);
    }
}

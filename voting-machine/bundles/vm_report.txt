# bundle: vm_report

--------------------------------------------------------------------------------
FILE: crates/vm_report/Cargo.toml
--------------------------------------------------------------------------------
//! vm_report/src/lib.rs — Pure offline report model + renderers (JSON/HTML).
//!
//! Determinism rules:
//! - No network, no I/O here. Callers supply artifacts already in-memory.
//! - Percent strings use one-decimal formatting without float arithmetic.
//! - Stable section order and field names.
//!
//! Notes:
//! - Inputs are accepted as JSON values (`serde_json::Value`) to avoid tight
//!   coupling with vm_pipeline/vm_io concrete types while keeping signatures
//!   stable across the workspace.
//! - For approval ballots, the model includes an explicit sentence about the
//!   denominator (“approvals / valid ballots”), as required by Doc 7.

#![deny(unsafe_code)]

use std::collections::BTreeMap;

// Re-export the helper requested by the spec (handy for other crates), even if
// we don't consume num/den here. We avoid float math in this crate.
pub use vm_core::rounding::percent_one_decimal_tenths;
pub use vm_core::ids::{ResultId, RunId, FrontierId};

// ---- Artifact type aliases (loosely-coupled) ----
// These keep this crate independent of vm_pipeline/vm_io concrete types.
// Callers pass the already-parsed JSON artifacts produced by the engine.
pub type ResultArtifact = serde_json::Value;
pub type RunRecordArtifact = serde_json::Value;
pub type FrontierMapArtifact = serde_json::Value;
pub type CompareScenariosArtifact = serde_json::Value;

// ===== Errors =====
#[derive(Debug)]
pub enum ReportError {
    Template(&'static str),
    MissingField(&'static str),
    Inconsistent(&'static str),
}

// ===== Model =====
#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct ReportModel {
    pub cover: SectionCover,
    pub snapshot: SectionSnapshot,
    pub eligibility: SectionEligibility,
    pub ballot_method: SectionBallotMethod,
    pub legitimacy_panel: SectionLegitimacy,
    pub outcome_label: SectionOutcome,
    pub frontier: Option<SectionFrontier>,
    pub sensitivity: Option<SectionSensitivity>,
    pub integrity: SectionIntegrity,
}

// --- Sections (minimal but schema-aligned) ---
#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct SectionCover {
    pub title: String,
    pub label: String,                 // "Decisive" | "Marginal" | "Invalid"
    pub reason: Option<String>,
}

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct SnapshotVar { pub key: String, pub value: String }

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct SectionSnapshot { pub items: Vec<SnapshotVar> }

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct SectionEligibility {
    pub roll_policy: String,
    pub registry_source: String,
    pub totals: EligibilityTotals,
    pub per_unit_quorum_note: Option<String>,
}

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct EligibilityTotals { pub eligible_roll: u64, pub ballots_cast: u64, pub valid_ballots: u64 }

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct SectionBallotMethod {
    pub method: String,                // VM-VAR-001
    pub allocation: String,            // VM-VAR-010
    pub weighting: String,             // VM-VAR-030
    pub approval_denominator_sentence: Option<String>, // forced for approval ballots
}

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct GateRow {
    pub name: String,
    pub value_pct_1dp: String,
    pub threshold_pct_0dp: String,
    pub pass: bool,
    pub denom_note: Option<String>,
}

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct SectionLegitimacy {
    pub quorum: GateRow,
    pub majority: GateRow,
    pub double_majority: Option<(GateRow, GateRow)>, // (national, family)
    pub symmetry: Option<bool>,
    pub pass: bool,
    pub reasons: Vec<String>,
}

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct SectionOutcome { pub label: String, pub reason: String, pub national_margin_pp: String }

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct FrontierCounters {
    pub changed: u32,
    pub no_change: u32,
    pub mediation: u32,
    pub enclave: u32,
    pub protected_blocked: u32,
    pub quorum_blocked: u32,
}

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct SectionFrontier {
    pub mode: String,                      // VM-VAR-040
    pub edge_policy: String,               // VM-VAR-047
    pub island_rule: String,               // VM-VAR-048
    pub counters: FrontierCounters,
    pub bands_summary: Vec<String>,
}

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct SectionSensitivity { pub table: Vec<Vec<String>> }

#[cfg_attr(feature = "render_json", derive(serde::Serialize))]
#[derive(Clone, Debug)]
pub struct SectionIntegrity {
    pub result_id: ResultId,
    pub run_id: RunId,
    pub frontier_id: Option<FrontierId>,
    pub engine_vendor: String,
    pub engine_name: String,
    pub engine_version: String,
    pub engine_build: String,
    pub formula_id_hex: String,
    pub tie_policy: String,
    pub tie_seed: Option<String>, // only if tie_policy == "random"
    pub started_utc: String,
    pub finished_utc: String,
}

// ===== API =====

/// Build the report model from artifacts (pure, offline).
///
/// This reads only well-known fields used for presentation. Missing required
/// fields yield `ReportError::MissingField`.
pub fn build_model(
    result: &ResultArtifact,
    run: &RunRecordArtifact,
    frontier: Option<&FrontierMapArtifact>,
    compare: Option<&CompareScenariosArtifact>,
) -> Result<ReportModel, ReportError> {
    // ---- Cover & Outcome ----
    let label = json_get_str(result, "/label")?;
    let label_reason = json_get_str(result, "/label_reason").unwrap_or_else(|_| "n/a".into());
    let cover = SectionCover {
        title: "Voting Model Result".to_string(),
        label: label.clone(),
        reason: Some(label_reason.clone()),
    };
    let national_margin_pp = json_get_i64(result, "/aggregates/national_margin_pp")
        .unwrap_or(0);
    let outcome_label = SectionOutcome {
        label: label.clone(),
        reason: label_reason.clone(),
        national_margin_pp: format!("{} pp", national_margin_pp),
    };

    // ---- Snapshot (selected VM-VAR echoes if present) ----
    let mut snapshot_items = Vec::new();
    if let Ok(bt) = json_get_str(result, "/params/ballot_type") {
        snapshot_items.push(SnapshotVar { key: "ballot_type".into(), value: bt });
    }
    if let Ok(am) = json_get_str(result, "/params/allocation_method") {
        snapshot_items.push(SnapshotVar { key: "allocation_method".into(), value: am });
    }
    if let Ok(th) = json_get_u64(result, "/params/pr_entry_threshold_pct") {
        snapshot_items.push(SnapshotVar { key: "pr_entry_threshold_pct".into(), value: format!("{}%", th) });
    }
    if let Ok(dm) = json_get_bool(result, "/params/double_majority_enabled") {
        snapshot_items.push(SnapshotVar { key: "double_majority_enabled".into(), value: dm.to_string() });
    }
    if let Ok(sym) = json_get_bool(result, "/params/symmetry_enabled") {
        snapshot_items.push(SnapshotVar { key: "symmetry_enabled".into(), value: sym.to_string() });
    }
    let snapshot = SectionSnapshot { items: snapshot_items };

    // ---- Eligibility (totals) ----
    let eligible_roll = json_get_u64(result, "/aggregates/turnout/eligible_roll").unwrap_or(0);
    let ballots_cast = json_get_u64(result, "/aggregates/turnout/ballots_cast").unwrap_or(0);
    let valid_ballots = json_get_u64(result, "/aggregates/turnout/valid_ballots").unwrap_or(0);
    let eligibility = SectionEligibility {
        roll_policy: json_get_str(result, "/params/roll_inclusion_policy").unwrap_or_else(|_| "unspecified".into()),
        registry_source: json_get_str(result, "/provenance/registry_source").unwrap_or_else(|_| "registry".into()),
        totals: EligibilityTotals { eligible_roll, ballots_cast, valid_ballots },
        per_unit_quorum_note: json_get_u64(result, "/params/quorum_per_unit_pct")
            .ok()
            .and_then(|q| if q > 0 { Some(format!("Per-unit quorum applied at {}%", q)) } else { None }),
    };

    // ---- Ballot method (and approval denominator sentence) ----
    let method = json_get_str(result, "/params/ballot_type").unwrap_or_else(|_| "unspecified".into());
    let allocation = json_get_str(result, "/params/allocation_method").unwrap_or_else(|_| "unspecified".into());
    let weighting = json_get_str(result, "/aggregates/weighting_method").unwrap_or_else(|_| "unspecified".into());
    let approval_denominator_sentence =
        if method == "approval" {
            Some("Approval rate is computed as approvals_for_change / valid_ballots.".to_string())
        } else { None };
    let ballot_method = SectionBallotMethod { method, allocation, weighting, approval_denominator_sentence };

    // ---- Legitimacy panel (quorum, majority, double, symmetry) ----
    let gates = result.pointer("/gates")
        .ok_or(ReportError::MissingField("gates"))?;

    let quorum_row = GateRow {
        name: "Quorum".into(),
        value_pct_1dp: json_percent_1dp_from_number(gates.pointer("/quorum/observed"))?,
        threshold_pct_0dp: json_get_u64(gates, "/quorum/threshold_pct").map(|v| format!("{}%", v))?,
        pass: json_get_bool(gates, "/quorum/pass").unwrap_or(false),
        denom_note: None,
    };

    let majority_row = GateRow {
        name: "Majority".into(),
        value_pct_1dp: json_percent_1dp_from_number(gates.pointer("/majority/observed"))?,
        threshold_pct_0dp: json_get_u64(gates, "/majority/threshold_pct").map(|v| format!("{}%", v))?,
        pass: json_get_bool(gates, "/majority/pass").unwrap_or(false),
        denom_note: Some("Approval rate denominator is valid_ballots.".into()),
    };

    let dm = gates.pointer("/double_majority");
    let double_majority = dm.and_then(|dmv| {
        let n = GateRow {
            name: "National".into(),
            value_pct_1dp: json_percent_1dp_from_number(dmv.pointer("/national/observed")).ok()?,
            threshold_pct_0dp: json_get_u64(dmv, "/national/threshold_pct").ok().map(|v| format!("{}%", v))?,
            pass: json_get_bool(dmv, "/national/pass").unwrap_or(false),
            denom_note: Some("Approval rate denominator is valid_ballots.".into()),
        };
        let r = GateRow {
            name: "Family".into(),
            value_pct_1dp: json_percent_1dp_from_number(dmv.pointer("/regional/observed")).ok()?,
            threshold_pct_0dp: json_get_u64(dmv, "/regional/threshold_pct").ok().map(|v| format!("{}%", v))?,
            pass: json_get_bool(dmv, "/regional/pass").unwrap_or(false),
            denom_note: Some("Approval rate denominator is valid_ballots.".into()),
        };
        Some((n, r))
    });

    let symmetry = gates.pointer("/symmetry").and_then(|s| s.get("pass")).and_then(|v| v.as_bool());

    // Overall pass and reasons list (stable tokens)
    let gates_pass = json_get_bool(gates, "/pass").unwrap_or(false);
    let reasons = result.pointer("/gates/reasons")
        .and_then(|v| v.as_array())
        .map(|arr| arr.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect::<Vec<_>>())
        .unwrap_or_default();

    let legitimacy_panel = SectionLegitimacy {
        quorum: quorum_row,
        majority: majority_row,
        double_majority,
        symmetry,
        pass: gates_pass,
        reasons,
    };

    // ---- Frontier (optional) ----
    let frontier_section = frontier.map(|fr| {
        // Counters are stored under predictable keys; fallback to zeros.
        let counters = FrontierCounters {
            changed: json_get_u64(fr, "/summary/changed").unwrap_or(0) as u32,
            no_change: json_get_u64(fr, "/summary/no_change").unwrap_or(0) as u32,
            mediation: json_get_u64(fr, "/summary/mediation").unwrap_or(0) as u32,
            enclave: json_get_u64(fr, "/summary/enclave").unwrap_or(0) as u32,
            protected_blocked: json_get_u64(fr, "/summary/protected_blocked").unwrap_or(0) as u32,
            quorum_blocked: json_get_u64(fr, "/summary/quorum_blocked").unwrap_or(0) as u32,
        };
        let bands_summary = fr.pointer("/bands_summary")
            .and_then(|v| v.as_array())
            .map(|a| a.iter().filter_map(|s| s.as_str().map(|x| x.to_string())).collect())
            .unwrap_or_else(|| Vec::new());

        SectionFrontier {
            mode: json_get_str(fr, "/mode").unwrap_or_else(|_| "none".into()),
            edge_policy: json_get_str(fr, "/edge_policy").unwrap_or_else(|_| "land".into()),
            island_rule: json_get_str(fr, "/island_rule").unwrap_or_else(|_| "none".into()),
            counters,
            bands_summary,
        }
    });

    // ---- Sensitivity (optional compare table) ----
    let sensitivity = compare.map(|cmp| {
        let rows = cmp.pointer("/table").and_then(|t| t.as_array())
            .map(|a| {
                a.iter().map(|row| {
                    row.as_array()
                        .map(|cells| cells.iter().map(cell_to_string).collect::<Vec<_>>())
                        .unwrap_or_default()
                }).collect::<Vec<_>>()
            }).unwrap_or_default();
        SectionSensitivity { table: rows }
    });

    // ---- Integrity (engine + IDs + policy/seed + timestamps) ----
    let engine_vendor  = json_get_str(run, "/engine/vendor").unwrap_or_else(|_| "vm-engine".into());
    let engine_name    = json_get_str(run, "/engine/name").unwrap_or_else(|_| "vm".into());
    let engine_version = json_get_str(run, "/engine/version").unwrap_or_else(|_| "0.1.0".into());
    let engine_build   = json_get_str(run, "/engine/build").unwrap_or_else(|_| "dev".into());

    let formula_id_hex = json_get_str(run, "/formula_id").unwrap_or_else(|_| {
        // Fallback to result root if present
        json_get_str(result, "/formula_id").unwrap_or_else(|_| "unknown".into())
    });

    let result_id: ResultId = json_get_str(run, "/outputs/result_id")
        .map_err(|_| ReportError::MissingField("outputs.result_id"))?
        .into();
    let run_id: RunId = json_get_str(run, "/id")
        .map_err(|_| ReportError::MissingField("run.id"))?
        .into();
    let frontier_id = run.pointer("/outputs/frontier_map_id")
        .and_then(|v| v.as_str())
        .map(|s| FrontierId::from(s.to_string()));

    let tie_policy = json_get_str(run, "/determinism/tie_policy").unwrap_or_else(|_| "deterministic".into());
    let tie_seed = if tie_policy == "random" {
        json_get_str(run, "/determinism/rng_seed").ok()
    } else { None };

    let started_utc = json_get_str(run, "/started_utc").unwrap_or_else(|_| "1970-01-01T00:00:00Z".into());
    let finished_utc = json_get_str(run, "/finished_utc").unwrap_or_else(|_| "1970-01-01T00:00:00Z".into());

    let integrity = SectionIntegrity {
        result_id,
        run_id,
        frontier_id,
        engine_vendor,
        engine_name,
        engine_version,
        engine_build,
        formula_id_hex,
        tie_policy,
        tie_seed,
        started_utc,
        finished_utc,
    };

    Ok(ReportModel {
        cover,
        snapshot,
        eligibility,
        ballot_method,
        legitimacy_panel,
        outcome_label,
        frontier: frontier_section,
        sensitivity,
        integrity,
    })
}

// ===== Renderers =====

/// Serialize the model as JSON (deterministic field order courtesy of struct layout).
#[cfg(feature = "render_json")]
pub fn render_json(model: &ReportModel) -> Result<String, ReportError> {
    serde_json::to_string(model).map_err(|_| ReportError::Template("json_serialize"))
}

/// Render a compact HTML summary using an embedded template (no external assets).
#[cfg(feature = "render_html")]
pub fn render_html(model: &ReportModel) -> Result<String, ReportError> {
    use minijinja::{Environment, context};

    static TEMPLATE: &str = r#"<!doctype html>
<html lang="en"><meta charset="utf-8">
<title>{{ cover.title }} — {{ integrity.result_id }}</title>
<h1>{{ cover.title }}</h1>
<p><strong>Label:</strong> {{ outcome.label }} — {{ outcome.reason }} (margin: {{ outcome.margin }})</p>

<h2>Legitimacy</h2>
<ul>
  <li>Quorum: {{ leg.quorum.value }} (≥ {{ leg.quorum.th }}) — {{ "PASS" if leg.quorum.pass else "FAIL" }}</li>
  <li>Majority: {{ leg.majority.value }} (≥ {{ leg.majority.th }}) — {{ "PASS" if leg.majority.pass else "FAIL" }}</li>
  {% if leg.double %}
  <li>Double-majority:
    <ul>
      <li>National: {{ leg.double.0.value }} (≥ {{ leg.double.0.th }}) — {{ "PASS" if leg.double.0.pass else "FAIL" }}</li>
      <li>Family: {{ leg.double.1.value }} (≥ {{ leg.double.1.th }}) — {{ "PASS" if leg.double.1.pass else "FAIL" }}</li>
    </ul>
  </li>
  {% endif %}
</ul>

{% if frontier %}
<h2>Frontier</h2>
<p>Mode: {{ frontier.mode }} — Edges: {{ frontier.edges }} — Island Rule: {{ frontier.island }}</p>
<p>Counters: changed={{ frontier.c.changed }}, none={{ frontier.c.none }}, mediation={{ frontier.c.mediation }},
enclave={{ frontier.c.enclave }}, protected={{ frontier.c.protected }}, quorum_blocked={{ frontier.c.qblock }}</p>
{% endif %}

<h2>Integrity</h2>
<p>Engine: {{ eng.vendor }}/{{ eng.name }} v{{ eng.version }} ({{ eng.build }}) — FID {{ integrity.formula_id_hex }}</p>
<p>Run: {{ integrity.run_id }} — Started {{ integrity.started }} — Finished {{ integrity.finished }}</p>
<p>Ties: policy={{ integrity.tie_policy }}{% if integrity.tie_seed %}, seed={{ integrity.tie_seed }}{% endif %}</p>
</html>
"#;

    let mut env = Environment::new();
    env.add_template("report.html", TEMPLATE).map_err(|_| ReportError::Template("add_template"))?;
    let tmpl = env.get_template("report.html").map_err(|_| ReportError::Template("get_template"))?;

    // Shape a tiny context (explicit to avoid surprising field leaks)
    let ctx = context! {
        cover => {
            "title" => &model.cover.title,
        },
        outcome => {
            "label" => &model.outcome_label.label,
            "reason" => &model.outcome_label.reason,
            "margin" => &model.outcome_label.national_margin_pp,
        },
        leg => {
            "quorum" => {
                "value" => &model.legitimacy_panel.quorum.value_pct_1dp,
                "th"    => &model.legitimacy_panel.quorum.threshold_pct_0dp,
                "pass"  => model.legitimacy_panel.quorum.pass,
            },
            "majority" => {
                "value" => &model.legitimacy_panel.majority.value_pct_1dp,
                "th"    => &model.legitimacy_panel.majority.threshold_pct_0dp,
                "pass"  => model.legitimacy_panel.majority.pass,
            },
            "double" => &model.legitimacy_panel.double_majority,
        },
        frontier => model.frontier.as_ref().map(|f| {
            serde_json::json!({
                "mode": f.mode,
                "edges": f.edge_policy,
                "island": f.island_rule,
                "c": {
                    "changed": f.counters.changed,
                    "none": f.counters.no_change,
                    "mediation": f.counters.mediation,
                    "enclave": f.counters.enclave,
                    "protected": f.counters.protected_blocked,
                    "qblock": f.counters.quorum_blocked
                }
            })
        }),
        eng => {
            "vendor" => &model.integrity.engine_vendor,
            "name"   => &model.integrity.engine_name,
            "version"=> &model.integrity.engine_version,
            "build"  => &model.integrity.engine_build,
        },
        integrity => {
            "result_id" => &model.integrity.result_id,
            "run_id"    => &model.integrity.run_id,
            "formula_id_hex" => &model.integrity.formula_id_hex,
            "tie_policy"=> &model.integrity.tie_policy,
            "tie_seed"  => &model.integrity.tie_seed,
            "started"   => &model.integrity.started_utc,
            "finished"  => &model.integrity.finished_utc,
        }
    };

    tmpl.render(ctx).map_err(|_| ReportError::Template("render_html"))
}

// ===== Helpers (pure; no floats) =====

fn cell_to_string(v: &serde_json::Value) -> String {
    match v {
        serde_json::Value::Null => "".into(),
        serde_json::Value::Bool(b) => b.to_string(),
        serde_json::Value::Number(n) => n.to_string(),
        serde_json::Value::String(s) => s.clone(),
        _ => v.to_string(),
    }
}

fn json_get_str<'a>(root: &'a serde_json::Value, ptr: &str) -> Result<String, ReportError> {
    root.pointer(ptr)
        .and_then(|v| v.as_str())
        .map(|s| s.to_string())
        .ok_or(ReportError::MissingField(ptr))
}
fn json_get_bool(root: &serde_json::Value, ptr: &str) -> Result<bool, ReportError> {
    root.pointer(ptr)
        .and_then(|v| v.as_bool())
        .ok_or(ReportError::MissingField(ptr))
}
fn json_get_u64(root: &serde_json::Value, ptr: &str) -> Result<u64, ReportError> {
    root.pointer(ptr)
        .and_then(|v| v.as_u64())
        .ok_or(ReportError::MissingField(ptr))
}
fn json_get_i64(root: &serde_json::Value, ptr: &str) -> Result<i64, ReportError> {
    root.pointer(ptr)
        .and_then(|v| v.as_i64())
        .ok_or(ReportError::MissingField(ptr))
}

/// Format a percentage number (already given as a JSON number 0..=100) into
/// a one-decimal percent string *without* float arithmetic. We only massage
/// the textual representation and clamp to a single decimal place.
fn json_percent_1dp_from_number(maybe_num: Option<&serde_json::Value>) -> Result<String, ReportError> {
    let n = maybe_num.ok_or(ReportError::MissingField("gates.*.observed"))?;
    let s = match n {
        serde_json::Value::Number(num) => num.to_string(),
        _ => return Err(ReportError::Inconsistent("gates.*.observed:not_number")),
    };
    Ok(format!("{}%", to_one_decimal(&s)))
}

/// Ensure a numeric string has exactly one decimal place, without changing the
/// value (we truncate extra decimals; upstream ensures engine precision).
fn to_one_decimal(s: &str) -> String {
    if let Some(dot) = s.find('.') {
        // keep one decimal digit maximum; if none exists after dot, add one zero.
        let after = &s[dot + 1..];
        if after.is_empty() {
            format!("{}{}", s, "0")
        } else {
            let end = dot + 2.min(s.len() - dot - 1);
            let mut out = String::with_capacity(dot + 2);
            out.push_str(&s[..=dot]); // include '.'
            out.push_str(&s[dot + 1..end]);
            out
        }
    } else {
        // no decimal point → add ".0"
        let mut out = String::with_capacity(s.len() + 2);
        out.push_str(s);
        out.push_str(".0");
        out
    }
}

// ===== End =====

--------------------------------------------------------------------------------
FILE: crates/vm_report/src/lib.rs
--------------------------------------------------------------------------------
//! vm_report/src/structure.rs
//! Pure report model + mappers (no I/O, no RNG).
//!
//! Inputs are artifact JSONs (Result / RunRecord / FrontierMap). This module
//! builds a renderer-friendly `ReportModel` mirroring Doc 7, with all human-
//! visible numbers preformatted (one-decimal percent; signed pp).
//!
//! Determinism: stable field order, BTree maps when needed, no floats.

#![deny(unsafe_code)]

use std::collections::BTreeMap;

use vm_core::ids::{FrontierId, ParamSetId, RegId, ResultId, RunId, TallyId};
use vm_core::rounding::percent_one_decimal_tenths;

// ----- Artifact aliases (decoupled from vm_pipeline/vm_io concrete types) -----
pub type ResultDb = serde_json::Value;
pub type RunRecordDb = serde_json::Value;
pub type FrontierMapDb = serde_json::Value;

// ===================== Model root =====================

#[derive(Clone, Debug)]
pub struct ReportModel {
    pub cover: CoverSnapshot,
    pub eligibility: EligibilityBlock,
    pub ballot: BallotBlock,
    pub panel: LegitimacyPanel,
    pub outcome: OutcomeBlock,
    pub frontier: Option<FrontierBlock>,
    pub sensitivity: Option<SensitivityBlock>,
    pub integrity: IntegrityBlock,
    pub footer: FooterIds,
}

// ---------------- Sections ----------------

#[derive(Clone, Debug)]
pub struct CoverSnapshot {
    pub label: String,               // Decisive|Marginal|Invalid
    pub reason: Option<String>,
    pub snapshot_vars: Vec<SnapshotVar>, // key/value VM-VARs for cover box
    pub registry_name: String,
    pub registry_published_date: String,
}
#[derive(Clone, Debug)]
pub struct SnapshotVar { pub key: String, pub value: String }

#[derive(Clone, Debug)]
pub struct EligibilityBlock {
    pub roll_policy: String,                // pretty VM-VAR-028
    pub totals_eligible_roll: u64,
    pub totals_ballots_cast: u64,
    pub totals_valid_ballots: u64,
    pub per_unit_quorum_note: Option<String>, // VM-VAR-021 + scope
    pub provenance: String,                 // source/edition string
}

#[derive(Clone, Debug)]
pub struct BallotBlock {
    pub ballot_type: String,                // VM-VAR-001
    pub allocation_method: String,          // VM-VAR-010
    pub weighting_method: String,           // VM-VAR-030
    pub approval_denominator_sentence: bool,
}

#[derive(Clone, Debug)]
pub struct GateRow {
    pub value_pct_1dp: String,              // e.g., "55.0%"
    pub threshold_pct_0dp: String,          // e.g., "55%"
    pub pass: bool,
    pub denom_note: Option<String>,         // “approval rate = approvals / valid ballots”
    pub members_hint: Option<Vec<String>>,  // double-majority family (ids/names) if present
}

#[derive(Clone, Debug)]
pub struct LegitimacyPanel {
    pub quorum: GateRow,
    pub majority: GateRow,
    pub double_majority: Option<(GateRow, GateRow)>, // (national, family)
    pub symmetry: Option<bool>,
    pub pass: bool,
    pub reasons: Vec<String>,
}

#[derive(Clone, Debug)]
pub struct OutcomeBlock {
    pub label: String,
    pub reason: String,
    pub national_margin_pp: String,         // signed "±pp"
}

#[derive(Clone, Debug)]
pub struct FrontierCounters {
    pub changed: u32, pub no_change: u32, pub mediation: u32,
    pub enclave: u32, pub protected_blocked: u32, pub quorum_blocked: u32,
}

#[derive(Clone, Debug)]
pub struct FrontierBlock {
    pub mode: String,                       // VM-VAR-040
    pub edge_types: String,                 // VM-VAR-047 summary
    pub island_rule: String,                // VM-VAR-048
    pub bands_summary: Vec<String>,         // ladder/sliding descriptors
    pub counters: FrontierCounters,
}

#[derive(Clone, Debug)]
pub struct SensitivityBlock { pub table_2x3: Vec<Vec<String>> }

#[derive(Clone, Debug)]
pub struct IntegrityBlock {
    pub engine_vendor: String, pub engine_name: String,
    pub engine_version: String, pub engine_build: String,
    pub formula_id_hex: String,
    pub tie_policy: String, pub tie_seed: Option<String>,
    pub started_utc: String, pub finished_utc: String,
}

#[derive(Clone, Debug)]
pub struct FooterIds {
    pub result_id: ResultId,
    pub run_id: RunId,
    pub frontier_id: Option<FrontierId>,
    pub reg_id: RegId,
    pub param_set_id: ParamSetId,
    pub tally_id: Option<TallyId>,
}

// ===================== Top-level mapping API =====================

/// Build the full model from artifacts (pure, deterministic; no I/O).
pub fn model_from_artifacts(
    result: &ResultDb,
    run: &RunRecordDb,
    frontier: Option<&FrontierMapDb>
) -> ReportModel {
    let cover = map_cover_snapshot(result);
    let eligibility = map_eligibility(result);
    let ballot = map_ballot(result);
    let panel = map_panel_from_gates(result);
    let outcome = map_outcome_from_result(result);
    let frontier_block = frontier.map(|fr| map_frontier(fr, result));
    let sensitivity = map_sensitivity(result);
    let (integrity, footer) = map_integrity_footer(run, result, frontier);

    ReportModel {
        cover,
        eligibility,
        ballot,
        panel,
        outcome,
        frontier: frontier_block,
        sensitivity,
        integrity,
        footer,
    }
}

// ===================== Mapping helpers =====================

pub fn map_cover_snapshot(result: &ResultDb) -> CoverSnapshot {
    let label = j_str(result, "/label").unwrap_or_else(|| "Invalid".into());
    let reason = j_str(result, "/label_reason");
    let mut snapshot_vars = Vec::<SnapshotVar>::new();

    if let Some(bt) = j_str(result, "/params/ballot_type") {
        snapshot_vars.push(SnapshotVar{ key: "ballot_type".into(), value: bt });
    }
    if let Some(am) = j_str(result, "/params/allocation_method") {
        snapshot_vars.push(SnapshotVar{ key: "allocation_method".into(), value: am });
    }
    if let Some(wm) = j_str(result, "/aggregates/weighting_method") {
        snapshot_vars.push(SnapshotVar{ key: "weighting_method".into(), value: wm });
    }
    if let Some(th) = j_u64(result, "/params/pr_entry_threshold_pct") {
        snapshot_vars.push(SnapshotVar{ key: "pr_entry_threshold_pct".into(), value: format!("{}%", th) });
    }
    if let Some(dm) = j_bool(result, "/params/double_majority_enabled") {
        snapshot_vars.push(SnapshotVar{ key: "double_majority_enabled".into(), value: dm.to_string() });
    }
    if let Some(sym) = j_bool(result, "/params/symmetry_enabled") {
        snapshot_vars.push(SnapshotVar{ key: "symmetry_enabled".into(), value: sym.to_string() });
    }
    if let Some(fm) = j_str(result, "/params/frontier_mode") {
        snapshot_vars.push(SnapshotVar{ key: "frontier_mode".into(), value: fm });
    }

    let registry_name = j_str(result, "/provenance/registry_name").unwrap_or_else(|| "registry".into());
    let registry_published_date = j_str(result, "/provenance/registry_published_date").unwrap_or_else(|| "".into());

    CoverSnapshot { label, reason, snapshot_vars, registry_name, registry_published_date }
}

pub fn map_eligibility(result: &ResultDb) -> EligibilityBlock {
    let roll_policy = j_str(result, "/params/roll_inclusion_policy").unwrap_or_else(|| "unspecified".into());
    let totals_eligible_roll = j_u64(result, "/aggregates/turnout/eligible_roll").unwrap_or(0);
    let totals_ballots_cast  = j_u64(result, "/aggregates/turnout/ballots_cast").unwrap_or(0);
    let totals_valid_ballots = j_u64(result, "/aggregates/turnout/valid_ballots").unwrap_or(0);

    let per_unit_quorum_note = j_u64(result, "/params/quorum_per_unit_pct")
        .and_then(|q| if q > 0 {
            let scope = j_str(result, "/params/quorum_per_unit_scope").unwrap_or_else(|| "units".into());
            Some(format!("Per-unit quorum applied at {}% (scope: {})", q, scope))
        } else { None });

    let provenance = j_str(result, "/provenance/registry_source")
        .or_else(|| j_str(result, "/provenance/registry_name"))
        .unwrap_or_else(|| "registry".into());

    EligibilityBlock {
        roll_policy,
        totals_eligible_roll,
        totals_ballots_cast,
        totals_valid_ballots,
        per_unit_quorum_note,
        provenance,
    }
}

pub fn map_ballot(result: &ResultDb) -> BallotBlock {
    let ballot_type = j_str(result, "/params/ballot_type").unwrap_or_else(|| "unspecified".into());
    let allocation_method = j_str(result, "/params/allocation_method").unwrap_or_else(|| "unspecified".into());
    let weighting_method  = j_str(result, "/aggregates/weighting_method").unwrap_or_else(|| "unspecified".into());
    let approval_denominator_sentence = ballot_type == "approval";

    BallotBlock { ballot_type, allocation_method, weighting_method, approval_denominator_sentence }
}

pub fn map_panel_from_gates(result: &ResultDb) -> LegitimacyPanel {
    let gates = result.pointer("/gates").cloned().unwrap_or_default();

    let quorum = GateRow {
        value_pct_1dp: percent_number_to_1dp_str(gates.pointer("/quorum/observed")),
        threshold_pct_0dp: j_u64(&gates, "/quorum/threshold_pct").map(|v| format!("{}%", v)).unwrap_or_else(|| "0%".into()),
        pass: j_bool(&gates, "/quorum/pass").unwrap_or(false),
        denom_note: None,
        members_hint: None,
    };

    let majority = GateRow {
        value_pct_1dp: percent_number_to_1dp_str(gates.pointer("/majority/observed")),
        threshold_pct_0dp: j_u64(&gates, "/majority/threshold_pct").map(|v| format!("{}%", v)).unwrap_or_else(|| "0%".into()),
        pass: j_bool(&gates, "/majority/pass").unwrap_or(false),
        denom_note: Some("approval rate = approvals / valid ballots".into()),
        members_hint: None,
    };

    let double_majority = gates.pointer("/double_majority").and_then(|dm| {
        let nat = GateRow {
            value_pct_1dp: percent_number_to_1dp_str(dm.pointer("/national/observed")),
            threshold_pct_0dp: j_u64(dm, "/national/threshold_pct").map(|v| format!("{}%", v)).unwrap_or_else(|| "0%".into()),
            pass: j_bool(dm, "/national/pass").unwrap_or(false),
            denom_note: Some("approval rate = approvals / valid ballots".into()),
            members_hint: None,
        };
        let fam = GateRow {
            value_pct_1dp: percent_number_to_1dp_str(dm.pointer("/regional/observed")),
            threshold_pct_0dp: j_u64(dm, "/regional/threshold_pct").map(|v| format!("{}%", v)).unwrap_or_else(|| "0%".into()),
            pass: j_bool(dm, "/regional/pass").unwrap_or(false),
            denom_note: Some("approval rate = approvals / valid ballots".into()),
            members_hint: dm.pointer("/members")
                .and_then(|lst| lst.as_array())
                .map(|arr| arr.iter().filter_map(|v| v.as_str().map(|s| s.to_string())).collect()),
        };
        Some((nat, fam))
    });

    let symmetry = gates.pointer("/symmetry").and_then(|s| s.get("pass")).and_then(|v| v.as_bool());
    let pass = j_bool(&gates, "/pass").unwrap_or(false);
    let reasons = gates.pointer("/reasons")
        .and_then(|v| v.as_array())
        .map(|a| a.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect::<Vec<_>>())
        .unwrap_or_default();

    LegitimacyPanel { quorum, majority, double_majority, symmetry, pass, reasons }
}

pub fn map_outcome_from_result(result: &ResultDb) -> OutcomeBlock {
    let label  = j_str(result, "/label").unwrap_or_else(|| "Invalid".into());
    let reason = j_str(result, "/label_reason").unwrap_or_else(|| "gates_failed".into());
    let nmargin = j_i64(result, "/aggregates/national_margin_pp").unwrap_or(0) as i32;

    OutcomeBlock {
        label,
        reason,
        national_margin_pp: pp_signed(nmargin),
    }
}

pub fn map_frontier(fr: &FrontierMapDb, result: &ResultDb) -> FrontierBlock {
    // Mode/edges/island can be read from params echoed in Result; fallback to FR if present.
    let mode        = j_str(result, "/params/frontier_mode")
        .or_else(|| j_str(fr, "/mode")).unwrap_or_else(|| "none".into());
    let edge_types  = j_str(result, "/params/contiguity_edge_types")
        .or_else(|| j_str(fr, "/edge_policy")).unwrap_or_else(|| "land".into());
    let island_rule = j_str(result, "/params/island_exception_rule")
        .or_else(|| j_str(fr, "/island_rule")).unwrap_or_else(|| "none".into());

    let bands_summary = fr.pointer("/bands_summary")
        .and_then(|v| v.as_array())
        .map(|a| a.iter().filter_map(|s| s.as_str().map(|x| x.to_string())).collect::<Vec<_>>())
        .unwrap_or_default();

    let counters = FrontierCounters {
        changed: j_u64(fr, "/summary/changed").unwrap_or(0) as u32,
        no_change: j_u64(fr, "/summary/no_change").unwrap_or(0) as u32,
        mediation: j_u64(fr, "/summary/mediation").unwrap_or(0) as u32,
        enclave: j_u64(fr, "/summary/enclave").unwrap_or(0) as u32,
        protected_blocked: j_u64(fr, "/summary/protected_blocked").unwrap_or(0) as u32,
        quorum_blocked: j_u64(fr, "/summary/quorum_blocked").unwrap_or(0) as u32,
    };

    FrontierBlock { mode, edge_types, island_rule, bands_summary, counters }
}

pub fn map_sensitivity(_result: &ResultDb) -> Option<SensitivityBlock> {
    // v1: no scenario compare; return None for a lean model.
    None
}

pub fn map_integrity_footer(
    run: &RunRecordDb,
    result: &ResultDb,
    frontier: Option<&FrontierMapDb>
) -> (IntegrityBlock, FooterIds) {
    let engine_vendor  = j_str(run, "/engine/vendor").unwrap_or_else(|| "vm-engine".into());
    let engine_name    = j_str(run, "/engine/name").unwrap_or_else(|| "vm".into());
    let engine_version = j_str(run, "/engine/version").unwrap_or_else(|| "0.1.0".into());
    let engine_build   = j_str(run, "/engine/build").unwrap_or_else(|| "dev".into());
    let formula_id_hex = j_str(run, "/formula_id")
        .or_else(|| j_str(result, "/formula_id"))
        .unwrap_or_else(|| "unknown".into());
    let tie_policy     = j_str(run, "/determinism/tie_policy").unwrap_or_else(|| "deterministic".into());
    let tie_seed       = if tie_policy == "random" { j_str(run, "/determinism/rng_seed") } else { None };
    let started_utc    = j_str(run, "/started_utc").unwrap_or_else(|| "1970-01-01T00:00:00Z".into());
    let finished_utc   = j_str(run, "/finished_utc").unwrap_or_else(|| "1970-01-01T00:00:00Z".into());

    let integrity = IntegrityBlock {
        engine_vendor, engine_name, engine_version, engine_build,
        formula_id_hex, tie_policy, tie_seed, started_utc, finished_utc,
    };

    let result_id   : ResultId   = j_str(run, "/outputs/result_id").unwrap_or_else(|| "RES:unknown".into()).into();
    let run_id      : RunId      = j_str(run, "/id").unwrap_or_else(|| "RUN:unknown".into()).into();
    let frontier_id : Option<FrontierId> = frontier
        .and_then(|_| j_str(run, "/outputs/frontier_map_id"))
        .map(Into::into);

    let reg_id      : RegId      = j_str(run, "/inputs/reg_id").unwrap_or_else(|| "REG:unknown".into()).into();
    let param_set_id: ParamSetId = j_str(run, "/inputs/parameter_set_id").unwrap_or_else(|| "PS:unknown".into()).into();
    let tally_id    : Option<TallyId> = j_str(run, "/inputs/ballot_tally_id").map(Into::into);

    let footer = FooterIds {
        result_id, run_id, frontier_id, reg_id, param_set_id, tally_id
    };

    (integrity, footer)
}

// ===================== Formatting helpers (integer math; no floats) =====================

/// Format % to one decimal using integer tenths from `percent_one_decimal_tenths`.
pub fn pct_1dp(num: i128, den: i128) -> String {
    if den <= 0 { return "0.0%".into(); }
    let tenths = percent_one_decimal_tenths(num, den);
    let whole = tenths / 10;
    let frac  = (tenths % 10).abs();
    format!("{}.{}%", whole, frac)
}
/// "55%"
pub fn pct0(value_u8: u8) -> String { format!("{}%", value_u8) }

/// "+3 pp" / "-2 pp"
pub fn pp_signed(pp_i32: i32) -> String {
    if pp_i32 >= 0 { format!("+{} pp", pp_i32) } else { format!("{} pp", pp_i32) }
}

// ===================== Small JSON helpers (pure) =====================

fn j_str(root: &serde_json::Value, ptr: &str) -> Option<String> {
    root.pointer(ptr).and_then(|v| v.as_str().map(|s| s.to_string()))
}
fn j_u64(root: &serde_json::Value, ptr: &str) -> Option<u64> {
    root.pointer(ptr).and_then(|v| v.as_u64())
}
fn j_i64(root: &serde_json::Value, ptr: &str) -> Option<i64> {
    root.pointer(ptr).and_then(|v| v.as_i64())
}
fn j_bool(root: &serde_json::Value, ptr: &str) -> Option<bool> {
    root.pointer(ptr).and_then(|v| v.as_bool())
}

/// Convert a JSON number 0..=100 (stringified) to one-decimal percent **without**
/// float arithmetic. If not present, returns "0.0%".
fn percent_number_to_1dp_str(maybe: Option<&serde_json::Value>) -> String {
    let s = match maybe {
        Some(serde_json::Value::Number(n)) => n.to_string(),
        _ => return "0.0%".into(),
    };
    // Ensure exactly one decimal place (truncate if more; add ".0" if none).
    if let Some(dot) = s.find('.') {
        let after = &s[dot + 1..];
        if after.is_empty() {
            format!("{}0%", s)
        } else {
            let end = dot + 2.min(s.len() - dot - 1);
            let mut out = String::with_capacity(dot + 2 + 1);
            out.push_str(&s[..=dot]); // include '.'
            out.push_str(&s[dot + 1..end]);
            out.push('%');
            out
        }
    } else {
        format!("{}.0%", s)
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_report/src/structure.rs
--------------------------------------------------------------------------------
//! crates/vm_report/src/structure.rs
//! Pure report data model + mappers from pipeline artifacts, per Doc 7.
//! No I/O, no recomputation, no floats. Deterministic ordering only.

// -------------------- Public model root & sections (Doc 7 order) --------------------

#[derive(Clone, Debug)]
pub struct ReportModel {
    pub cover: CoverSnapshot,
    pub eligibility: EligibilityBlock,
    pub ballot: BallotBlock,
    pub panel: LegitimacyPanel,
    pub outcome: OutcomeBlock,
    pub frontier: Option<FrontierBlock>,
    pub sensitivity: Option<SensitivityBlock>,
    pub integrity: IntegrityBlock,
    pub footer: FooterIds,
}

#[derive(Clone, Debug)]
pub struct CoverSnapshot {
    pub label: String,                       // Decisive|Marginal|Invalid
    pub reason: Option<String>,
    pub snapshot_vars: Vec<SnapshotVar>,     // VM-VAR key/value pairs
    pub registry_name: String,
    pub registry_published_date: String,
}
#[derive(Clone, Debug)]
pub struct SnapshotVar { pub key: String, pub value: String }

#[derive(Clone, Debug)]
pub struct EligibilityBlock {
    pub roll_policy: String,                 // VM-VAR-028, pretty
    pub totals_eligible_roll: u64,
    pub totals_ballots_cast: u64,
    pub totals_valid_ballots: u64,
    pub per_unit_quorum_note: Option<String>,// VM-VAR-021 (+scope)
    pub provenance: String,                  // source/edition text
}

#[derive(Clone, Debug)]
pub struct BallotBlock {
    pub ballot_type: String,                 // VM-VAR-001
    pub allocation_method: String,           // VM-VAR-010
    pub weighting_method: String,            // VM-VAR-030
    pub approval_denominator_sentence: bool, // “approval rate = approvals / valid ballots”
}

#[derive(Clone, Debug)]
pub struct GateRow {
    pub value_pct_1dp: String,               // e.g., "55.0%"
    pub threshold_pct_0dp: String,           // e.g., "55%"
    pub pass: bool,
    pub denom_note: Option<String>,          // for approval majority note
    pub members_hint: Option<Vec<String>>,   // for double-majority family
}

#[derive(Clone, Debug)]
pub struct LegitimacyPanel {
    pub quorum: GateRow,
    pub majority: GateRow,
    pub double_majority: Option<(GateRow, GateRow)>, // (national, family)
    pub symmetry: Option<bool>,
    pub pass: bool,
    pub reasons: Vec<String>,
}

#[derive(Clone, Debug)]
pub struct OutcomeBlock {
    pub label: String,
    pub reason: String,
    pub national_margin_pp: String,          // signed “±pp”
}

#[derive(Clone, Debug)]
pub struct FrontierCounters {
    pub changed: u32, pub no_change: u32, pub mediation: u32,
    pub enclave: u32, pub protected_blocked: u32, pub quorum_blocked: u32,
}

#[derive(Clone, Debug)]
pub struct FrontierBlock {
    pub mode: String,                        // VM-VAR-040
    pub edge_types: String,                  // VM-VAR-047 summary
    pub island_rule: String,                 // VM-VAR-048
    pub bands_summary: Vec<String>,          // ladder/sliding descriptors (declared order)
    pub counters: FrontierCounters,
}

#[derive(Clone, Debug)]
pub struct SensitivityBlock { pub table_2x3: Vec<Vec<String>> }

#[derive(Clone, Debug)]
pub struct IntegrityBlock {
    pub engine_vendor: String, pub engine_name: String,
    pub engine_version: String, pub engine_build: String,
    pub formula_id_hex: String,
    pub tie_policy: String, pub tie_seed: Option<String>,
    pub started_utc: String, pub finished_utc: String,
}

// Footer IDs: keep strong types where available, otherwise String.
use vm_core::ids::{ResultId, RunId, FrontierMapId as FrontierId};
#[derive(Clone, Debug)]
pub struct FooterIds {
    pub result_id: ResultId,
    pub run_id: RunId,
    pub frontier_id: Option<FrontierId>,
    pub reg_id: String,
    pub param_set_id: String,
    pub tally_id: Option<String>,
}

// -------------------- Artifact “view” traits (no schema guesses here) --------------------
// The pipeline may wrap concrete DB structs to implement these views. This file depends only
// on what we need to *display*, not on storage layout. All methods are pure getters.

use core::fmt::Display;
use alloc::vec::Vec;
use alloc::string::String;
use alloc::collections::BTreeMap;

extern crate alloc;

/// Minimal view of Result artifact (RES).
pub trait ResultView {
    // Cover / label
    fn label(&self) -> &str;                 // "Decisive" | "Marginal" | "Invalid"
    fn label_reason(&self) -> Option<&str>;
    fn registry_name(&self) -> &str;
    fn registry_published_date(&self) -> &str;

    // Snapshot VM-VARs (already stringified by pipeline snapshot)
    fn snapshot_vars(&self) -> &[(String, String)]; // preserved order

    // Totals
    fn totals_eligible_roll(&self) -> u64;
    fn totals_ballots_cast(&self) -> u64;
    fn totals_valid_ballots(&self) -> u64;

    // Eligibility / provenance
    fn roll_policy_pretty(&self) -> &str;    // VM-VAR-028
    fn per_unit_quorum_note(&self) -> Option<String>; // VM-VAR-021 (+scope)
    fn provenance(&self) -> &str;            // source/edition

    // Ballot / methods
    fn ballot_type(&self) -> &str;           // VM-VAR-001
    fn allocation_method(&self) -> &str;     // VM-VAR-010
    fn weighting_method(&self) -> &str;      // VM-VAR-030

    // Gates (precomputed ratios & thresholds; no recomputation here)
    fn gate_quorum_ratio(&self) -> (i128, i128);     // (num, den)
    fn gate_quorum_threshold_pct(&self) -> u8;
    fn gate_quorum_pass(&self) -> bool;

    fn gate_majority_ratio(&self) -> (i128, i128);   // approval / valid_ballots
    fn gate_majority_threshold_pct(&self) -> u8;
    fn gate_majority_pass(&self) -> bool;

    fn gate_double_majority_enabled(&self) -> bool;
    fn gate_double_majority_national_ratio(&self) -> (i128, i128);
    fn gate_double_majority_family_ratio(&self) -> (i128, i128);
    fn gate_double_majority_threshold_pct(&self) -> u8; // assume same cutoff both sides
    fn gate_double_majority_family_members(&self) -> Option<Vec<String>>;
    fn gate_double_majority_pass_both(&self) -> Option<(bool, bool)>;

    fn symmetry_enabled(&self) -> bool;
    fn symmetry_pass(&self) -> Option<bool>;

    // Outcome
    fn national_margin_pp(&self) -> i32;

    // IDs
    fn result_id(&self) -> &ResultId;
    fn frontier_id(&self) -> Option<FrontierId>;
    fn reg_id_str(&self) -> &str;
    fn param_set_id_str(&self) -> &str;
    fn tally_id_str(&self) -> Option<&str>;
}

/// Minimal view of RunRecord artifact (RUN).
pub trait RunRecordView {
    fn engine_vendor(&self) -> &str;
    fn engine_name(&self) -> &str;
    fn engine_version(&self) -> &str;
    fn engine_build(&self) -> &str;

    fn formula_id_hex(&self) -> &str;

    fn tie_policy(&self) -> &str;            // "deterministic" | "random" | ...
    fn tie_seed_opt(&self) -> Option<u64>;   // only meaningful if policy == random

    fn started_utc(&self) -> &str;           // "YYYY-MM-DDTHH:MM:SSZ"
    fn finished_utc(&self) -> &str;

    fn run_id(&self) -> &RunId;
}

/// Minimal view of FrontierMap artifact (FR).
pub trait FrontierMapView {
    fn mode_pretty(&self) -> &str;           // VM-VAR-040
    fn edge_types_summary(&self) -> &str;    // VM-VAR-047
    fn island_rule_pretty(&self) -> &str;    // VM-VAR-048
    fn bands_summary(&self) -> &[String];    // declared order, already pretty

    fn counters(&self) -> FrontierCounters;  // changed / no_change / mediation / enclave / protected_blocked / quorum_blocked
}

// Public aliases to match function signatures in the spec (trait objects).
pub type ResultDb     = dyn ResultView;
pub type RunRecordDb  = dyn RunRecordView;
pub type FrontierMapDb= dyn FrontierMapView;

// -------------------- Top-level mapping API (pure) --------------------

pub fn model_from_artifacts(
    result: &ResultDb,
    run: &RunRecordDb,
    frontier: Option<&FrontierMapDb>,
) -> ReportModel {
    let cover = map_cover_snapshot(result);
    let eligibility = map_eligibility(result);
    let ballot = map_ballot(result);
    let panel = map_panel_from_gates(result);
    let outcome = map_outcome_from_result(result);
    let frontier_block = frontier.map(|fr| map_frontier(fr, result));
    let sensitivity = map_sensitivity(result);
    let (integrity, footer) = map_integrity_footer(run, result, frontier);

    ReportModel {
        cover,
        eligibility,
        ballot,
        panel,
        outcome,
        frontier: frontier_block,
        sensitivity,
        integrity,
        footer,
    }
}

// -------------------- Mapping helpers (pure) --------------------

fn map_cover_snapshot(result: &ResultDb) -> CoverSnapshot {
    CoverSnapshot {
        label: result.label().to_string(),
        reason: result.label_reason().map(|s| s.to_string()),
        snapshot_vars: result.snapshot_vars().iter().cloned().collect(),
        registry_name: result.registry_name().to_string(),
        registry_published_date: result.registry_published_date().to_string(),
    }
}

fn map_eligibility(result: &ResultDb) -> EligibilityBlock {
    EligibilityBlock {
        roll_policy: result.roll_policy_pretty().to_string(),
        totals_eligible_roll: result.totals_eligible_roll(),
        totals_ballots_cast: result.totals_ballots_cast(),
        totals_valid_ballots: result.totals_valid_ballots(),
        per_unit_quorum_note: result.per_unit_quorum_note(),
        provenance: result.provenance().to_string(),
    }
}

fn map_ballot(result: &ResultDb) -> BallotBlock {
    let ballot_type = result.ballot_type().to_string();
    let approval_sentence = ballot_type.to_ascii_lowercase() == "approval";
    BallotBlock {
        ballot_type,
        allocation_method: result.allocation_method().to_string(),
        weighting_method: result.weighting_method().to_string(),
        approval_denominator_sentence: approval_sentence,
    }
}

fn map_panel_from_gates(result: &ResultDb) -> LegitimacyPanel {
    // Quorum
    let (q_num, q_den) = result.gate_quorum_ratio();
    let quorum = GateRow {
        value_pct_1dp: pct_1dp(q_num, q_den),
        threshold_pct_0dp: pct0(result.gate_quorum_threshold_pct()),
        pass: result.gate_quorum_pass(),
        denom_note: None,
        members_hint: None,
    };

    // National approval majority (approval / valid ballots)
    let (m_num, m_den) = result.gate_majority_ratio();
    let majority = GateRow {
        value_pct_1dp: pct_1dp(m_num, m_den),
        threshold_pct_0dp: pct0(result.gate_majority_threshold_pct()),
        pass: result.gate_majority_pass(),
        denom_note: Some("approval rate = approvals / valid ballots".to_string()),
        members_hint: None,
    };

    // Double-majority (if enabled)
    let dm = if result.gate_double_majority_enabled() {
        let (n_num, n_den) = result.gate_double_majority_national_ratio();
        let (f_num, f_den) = result.gate_double_majority_family_ratio();
        let th = pct0(result.gate_double_majority_threshold_pct());
        let (pass_nat, pass_fam) = result.gate_double_majority_pass_both().unwrap_or((false, false));
        let hint = result.gate_double_majority_family_members();

        let nat = GateRow {
            value_pct_1dp: pct_1dp(n_num, n_den),
            threshold_pct_0dp: th.clone(),
            pass: pass_nat,
            denom_note: Some("approval rate = approvals / valid ballots".to_string()),
            members_hint: None,
        };
        let fam = GateRow {
            value_pct_1dp: pct_1dp(f_num, f_den),
            threshold_pct_0dp: th,
            pass: pass_fam,
            denom_note: Some("approval rate = approvals / valid ballots".to_string()),
            members_hint: hint,
        };
        Some((nat, fam))
    } else {
        None
    };

    let symmetry = if result.symmetry_enabled() { result.symmetry_pass() } else { None };

    // Overall pass/reasons mirror result label & gate passes (no recompute).
    let pass = quorum.pass && majority.pass && dm.as_ref().map_or(true, |(n, f)| n.pass && f.pass)
        && symmetry.unwrap_or(true);

    let mut reasons: Vec<String> = Vec::new();
    if !quorum.pass { reasons.push("Quorum failed".into()); }
    if !majority.pass { reasons.push("National majority failed".into()); }
    if let Some((n, f)) = &dm {
        if !n.pass || !f.pass { reasons.push("Double-majority failed".into()); }
    }
    if let Some(false) = symmetry { reasons.push("Symmetry failed".into()); }

    LegitimacyPanel { quorum, majority, double_majority: dm, symmetry, pass, reasons }
}

fn map_outcome_from_result(result: &ResultDb) -> OutcomeBlock {
    OutcomeBlock {
        label: result.label().to_string(),
        reason: result.label_reason().unwrap_or_default().to_string(),
        national_margin_pp: pp_signed(result.national_margin_pp()),
    }
}

fn map_frontier(fr: &FrontierMapDb, _result: &ResultDb) -> FrontierBlock {
    FrontierBlock {
        mode: fr.mode_pretty().to_string(),
        edge_types: fr.edge_types_summary().to_string(),
        island_rule: fr.island_rule_pretty().to_string(),
        bands_summary: fr.bands_summary().to_vec(),
        counters: fr.counters(),
    }
}

fn map_sensitivity(_result: &ResultDb) -> Option<SensitivityBlock> {
    // v1: no scenarios packaged ⇒ None
    None
}

fn map_integrity_footer(
    run: &RunRecordDb,
    result: &ResultDb,
    frontier: Option<&FrontierMapDb>,
) -> (IntegrityBlock, FooterIds) {
    // Integrity
    let (policy, seed_opt) = (run.tie_policy().to_string(), run.tie_seed_opt());
    let tie_seed = match (policy.as_str(), seed_opt) {
        ("random", Some(s)) => Some(s.to_string()),
        _ => None,
    };
    let integrity = IntegrityBlock {
        engine_vendor: run.engine_vendor().to_string(),
        engine_name: run.engine_name().to_string(),
        engine_version: run.engine_version().to_string(),
        engine_build: run.engine_build().to_string(),
        formula_id_hex: run.formula_id_hex().to_string(),
        tie_policy: policy,
        tie_seed,
        started_utc: run.started_utc().to_string(),
        finished_utc: run.finished_utc().to_string(),
    };

    // Footer IDs
    let footer = FooterIds {
        result_id: result.result_id().clone(),
        run_id: run.run_id().clone(),
        frontier_id: frontier.map(|_| result.frontier_id()).flatten(),
        reg_id: result.reg_id_str().to_string(),
        param_set_id: result.param_set_id_str().to_string(),
        tally_id: result.tally_id_str().map(|s| s.to_string()),
    };

    (integrity, footer)
}

// -------------------- Formatting helpers (integer math only) --------------------

fn pct_1dp(num: i128, den: i128) -> String {
    use vm_core::rounding::percent_one_decimal_tenths;
    if den <= 0 { return "0.0%".into(); }
    let tenths = percent_one_decimal_tenths(num, den); // e.g., 553 → 55.3%
    let sign = if tenths < 0 { "-" } else { "" };
    let abs = tenths.abs();
    let whole = abs / 10;
    let dec = (abs % 10) as i128;
    format!("{sign}{whole}.{dec}%")
}

fn pct0(value_u8: u8) -> String {
    format!("{value_u8}%")
}

fn pp_signed(pp_i32: i32) -> String {
    match pp_i32.cmp(&0) {
        core::cmp::Ordering::Greater => format!("+{pp_i32} pp"),
        core::cmp::Ordering::Equal => "±0 pp".to_string(),
        core::cmp::Ordering::Less => format!("{pp_i32} pp"),
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_report/src/render_json.rs
--------------------------------------------------------------------------------
//! crates/vm_report/src/render_json.rs
//! Deterministic JSON renderer for ReportModel (Doc 7 fixed order). No I/O, no math, no hashing.

use serde_json::{Map, Value};

use crate::structure::{
    FrontierBlock, FrontierCounters, GateRow, ReportModel, SensitivityBlock,
};

/// Public API: return a compact UTF-8 JSON string (no trailing newline).
pub fn render_json(model: &ReportModel) -> String {
    let v = to_ordered_json(model);
    // serde_json::to_string is deterministic for a given Value and Map insertion order.
    serde_json::to_string(&v).expect("render_json: serialization must not fail")
}

/// Internal: build a Value tree with **stable insertion order** for all objects.
fn to_ordered_json(m: &ReportModel) -> Value {
    let mut root = Map::new();

    // Insert sections strictly in Doc 7 order.
    root.insert("cover".into(), cover_json(m));
    root.insert("eligibility".into(), eligibility_json(m));
    root.insert("ballot".into(), ballot_json(m));
    root.insert("legitimacy_panel".into(), panel_json(m));
    root.insert("outcome".into(), outcome_json(m));

    if let Some(fr) = frontier_json(m) {
        root.insert("frontier".into(), fr);
    }

    if let Some(sens) = sensitivity_json(m) {
        root.insert("sensitivity".into(), sens);
    }

    root.insert("integrity".into(), integrity_json(m));
    root.insert("footer".into(), footer_json(m));

    Value::Object(root)
}

// ---------------- Section builders (fixed key ordering in each object) ----------------

fn cover_json(m: &ReportModel) -> Value {
    let mut obj = Map::new();
    obj.insert("label".into(), Value::String(m.cover.label.clone()));
    if let Some(r) = &m.cover.reason {
        obj.insert("reason".into(), Value::String(r.clone()));
    }

    // snapshot_vars: preserve model order
    let vars = m
        .cover
        .snapshot_vars
        .iter()
        .map(|kv| {
            let mut kvobj = Map::new();
            kvobj.insert("key".into(), Value::String(kv.key.clone()));
            kvobj.insert("value".into(), Value::String(kv.value.clone()));
            Value::Object(kvobj)
        })
        .collect::<Vec<_>>();
    obj.insert("snapshot_vars".into(), Value::Array(vars));

    obj.insert(
        "registry_name".into(),
        Value::String(m.cover.registry_name.clone()),
    );
    obj.insert(
        "registry_published_date".into(),
        Value::String(m.cover.registry_published_date.clone()),
    );
    Value::Object(obj)
}

fn eligibility_json(m: &ReportModel) -> Value {
    let mut obj = Map::new();
    obj.insert(
        "roll_policy".into(),
        Value::String(m.eligibility.roll_policy.clone()),
    );
    obj.insert(
        "totals_eligible_roll".into(),
        Value::from(m.eligibility.totals_eligible_roll),
    );
    obj.insert(
        "totals_ballots_cast".into(),
        Value::from(m.eligibility.totals_ballots_cast),
    );
    obj.insert(
        "totals_valid_ballots".into(),
        Value::from(m.eligibility.totals_valid_ballots),
    );
    if let Some(note) = &m.eligibility.per_unit_quorum_note {
        obj.insert("per_unit_quorum_note".into(), Value::String(note.clone()));
    }
    obj.insert(
        "provenance".into(),
        Value::String(m.eligibility.provenance.clone()),
    );
    Value::Object(obj)
}

fn ballot_json(m: &ReportModel) -> Value {
    let mut obj = Map::new();
    obj.insert(
        "ballot_type".into(),
        Value::String(m.ballot.ballot_type.clone()),
    );
    obj.insert(
        "allocation_method".into(),
        Value::String(m.ballot.allocation_method.clone()),
    );
    obj.insert(
        "weighting_method".into(),
        Value::String(m.ballot.weighting_method.clone()),
    );
    // Emit the fixed approval denominator sentence flag only when true.
    if m.ballot.approval_denominator_sentence {
        obj.insert(
            "approval_denominator_sentence".into(),
            Value::Bool(true),
        );
    }
    Value::Object(obj)
}

fn panel_json(m: &ReportModel) -> Value {
    let mut obj = Map::new();
    obj.insert("quorum".into(), gate_row(&m.panel.quorum));
    obj.insert("majority".into(), gate_row(&m.panel.majority));

    if let Some((nat, fam)) = &m.panel.double_majority {
        let mut dm = Map::new();
        dm.insert("national".into(), gate_row(nat));
        dm.insert("family".into(), gate_row(fam));
        obj.insert("double_majority".into(), Value::Object(dm));
    }

    if let Some(sym) = m.panel.symmetry {
        obj.insert("symmetry".into(), Value::Bool(sym));
    }

    obj.insert("pass".into(), Value::Bool(m.panel.pass));

    // Reasons are already ordered by the builder; emit as-is.
    let reasons = m
        .panel
        .reasons
        .iter()
        .cloned()
        .map(Value::String)
        .collect::<Vec<_>>();
    obj.insert("reasons".into(), Value::Array(reasons));

    Value::Object(obj)
}

fn gate_row(g: &GateRow) -> Value {
    let mut obj = Map::new();
    obj.insert(
        "value_pct_1dp".into(),
        Value::String(g.value_pct_1dp.clone()),
    );
    obj.insert(
        "threshold_pct_0dp".into(),
        Value::String(g.threshold_pct_0dp.clone()),
    );
    obj.insert("pass".into(), Value::Bool(g.pass));
    if let Some(dn) = &g.denom_note {
        obj.insert("denom_note".into(), Value::String(dn.clone()));
    }
    if let Some(hint) = &g.members_hint {
        let arr = hint.iter().cloned().map(Value::String).collect::<Vec<_>>();
        obj.insert("members_hint".into(), Value::Array(arr));
    }
    Value::Object(obj)
}

fn outcome_json(m: &ReportModel) -> Value {
    let mut obj = Map::new();
    obj.insert("label".into(), Value::String(m.outcome.label.clone()));
    obj.insert("reason".into(), Value::String(m.outcome.reason.clone()));
    obj.insert(
        "national_margin_pp".into(),
        Value::String(m.outcome.national_margin_pp.clone()),
    );
    Value::Object(obj)
}

fn frontier_json(m: &ReportModel) -> Option<Value> {
    let fr: &FrontierBlock = m.frontier.as_ref()?;
    let mut obj = Map::new();
    obj.insert("mode".into(), Value::String(fr.mode.clone()));
    obj.insert("edge_types".into(), Value::String(fr.edge_types.clone()));
    obj.insert("island_rule".into(), Value::String(fr.island_rule.clone()));

    // bands_summary in declared order
    let bands = fr
        .bands_summary
        .iter()
        .cloned()
        .map(Value::String)
        .collect::<Vec<_>>();
    obj.insert("bands_summary".into(), Value::Array(bands));

    // counters in a fixed key order
    let c: &FrontierCounters = &fr.counters;
    let mut counters = Map::new();
    counters.insert("changed".into(), Value::from(c.changed));
    counters.insert("no_change".into(), Value::from(c.no_change));
    counters.insert("mediation".into(), Value::from(c.mediation));
    counters.insert("enclave".into(), Value::from(c.enclave));
    counters.insert(
        "protected_blocked".into(),
        Value::from(c.protected_blocked),
    );
    counters.insert("quorum_blocked".into(), Value::from(c.quorum_blocked));
    obj.insert("counters".into(), Value::Object(counters));

    Some(Value::Object(obj))
}

/// Policy: include `"sensitivity": "N/A (not executed)"` when absent.
fn sensitivity_json(m: &ReportModel) -> Option<Value> {
    match &m.sensitivity {
        Some(SensitivityBlock { table_2x3 }) => {
            let rows = table_2x3
                .iter()
                .map(|row| Value::Array(row.iter().cloned().map(Value::String).collect()))
                .collect::<Vec<_>>();
            Some(Value::Object(
                [("table_2x3".into(), Value::Array(rows))].into_iter().collect(),
            ))
        }
        None => Some(Value::String("N/A (not executed)".into())),
    }
}

fn integrity_json(m: &ReportModel) -> Value {
    let mut obj = Map::new();
    obj.insert(
        "engine_vendor".into(),
        Value::String(m.integrity.engine_vendor.clone()),
    );
    obj.insert(
        "engine_name".into(),
        Value::String(m.integrity.engine_name.clone()),
    );
    obj.insert(
        "engine_version".into(),
        Value::String(m.integrity.engine_version.clone()),
    );
    obj.insert(
        "engine_build".into(),
        Value::String(m.integrity.engine_build.clone()),
    );
    obj.insert(
        "formula_id_hex".into(),
        Value::String(m.integrity.formula_id_hex.clone()),
    );
    obj.insert(
        "tie_policy".into(),
        Value::String(m.integrity.tie_policy.clone()),
    );
    if let Some(seed) = &m.integrity.tie_seed {
        obj.insert("tie_seed".into(), Value::String(seed.clone()));
    }
    obj.insert(
        "started_utc".into(),
        Value::String(m.integrity.started_utc.clone()),
    );
    obj.insert(
        "finished_utc".into(),
        Value::String(m.integrity.finished_utc.clone()),
    );
    Value::Object(obj)
}

fn footer_json(m: &ReportModel) -> Value {
    let mut obj = Map::new();
    // Strong types display as canonical strings via Display
    obj.insert("result_id".into(), Value::String(m.footer.result_id.to_string()));
    obj.insert("run_id".into(), Value::String(m.footer.run_id.to_string()));
    if let Some(fr) = &m.footer.frontier_id {
        obj.insert("frontier_id".into(), Value::String(fr.to_string()));
    }
    obj.insert("reg_id".into(), Value::String(m.footer.reg_id.clone()));
    obj.insert(
        "param_set_id".into(),
        Value::String(m.footer.param_set_id.clone()),
    );
    if let Some(tly) = &m.footer.tally_id {
        obj.insert("tally_id".into(), Value::String(tly.clone()));
    }
    Value::Object(obj)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::structure::*;

    fn demo_model() -> ReportModel {
        ReportModel {
            cover: CoverSnapshot {
                label: "Decisive".into(),
                reason: Some("All gates passed".into()),
                snapshot_vars: vec![SnapshotVar{ key:"VAR-001".into(), value:"plurality".into() }],
                registry_name: "Demo Registry".into(),
                registry_published_date: "2025-01-01".into(),
            },
            eligibility: EligibilityBlock {
                roll_policy: "Resident roll".into(),
                totals_eligible_roll: 1000,
                totals_ballots_cast: 700,
                totals_valid_ballots: 680,
                per_unit_quorum_note: None,
                provenance: "demo v1".into(),
            },
            ballot: BallotBlock {
                ballot_type: "approval".into(),
                allocation_method: "wta".into(),
                weighting_method: "none".into(),
                approval_denominator_sentence: true,
            },
            panel: LegitimacyPanel {
                quorum: GateRow {
                    value_pct_1dp: "70.0%".into(),
                    threshold_pct_0dp: "50%".into(),
                    pass: true,
                    denom_note: None,
                    members_hint: None,
                },
                majority: GateRow {
                    value_pct_1dp: "55.0%".into(),
                    threshold_pct_0dp: "55%".into(),
                    pass: true,
                    denom_note: Some("approval rate = approvals / valid ballots".into()),
                    members_hint: None,
                },
                double_majority: None,
                symmetry: None,
                pass: true,
                reasons: vec![],
            },
            outcome: OutcomeBlock {
                label: "Decisive".into(),
                reason: "All gates passed".into(),
                national_margin_pp: "+10 pp".into(),
            },
            frontier: None,
            sensitivity: None,
            integrity: IntegrityBlock {
                engine_vendor: "KOA".into(),
                engine_name: "VM".into(),
                engine_version: "0.1.0".into(),
                engine_build: "abc123".into(),
                formula_id_hex: "0".repeat(64),
                tie_policy: "deterministic".into(),
                tie_seed: None,
                started_utc: "2025-08-12T14:00:00Z".into(),
                finished_utc: "2025-08-12T14:00:05Z".into(),
            },
            footer: FooterIds {
                result_id: "RES:0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd".parse().unwrap(),
                run_id: "RUN:2025-08-12T14:00:00Z-0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd".parse().unwrap(),
                frontier_id: None,
                reg_id: "REG:demo".into(),
                param_set_id: "PS:demo".into(),
                tally_id: None,
            },
        }
    }

    #[test]
    fn deterministic_and_in_order() {
        let m = demo_model();
        let s1 = render_json(&m);
        let s2 = render_json(&m);
        assert_eq!(s1, s2);

        // Top-level order sanity (cover → eligibility → ballot → legitimacy_panel → outcome → integrity → footer)
        let cover_pos = s1.find("\"cover\"").unwrap();
        let elig_pos = s1.find("\"eligibility\"").unwrap();
        let ballot_pos = s1.find("\"ballot\"").unwrap();
        let panel_pos = s1.find("\"legitimacy_panel\"").unwrap();
        let outcome_pos = s1.find("\"outcome\"").unwrap();
        let integ_pos = s1.find("\"integrity\"").unwrap();
        let footer_pos = s1.find("\"footer\"").unwrap();
        assert!(cover_pos < elig_pos && elig_pos < ballot_pos && ballot_pos < panel_pos);
        assert!(panel_pos < outcome_pos && outcome_pos < integ_pos && integ_pos < footer_pos);

        // Approval sentence present
        assert!(s1.contains("\"approval_denominator_sentence\":true"));
    }
}

--------------------------------------------------------------------------------
FILE: crates/vm_report/src/render_html.rs
--------------------------------------------------------------------------------
//! vm_report/src/render_html.rs
//! Deterministic, offline HTML renderer for ReportModel (Doc 7).
//! No I/O, no RNG, no external assets.

#![deny(unsafe_code)]

use crate::structure::ReportModel;

// ===== Public API =====

/// Render a ReportModel into a single (or bilingual) HTML string.
/// Deterministic: same model → identical bytes.
pub fn render_html(model: &ReportModel, opts: HtmlRenderOpts) -> String {
    match &opts.bilingual {
        Some(pair) => {
            // Two full documents back-to-back (simple & deterministic).
            let mut out = String::new();
            out.push_str(&render_one(model, &opts, &pair.primary_lang));
            out.push_str("\n<!-- ---- bilingual separator ---- -->\n");
            out.push_str(&render_one(model, &opts, &pair.secondary_lang));
            out
        }
        None => render_one(model, &opts, "en"),
    }
}

// ===== Options & writer =====

#[derive(Clone, Default)]
pub struct HtmlRenderOpts {
    pub bilingual: Option<BilingualPair>, // (primary_lang, secondary_lang)
    pub embed_assets: bool,               // inline CSS/JS/fonts from bundle
}

#[derive(Clone)]
pub struct BilingualPair {
    pub primary_lang: String,
    pub secondary_lang: String,
}

// Minimal writer with deterministic push order.
struct Html {
    buf: String,
}
impl Html {
    fn new() -> Self { Self { buf: String::with_capacity(32 * 1024) } }
    fn push<S: AsRef<str>>(&mut self, s: S) { self.buf.push_str(s.as_ref()); }
    fn finish(self) -> String { self.buf }
}

// ===== Internal: render one full document =====

fn render_one(model: &ReportModel, opts: &HtmlRenderOpts, lang: &str) -> String {
    let mut w = Html::new();

    // Document head
    w.push("<!DOCTYPE html><html lang=\"");
    w.push(esc(lang));
    w.push("\"><head><meta charset=\"utf-8\">\
            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\
            <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\">\
            <title>Voting Model Report</title>");
    if opts.embed_assets {
        w.push("<style>");
        w.push(embed_assets_css());
        // optional fonts (kept empty by default; placeholder included for determinism)
        let fonts = embed_assets_fonts_base64();
        if !fonts.is_empty() {
            w.push(fonts);
        }
        w.push("</style>");
    } else {
        // Still avoid external links; include a minimal default CSS.
        w.push("<style>");
        w.push(MINIMAL_CSS);
        w.push("</style>");
    }
    w.push("</head><body>");

    let (main_role, contentinfo_role) = aria_landmarks();
    w.push("<main "); w.push(main_role); w.push(">");

    // Sections in Doc 7 order
    write_section_cover_snapshot(&mut w, model);
    write_section_eligibility(&mut w, model);
    write_section_ballot(&mut w, model);
    write_section_panel(&mut w, model);
    write_section_outcome(&mut w, model);
    write_section_frontier(&mut w, model);
    write_section_sensitivity(&mut w, model);
    write_section_integrity_footer(&mut w, model);

    w.push("</main>");
    w.push("<footer "); w.push(contentinfo_role); w.push(" class=\"footer-ids\">");
    // IDs line (fixed order; seed shown upstream within Integrity section when applicable)
    w.push("<div class=\"ids\">");
    w.push("<span>Result: "); w.push(esc(&model.footer.result_id.to_string())); w.push("</span>");
    w.push(" · <span>Run: "); w.push(esc(&model.footer.run_id.to_string())); w.push("</span>");
    if let Some(fr) = &model.footer.frontier_id {
        w.push(" · <span>Frontier: "); w.push(esc(&fr.to_string())); w.push("</span>");
    }
    w.push(" · <span>Registry: "); w.push(esc(&model.footer.reg_id.to_string())); w.push("</span>");
    w.push(" · <span>Params: "); w.push(esc(&model.footer.param_set_id.to_string())); w.push("</span>");
    if let Some(tly) = &model.footer.tally_id {
        w.push(" · <span>Tally: "); w.push(esc(&tly.to_string())); w.push("</span>");
    }
    w.push("</div></footer>");

    w.push("</body></html>");
    let mut html = w.finish();
    ensure_keyboard_order(&mut html);
    html
}

// ===== Section writers =====

fn write_section_cover_snapshot(w: &mut Html, m: &ReportModel) {
    w.push("<section id=\"cover\" role=\"region\" aria-labelledby=\"h-cover\">");
    w.push("<h1 id=\"h-cover\">Voting Model Report</h1>");

    // Badge for outcome label on cover
    let label_class = match m.cover.label.as_str() {
        "Decisive" => "badge-dec",
        "Marginal" => "badge-mar",
        _ => "badge-inv",
    };
    w.push("<div class=\"cover-card\">");
    w.push("<div class=\"label-row\"><span class=\"badge ");
    w.push(label_class);
    w.push("\">");
    w.push(esc(&m.cover.label));
    w.push("</span>");
    if let Some(reason) = &m.cover.reason {
        w.push("<span class=\"reason\">");
        w.push(esc(reason));
        w.push("</span>");
    }
    w.push("</div>");

    // Registry provenance
    if !m.cover.registry_name.is_empty() || !m.cover.registry_published_date.is_empty() {
        w.push("<div class=\"registry\">");
        if !m.cover.registry_name.is_empty() {
            w.push("<span class=\"k\">Registry</span><span class=\"v\">");
            w.push(esc(&m.cover.registry_name));
            w.push("</span>");
        }
        if !m.cover.registry_published_date.is_empty() {
            w.push("<span class=\"k\">Published</span><span class=\"v\">");
            w.push(esc(&m.cover.registry_published_date));
            w.push("</span>");
        }
        w.push("</div>");
    }

    // Snapshot variables
    if !m.cover.snapshot_vars.is_empty() {
        w.push("<dl class=\"snapshot\">");
        for kv in &m.cover.snapshot_vars {
            w.push("<dt>");
            w.push(esc(&kv.key));
            w.push("</dt><dd>");
            w.push(esc(&kv.value));
            w.push("</dd>");
        }
        w.push("</dl>");
    }

    w.push("</div></section>");
}

fn write_section_eligibility(w: &mut Html, m: &ReportModel) {
    w.push("<section id=\"eligibility\" role=\"region\" aria-labelledby=\"h-elig\">");
    w.push("<h2 id=\"h-elig\">Eligibility & Rolls</h2>");

    w.push("<div class=\"elig-grid\">");
    w.push("<div class=\"row\"><span class=\"k\">Roll policy</span><span class=\"v\">");
    w.push(esc(&m.eligibility.roll_policy));
    w.push("</span></div>");

    w.push("<div class=\"row\"><span class=\"k\">Eligible roll (Σ)</span><span class=\"v\">");
    w.push(m.eligibility.totals_eligible_roll.to_string());
    w.push("</span></div>");

    w.push("<div class=\"row\"><span class=\"k\">Ballots cast (Σ)</span><span class=\"v\">");
    w.push(m.eligibility.totals_ballots_cast.to_string());
    w.push("</span></div>");

    w.push("<div class=\"row\"><span class=\"k\">Valid ballots (Σ)</span><span class=\"v\">");
    w.push(m.eligibility.totals_valid_ballots.to_string());
    w.push("</span></div>");

    if let Some(note) = &m.eligibility.per_unit_quorum_note {
        w.push("<div class=\"note\">");
        w.push(esc(note));
        w.push("</div>");
    }
    if !m.eligibility.provenance.is_empty() {
        w.push("<div class=\"provenance\">");
        w.push(esc(&m.eligibility.provenance));
        w.push("</div>");
    }
    w.push("</div></section>");
}

fn write_section_ballot(w: &mut Html, m: &ReportModel) {
    w.push("<section id=\"ballot\" role=\"region\" aria-labelledby=\"h-ballot\">");
    w.push("<h2 id=\"h-ballot\">Ballot & Allocation</h2>");

    w.push("<ul class=\"kv\">");
    w.push("<li><span class=\"k\">Ballot type</span><span class=\"v\">");
    w.push(esc(&m.ballot.ballot_type));
    w.push("</span></li>");
    w.push("<li><span class=\"k\">Allocation</span><span class=\"v\">");
    w.push(esc(&m.ballot.allocation_method));
    w.push("</span></li>");
    w.push("<li><span class=\"k\">Weighting</span><span class=\"v\">");
    w.push(esc(&m.ballot.weighting_method));
    w.push("</span></li>");
    w.push("</ul>");

    if m.ballot.approval_denominator_sentence {
        w.push("<p class=\"aside\"><em>Approval rate is computed as ");
        w.push("<code>approvals</code> / <code>valid ballots</code>.</em></p>");
    }

    w.push("</section>");
}

fn write_section_panel(w: &mut Html, m: &ReportModel) {
    w.push("<section id=\"legitimacy\" role=\"region\" aria-labelledby=\"h-leg\">");
    w.push("<h2 id=\"h-leg\">Legitimacy Gates</h2>");

    // Table with quorum + majority (always shown)
    w.push("<table class=\"panel\"><thead><tr>\
            <th>Gate</th><th>Observed</th><th>Threshold</th><th>Status</th>\
            </tr></thead><tbody>");

    // Row helper
    let mut row = |name: &str, val: &str, th: &str, pass: bool| {
        w.push("<tr><td>");
        w.push(esc(name));
        w.push("</td><td>");
        w.push(esc(val));
        w.push("</td><td>");
        w.push(esc(th));
        w.push("</td><td>");
        if pass { w.push("✅ Pass"); } else { w.push("❌ Fail"); }
        w.push("</td></tr>");
    };

    row("Quorum", &m.panel.quorum.value_pct_1dp, &m.panel.quorum.threshold_pct_0dp, m.panel.quorum.pass);
    row("Majority", &m.panel.majority.value_pct_1dp, &m.panel.majority.threshold_pct_0dp, m.panel.majority.pass);

    if let Some((nat, fam)) = &m.panel.double_majority {
        row("Double majority — National", &nat.value_pct_1dp, &nat.threshold_pct_0dp, nat.pass);
        row("Double majority — Family", &fam.value_pct_1dp, &fam.threshold_pct_0dp, fam.pass);
    }

    w.push("</tbody></table>");

    if let Some(sym) = m.panel.symmetry {
        w.push("<p class=\"symmetry\">Symmetry respected: ");
        w.push(if sym { "true" } else { "false" });
        w.push("</p>");
    }

    if !m.panel.reasons.is_empty() && !m.panel.pass {
        w.push("<div class=\"reasons\"><strong>Reasons:</strong><ul>");
        for r in &m.panel.reasons {
            w.push("<li>"); w.push(esc(r)); w.push("</li>");
        }
        w.push("</ul></div>");
    }

    w.push("</section>");
}

fn write_section_outcome(w: &mut Html, m: &ReportModel) {
    w.push("<section id=\"outcome\" role=\"region\" aria-labelledby=\"h-out\">");
    w.push("<h2 id=\"h-out\">Outcome</h2>");
    let label_class = match m.outcome.label.as_str() {
        "Decisive" => "badge-dec",
        "Marginal" => "badge-mar",
        _ => "badge-inv",
    };
    w.push("<p class=\"outcome\"><span class=\"badge ");
    w.push(label_class);
    w.push("\">");
    w.push(esc(&m.outcome.label));
    w.push("</span> — ");
    w.push(esc(&m.outcome.reason));
    w.push("</p>");
    w.push("<p class=\"margin\">National margin: <strong>");
    w.push(esc(&m.outcome.national_margin_pp));
    w.push("</strong></p>");
    w.push("</section>");
}

fn write_section_frontier(w: &mut Html, m: &ReportModel) {
    if let Some(fr) = &m.frontier {
        w.push("<section id=\"frontier\" role=\"region\" aria-labelledby=\"h-fr\">");
        w.push("<h2 id=\"h-fr\">Frontier</h2>");

        w.push("<ul class=\"kv\">");
        w.push("<li><span class=\"k\">Mode</span><span class=\"v\">");
        w.push(esc(&fr.mode));
        w.push("</span></li>");
        w.push("<li><span class=\"k\">Edge policy</span><span class=\"v\">");
        w.push(esc(&fr.edge_types));
        w.push("</span></li>");
        w.push("<li><span class=\"k\">Island rule</span><span class=\"v\">");
        w.push(esc(&fr.island_rule));
        w.push("</span></li>");
        w.push("</ul>");

        // Counters
        w.push("<div class=\"fr-counters\">");
        let c = &fr.counters;
        w.push(format!("<span>Changed: {}</span>", c.changed).as_str());
        w.push(" · ");
        w.push(format!("<span>No change: {}</span>", c.no_change).as_str());
        w.push(" · ");
        w.push(format!("<span>Mediation: {}</span>", c.mediation).as_str());
        w.push(" · ");
        w.push(format!("<span>Enclave: {}</span>", c.enclave).as_str());
        w.push(" · ");
        w.push(format!("<span>Protected blocked: {}</span>", c.protected_blocked).as_str());
        w.push(" · ");
        w.push(format!("<span>Quorum blocked: {}</span>", c.quorum_blocked).as_str());
        w.push("</div>");

        if !fr.bands_summary.is_empty() {
            w.push("<div class=\"bands\"><strong>Bands:</strong> <ul>");
            for b in &fr.bands_summary {
                w.push("<li>"); w.push(esc(b)); w.push("</li>");
            }
            w.push("</ul></div>");
        }

        w.push("</section>");
    }
}

fn write_section_sensitivity(w: &mut Html, m: &ReportModel) {
    w.push("<section id=\"sensitivity\" role=\"region\" aria-labelledby=\"h-sens\">");
    w.push("<h2 id=\"h-sens\">Sensitivity</h2>");
    if let Some(s) = &m.sensitivity {
        w.push("<table class=\"sens\"><tbody>");
        for row in &s.table_2x3 {
            w.push("<tr>");
            for cell in row {
                w.push("<td>"); w.push(esc(cell)); w.push("</td>");
            }
            w.push("</tr>");
        }
        w.push("</tbody></table>");
    } else {
        w.push("<p class=\"na\">N/A (not executed)</p>");
    }
    w.push("</section>");
}

fn write_section_integrity_footer(w: &mut Html, m: &ReportModel) {
    w.push("<section id=\"integrity\" role=\"region\" aria-labelledby=\"h-int\">");
    w.push("<h2 id=\"h-int\">Integrity & Reproducibility</h2>");
    w.push("<ul class=\"kv\">");
    w.push("<li><span class=\"k\">Engine</span><span class=\"v\">");
    w.push(esc(&m.integrity.engine_vendor));
    w.push(" / ");
    w.push(esc(&m.integrity.engine_name));
    w.push(" ");
    w.push(esc(&m.integrity.engine_version));
    w.push(" (");
    w.push(esc(&m.integrity.engine_build));
    w.push(")</span></li>");
    w.push("<li><span class=\"k\">Formula ID</span><span class=\"v mono\">");
    w.push(esc(&m.integrity.formula_id_hex));
    w.push("</span></li>");
    w.push("<li><span class=\"k\">Tie policy</span><span class=\"v\">");
    w.push(esc(&m.integrity.tie_policy));
    if m.integrity.tie_policy == "random" {
        if let Some(seed) = &m.integrity.tie_seed {
            w.push(" — seed ");
            w.push(esc(seed));
        }
    }
    w.push("</span></li>");
    w.push("<li><span class=\"k\">Started (UTC)</span><span class=\"v\">");
    w.push(esc(&m.integrity.started_utc));
    w.push("</span></li>");
    w.push("<li><span class=\"k\">Finished (UTC)</span><span class=\"v\">");
    w.push(esc(&m.integrity.finished_utc));
    w.push("</span></li>");
    w.push("</ul>");
    w.push("</section>");
}

// ===== Utilities =====

fn embed_assets_css() -> &'static str {
    // Simple, deterministic, offline CSS (no external @import).
    r#"html{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji";line-height:1.35}
body{margin:0;padding:0;background:#fff;color:#111}
main{display:block;max-width:980px;margin:0 auto;padding:24px}
h1,h2{margin:.2em 0 .4em 0}
h1{font-size:1.8rem} h2{font-size:1.3rem}
.k{color:#444;margin-right:.5rem}
.v{color:#000}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace}
.cover-card{border:1px solid #ddd;border-radius:8px;padding:16px;margin:8px 0 16px}
.snapshot{display:grid;grid-template-columns:max-content 1fr;gap:8px 16px;margin-top:8px}
.elig-grid .row{display:flex;gap:12px;margin:4px 0}
.note{margin-top:8px;color:#333}
.provenance{margin-top:6px;color:#555}
.kv{list-style:none;padding-left:0} .kv li{margin:4px 0}
.panel{border-collapse:collapse;width:100%;margin:8px 0}
.panel th,.panel td{border:1px solid #ddd;padding:6px 8px;text-align:left}
.badge{display:inline-block;font-weight:600;padding:.15rem .5rem;border-radius:6px}
.badge-dec{background:#e6ffed;color:#046a1d;border:1px solid #b4f2c2}
.badge-mar{background:#fff7e6;color:#7f4b00;border:1px solid #f2deaf}
.badge-inv{background:#ffe6e6;color:#8a0000;border:1px solid #f2bbbb}
.outcome{font-size:1.05rem}
.margin{color:#333}
.fr-counters{margin:.5rem 0;color:#222}
.bands ul{margin:.3rem 0 .6rem 1rem}
.aside{color:#333}
.na{color:#555;font-style:italic}
.footer-ids{background:#f8f8f8;border-top:1px solid #e5e5e5;padding:10px 16px}
.footer-ids .ids{max-width:980px;margin:0 auto;color:#333}
"#
}

fn embed_assets_fonts_base64() -> &'static str {
    // Keep empty by default to avoid inflating output; placeholder for future.
    ""
}

const MINIMAL_CSS: &str = r#"body{font-family:system-ui,Arial,sans-serif}main{max-width:980px;margin:0 auto;padding:24px}"#;

/// Keep tab/anchor order stable; currently a no-op with fixed layout.
fn ensure_keyboard_order(_html: &mut String) {}

/// ARIA roles for main & footer landmarks.
fn aria_landmarks() -> (&'static str, &'static str) { ("role=\"main\"", "role=\"contentinfo\"") }

/// Minimal HTML escaping (no allocations beyond return String).
fn esc<S: AsRef<str>>(s: S) -> String {
    let mut out = String::with_capacity(s.as_ref().len() + 8);
    for ch in s.as_ref().chars() {
        match ch {
            '&' => out.push_str("&amp;"),
            '<' => out.push_str("&lt;"),
            '>' => out.push_str("&gt;"),
            '"' => out.push_str("&quot;"),
            '\''=> out.push_str("&#39;"),
            _   => out.push(ch),
        }
    }
    out
}

<!-- Converted from: 05 - .gitignore, Version FormulaID VM-ENGINE v0).docx on 2025-08-12T18:20:45.736746Z -->

```gitignore
Pre-Coding Essentials (Component: .gitignore, Version/FormulaID: VM-ENGINE v0) — 5/89
1) Goal & Success
Goal: Ignore build artifacts, caches, and local/IDE noise while tracking all normative inputs (schemas, fixtures, vendor).
Success: git status shows only source/doc/spec changes; no accidental commits of target/, artifacts/, UI build output, or OS clutter.
2) Scope
In scope: workspace-wide ignore rules for Rust, Tauri UI, CI artifacts, OS/IDE files.
Out of scope: line-ending normalization (.gitattributes), editor formatting (.editorconfig).
3) Inputs → Outputs
Inputs: Cargo workspace, Tauri UI subproject, Makefile output locations.
Outputs: Clean VCS state; reproducible clones (no missing required files like vendor/, schemas/, fixtures/).
4) Entities/Tables
5) Variables
6) Functions
(None.)
7) Algorithm Outline (rules to include)
Add the following patterns, in this order (specific → generic), with comments:
gitignore
CopyEdit
# --- Rust / Cargo ---
/target/
/**/target/
**/*.rs.bk

# Coverage / profiling (if used)
*.profraw
*.gcda
*.gcno
*.lcov

# --- Workspace artifacts (transient) ---
/artifacts/
/dist/
/tmp/
/.cache/

# --- Tauri (Rust side) ---
/crates/vm_app/src-tauri/target/
/crates/vm_app/src-tauri/.tauri-build
/crates/vm_app/src-tauri/.cargo-lock-backup

# --- Frontend (Vite/Node) ---
/crates/vm_app/ui/node_modules/
/crates/vm_app/ui/.vite/
/crates/vm_app/ui/dist/
/crates/vm_app/ui/npm-debug.log*
/crates/vm_app/ui/yarn-error.log*
/crates/vm_app/ui/pnpm-lock.yaml # keep lock if you decide to pin; otherwise ignore

# --- OS / editors ---
.DS_Store
Thumbs.db
Desktop.ini
*.log
*.tmp
*.bak
*~
*.swp
*.swo
.idea/
.vscode/

# --- Test run byproducts (safety) ---
**/*.assert.out
**/*.assert.err

# --- DO NOT IGNORE (must be tracked) ---
# (Documentation comments only; no patterns needed.)
# - vendor/            (keep for offline builds)
# - schemas/           (normative JSON Schemas)
# - fixtures/          (Annex B test data)
# - crates/vm_app/ui/public/map/tiles/*.mbtiles (bundled tiles)

8) State Flow
Developers run builds/tests → outputs land in ignored folders → repo stays clean.
9) Determinism & Numeric Rules
N/A (supports determinism by ensuring canonical inputs are versioned and transient outputs are not).
10) Edge Cases & Failure Policy
If you later vendor dependencies, ensure vendor/ is not ignored (leave as tracked).
If CI needs to diff generated reports, write them outside artifacts/ or temporarily remove that rule in CI-only .gitignore overrides.
Keep lockfiles (Cargo.lock, UI lockfile if chosen) tracked for reproducibility.
11) Test Checklist (must pass)
Fresh clone + make ci → git status clean.
Create dummy files in each ignored dir → git status still clean.
Verify schemas/, fixtures/, vendor/ remain unignored (e.g., add a file and see it appear in git status).
```


awesome—here’s a tight “coding brief” for **file 5** so we can implement it cleanly next, fully aligned with your 10 reference docs. I’m assuming **file 5 = the Gates / Apply-Decision-Rules stage** (the thing that evaluates quorum/majority/double-majority, applies eligibility overrides & exceptions, sets the **Invalid** label and skips Frontier when appropriate). If that assumption’s off, the checklist below still gives you everything needed to wire the gates stage wherever file 5 lives.

---

# What we need to code file 5 (Gates)

## 1) Purpose (one line)

Implement **S2: Eligibility & validity gates (Doc 4B)** with deterministic ordering, precedence, and reason recording; mark units Invalid when a gate fails; ensure Frontier is skipped for invalid units.&#x20;

---

## 2) Inputs & outputs (types we must read/emit)

**Inputs (from prior stages / DB):**

* `DivisionRegistry` (units, option order, flags like protected areas, any tags/families used by “affected family”). IDs/ordering must already be valid (Doc 1).&#x20;
* `BallotTally` per unit (valid/invalid ballots; per-option tallies; approvals\_for\_change if approval; totals for turnout).&#x20;
* `ParameterSet` with the **included** VM-VARs for gates & precedence (see §3).&#x20;

**Outputs (to Result/RunRecord, and for later stages):**

* Per-unit **gate status** + **reasons\[]** (ordered) in `RunRecord.summary.units[]`. For invalid units, `allocations=[]`, label `Invalid`, and **Frontier is omitted**. Record `protected_bypass` and `applied_exceptions` when applicable.&#x20;
* A compact **Gate panel** in `Result` (quorum/majority/double\_majority/symmetry—numbers and pass/fail flags; preformatted compare strings are fine but not required by this file).&#x20;

---

## 3) VM-VARs & precedence we must support

**Core gates / thresholds (this edition’s IDs & names):**

* 012–017: eligibility/sanity family (min/other floors as per release use; treat as part of “sanity/eligibility” pass).&#x20;
* **020..028**: generic thresholds A..H (bind them to concrete meanings in this release—e.g., national majority=**020**=55, regional majority=**022**=55—via the ParameterSet/fixtures). Implement as integer cutoffs with **≥** rule.&#x20;
* **029** `symmetry_exceptions`: deterministic allow/deny selectors; *narrow* eligibility overrides (record in `applied_exceptions[]`).&#x20;
* **030** `eligibility_override_list`: explicit include/exclude list; **applies before 029** (hard precedence).&#x20;
* **031** `ballot_integrity_floor`: cannot be bypassed by 029 or protected areas.&#x20;
* **045** protected-area policy: may **bypass eligibility only** if allowed; never bypass Sanity/Integrity.&#x20;

**Precedence & ordering (must implement exactly):**

* Evaluate in stage order **Sanity → Eligibility → Validity → Frontier pre-check**, and within a stage, record reasons **ascending by VM-VAR id**.&#x20;
* **030 before 029**; record both (030 in `reasons`, 029 in `applied_exceptions[]` if matched).&#x20;
* Protected bypass (045) can skip eligibility **only**; never skip integrity floor (031).&#x20;

---

## 4) Gate math rules we must encode

* **Turnout/quorum**: turnout = Σ`ballots_cast` / Σ`eligible_roll` (integer math). Compare against threshold(s) with **≥** (no floats).&#x20;
* **Majority/supermajority**:

  * If **approval ballots**, **support = approvals\_for\_change / valid\_ballots** (fixed “approval-rate” denominator). This is a normative rule for gates; ignore any “approval share” notion. Edge at 55.0% must **Pass** (≥).
  * For non-approval families, use the release binding (e.g., votes\_for\_change / valid\_ballots); still integer math with ≥.
* **Double-majority** (when present): compute **national support** and **affected-family support** using the same denominator policy as above; both must meet their thresholds (e.g., 55/55). Family selection via ParameterSet (list/tag) **must not depend on Frontier**, per tests.&#x20;
* **Symmetry**: compute/report symmetry-neutrality (identical denominator/threshold treatment in mirrored A→B vs B→A runs). Treated as a panel check; not a hard invalidator in this suite.&#x20;

---

## 5) Determinism & recording requirements

* Integer/rational comparisons only; **no floats** in artifacts.&#x20;
* If any gate fails for a unit: set unit `Invalid`, **skip Frontier** for that unit/run per doc’s branch rule; allocations empty; label `Invalid`.&#x20;
* **Reasons\[]**: include **every** failing gate; sort by VM-VAR id ascending; then append symbolic reasons (e.g., `"frontier_missing_inputs"`) in lexicographic order.&#x20;
* Record `protected_bypass=true` only when 045 actually bypassed an eligibility failure.&#x20;

---

## 6) Function surface (suggested)

* `apply_gates(unit_ctx, params) -> GateOutcome`

  * `GateOutcome { valid: bool, reasons: Vec<ReasonTok>, protected_bypass: bool, applied_exceptions: Vec<String>, panel: GatePanel }`
* Helpers:

  * `cmp_ge_pct(numer:u128, denom:u128, threshold_pct:u32) -> bool` (integer math; handles denom=0).
  * `approval_support(unit_ctx) -> (numer,denom)` returning `(approvals_for_change, valid_ballots)` for approval ballots.&#x20;
  * `select_affected_family(registry, params) -> BTreeSet<UnitId>` (list/tag mode only for tests; document that “by\_proposed\_change” needs Frontier and is **invalid** with `frontier_mode=none`).&#x20;
  * `record_reason(id, short) -> ReasonTok` producing `"VM-VAR-0xx:short_name"` (token grammar per Annex C).&#x20;

---

## 7) Edge cases (must-handle)

* **Denominator=0**: treat support as 0/0 ⇒ **Fail** if threshold>0; still record reason deterministically. (Keeps math integer-safe; consistent with tests.)
* **Frontier enabled but inputs missing**: add symbolic reason `"frontier_missing_inputs"`, and unit is invalid.&#x20;
* **Protected area set but 045=deny**: no effect; do **not** mark bypass.&#x20;
* **029/030 precedence** conflict: 030 (exclude) wins; include in `reasons`; 029 recorded only in `applied_exceptions` if it matched.&#x20;

---

## 8) Conformance targets (tie to tests/fixtures)

Implement so these canonical expectations pass verbatim:

* **Supermajority edge (55.0%)** → **Pass** (≥) and Decisive (VM-TST-004). Uses approval-rate denominator.&#x20;
* **Quorum fail (48%)** → **Invalid**, **Frontier omitted** (VM-TST-005).&#x20;
* **Double-majority family fail**: national pass, family 53% < 55% ⇒ **Invalid**; reason mentions regional threshold (VM-TST-006).&#x20;
* **Symmetry mirrored pass**: A→B and B→A at 56% both **Pass** with identical denominator/threshold handling (VM-TST-007).&#x20;
* **6B gates suite**: reasons ordering (201–202), 029 exceptions (203), **030 over 029** precedence (204), integrity floor non-bypass (205/207), protected-area bypass only for eligibility (206), frontier pre-check token (208).

---

## 9) Data we’ll read/produce (field checklist)

**We must read (per unit):**

* `valid_ballots`, `invalid_ballots`, `eligible_roll`, `ballots_cast`.
* For approval: `approvals_for_change`.
* Any unit flags: protected area, tags/family membership (for affected family selection).

**We must write:**

* `Result.gates.panel` fields for quorum/majority/double\_majority/symmetry (pass flags + raw numerators/denominators + thresholds).
* `RunRecord.summary.units[]` with: `gate_status`, `reasons[]`, `protected_bypass?`, `applied_exceptions[]`, `frontier_ready`. Token/ordering rules per Doc 4B.&#x20;

---

## 10) Assumptions we’ll lock (to keep consistent with the edition)

* The **majority thresholds** used by this release’s fixtures bind **020 (national)** and **022 (regional)** to **55%** unless a case overrides. (Annex A presents threshold\_A..H; the fixtures bind concrete values.)&#x20;
* **Approval gate denominator** is **always** `valid_ballots` (approval-rate), not widenable by other toggles.&#x20;
* **Symmetry** is a reported check, not a hard invalidator in the featured tests.&#x20;

---

## 11) Ready-to-code to-dos (so implementation is frictionless)

* [ ] Define `GatePanel` and `GateOutcome` structs (with raw counts + pass flags).
* [ ] Implement comparator `ge_pct_int(n,d,thr)` with 64/128-bit intermediates.
* [ ] Implement 030→029 precedence and record-ordering utilities.
* [ ] Implement affected-family selector (list/tag) independent of Frontier.
* [ ] Wire **branching**: any gate failure ⇒ unit Invalid; ensure pipeline skips S3 Frontier for the run (or per unit as your engine models it).&#x20;
* [ ] Emit RunRecord tokens with **exact** ordering and names (Annex C grammar).&#x20;
* [ ] Unit tests: cover the four gate smoke tests (004–007) + 6B reasons/precedence/ protected/integrity/frontier-precheck cases.&#x20;

---

That’s everything I need on my side to implement file 5 precisely and keep it locked to the reference docs. If file 5 is meant to be a different stage, I’ll transpose the same level of prep to that module, but the above matches the gates step the rest of your suite is exercising.
